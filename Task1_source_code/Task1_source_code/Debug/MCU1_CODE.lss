
MCU1_CODE.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000000e2  00000000  00000000  000001b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00800060  000000e2  000002c0  2**0
                  ALLOC
  2 .bss          0000001e  00800060  00800060  000024b3  2**0
                  ALLOC
  3 .comment      0000002f  00000000  00000000  000024b3  2**0
                  CONTENTS, READONLY
  4 .stack.descriptors.hdr 00000142  00000000  00000000  000024e2  2**0
                  CONTENTS, READONLY
  5 .debug_aranges 00000578  00000000  00000000  00002628  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00008711  00000000  00000000  00002ba0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001699  00000000  00000000  0000b2b1  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000345b  00000000  00000000  0000c94a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000dd0  00000000  00000000  0000fda8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000007f1  00000000  00000000  00010b78  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00004baf  00000000  00000000  00011369  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000470  00000000  00000000  00015f18  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .text         00000004  000022ec  000022ec  000024a0  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 14 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00016388  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .text.Initialize_E2PROM_State 00000016  0000217c  0000217c  00002330  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 16 .text.Read_E2PROM_State 0000000c  00002262  00002262  00002416  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 17 .text.App_Init 00000060  0000191c  0000191c  00001ad0  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 18 .text.check_State 000000a0  000011d8  000011d8  0000138c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 19 .text.handle_State 00000110  000007ce  000007ce  00000982  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 20 .text.UART_Transmit_State 0000004a  00001ce4  00001ce4  00001e98  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 21 .data.EEPROM_State_Add 00000001  008006b2  00000111  000002c5  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 22 .bss.DC_fan1  00000001  008006b3  008006b3  000024b3  2**0
                  ALLOC
 23 .bss.buttonPressed 00000001  008006b4  008006b4  000024b3  2**0
                  ALLOC
 24 .bss.currentState 00000001  008006b5  008006b5  000024b3  2**0
                  ALLOC
 25 .text.Initialize_TEMP_SENSOR 0000000c  0000226e  0000226e  00002422  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 26 .text.Read_TEMP_SENSOR 00000030  00001f9c  00001f9c  00002150  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 27 .text.DC_Initialize 00000052  00001ba8  00001ba8  00001d5c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 28 .text.DC_Start 00000090  00001310  00001310  000014c4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 29 .text.DC_Stop 0000004e  00001c4a  00001c4a  00001dfe  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 30 .text.DC_Change_Speed 00000026  00001ffa  00001ffa  000021ae  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 31 .text.tmp     00000016  00002192  00002192  00002346  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 32 .text.uart    0000001e  000020d4  000020d4  00002288  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 33 .text.eestate 0000001e  000020f2  000020f2  000022a6  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 34 .text.fan1    00000026  00002020  00002020  000021d4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 35 .progmemx.data 0000002a  000000e2  000000e2  00000296  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, PROGMEMX
 36 .text.main    00000102  000008de  000008de  00000a92  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 37 .text.__vector_1 0000007c  0000153a  0000153a  000016ee  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 38 .data.Speed_Scale 00000001  008006b6  000022fe  000024b2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 39 .bss.temperature 00000002  008006a2  008006a2  000024b3  2**0
                  ALLOC
 40 .bss.temp_counter 00000001  008006b7  008006b7  000024b3  2**0
                  ALLOC
 41 .bss.bot1_intur 00000001  008006b8  008006b8  000024b3  2**0
                  ALLOC
 42 .bss.reset    00000001  008006b9  008006b9  000024b3  2**0
                  ALLOC
 43 .text.ADC_Initialize 0000000e  0000222a  0000222a  000023de  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 44 .text.ADC_Read 00000074  00001630  00001630  000017e4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 45 .text.DIO_SetPinDirection 000000e2  000009e0  000009e0  00000b94  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 46 .text.DIO_SetPinValue 000000e2  00000ac2  00000ac2  00000c76  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 47 .text.External_Interrupt0_Initalize 00000058  00001b50  00001b50  00001d04  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 48 .text.UART_Initialize_WithoutInterrupt 00000120  000006ae  000006ae  00000862  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 49 .text.UART_Transmit_Character 0000000a  000022aa  000022aa  0000245e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 50 .text.UART_Transmit_Word 0000001c  00002110  00002110  000022c4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 51 .text.WDT_ON  0000000c  0000227a  0000227a  0000242e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 52 .text.pvPortMalloc 0000006a  00001786  00001786  0000193a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 53 .text.vPortFree 00000002  000022f4  000022f4  000024a8  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 54 .bss.pucAlignedHeap.1961 00000002  008006a4  008006a4  000024b3  2**0
                  ALLOC
 55 .bss.xNextFreeByte 00000002  008006a6  008006a6  000024b3  2**0
                  ALLOC
 56 .bss.ucHeap   000005dc  0080007e  0080007e  000024b3  2**0
                  ALLOC
 57 .text.vListInitialise 0000001c  0000212c  0000212c  000022e0  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 58 .text.vListInitialiseItem 00000008  000022c8  000022c8  0000247c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 59 .text.vListInsertEnd 00000042  00001e42  00001e42  00001ff6  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 60 .text.vListInsert 00000062  000018ba  000018ba  00001a6e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 61 .text.uxListRemove 0000004c  00001c98  00001c98  00001e4c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 62 .text.prvSetupTimerInterrupt 00000012  000021d4  000021d4  00002388  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 63 .text.pxPortInitialiseStack 000000d8  00000c86  00000c86  00000e3a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 64 .text.xPortStartScheduler 0000005e  000019dc  000019dc  00001b90  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 65 .text.vPortYield 000000b2  00001126  00001126  000012da  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 66 .text.vPortYieldFromTick 000000b8  00000fb6  00000fb6  0000116a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 67 .text.__vector_7 00000006  000022e0  000022e0  00002494  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 68 .text.prvIsQueueEmpty 00000026  00002046  00002046  000021fa  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 69 .text.prvIsQueueFull 00000038  00001efc  00001efc  000020b0  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 70 .text.prvCopyDataToQueue 000000c0  00000ef6  00000ef6  000010aa  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 71 .text.prvCopyDataFromQueue 00000036  00001f34  00001f34  000020e8  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 72 .text.prvUnlockQueue 00000074  000016a4  000016a4  00001858  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 73 .text.xQueueGenericReset 0000008e  000013a0  000013a0  00001554  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 74 .text.xQueueGenericCreate 0000005c  00001a98  00001a98  00001c4c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 75 .text.xQueueGenericSend 0000012e  00000580  00000580  00000734  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 76 .text.xQueueGenericReceive 0000017e  00000112  00000112  000002c6  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 77 .text.prvResetNextTaskUnblockTime 0000003e  00001e84  00001e84  00002038  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 78 .text.prvAllocateTCBAndStack 00000050  00001bfa  00001bfa  00001dae  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 79 .text.prvDeleteTCB 0000001a  00002148  00002148  000022fc  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 80 .text.prvInitialiseTCBVariables 0000008c  0000142e  0000142e  000015e2  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 81 .text.prvInitialiseTaskLists 00000066  000017f0  000017f0  000019a4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 82 .text.prvAddCurrentTaskToDelayedList 0000006e  00001718  00001718  000018cc  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 83 .text.xTaskGenericCreate 00000178  00000290  00000290  00000444  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 84 .progmemx.data 00000005  0000010c  0000010c  000002c0  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, PROGMEMX
 85 .text.vTaskStartScheduler 00000060  0000197c  0000197c  00001b30  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 86 .text.vTaskSuspendAll 0000000c  00002286  00002286  0000243a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 87 .text.xTaskIncrementTick 00000178  00000408  00000408  000005bc  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 88 .text.xTaskResumeAll 000000e2  00000ba4  00000ba4  00000d58  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 89 .text.vTaskDelay 00000044  00001d76  00001d76  00001f2a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 90 .text.prvCheckTasksWaitingTermination 0000005c  00001af4  00001af4  00001ca8  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 91 .text.prvIdleTask 00000012  000021e6  000021e6  0000239a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 92 .text.vTaskSwitchContext 000000b8  0000106e  0000106e  00001222  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 93 .text.vTaskPlaceOnEventList 0000003a  00001ec2  00001ec2  00002076  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 94 .text.xTaskRemoveFromEventList 00000098  00001278  00001278  0000142c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 95 .text.vTaskSetTimeOutState 00000016  000021a8  000021a8  0000235c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 96 .text.xTaskCheckForTimeOut 00000064  00001856  00001856  00001a0a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 97 .text.vTaskMissedYield 00000008  000022d0  000022d0  00002484  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 98 .text.vTaskPriorityInherit 000000c4  00000e32  00000e32  00000fe6  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 99 .text.xTaskPriorityDisinherit 00000080  000014ba  000014ba  0000166e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
100 .text.pvTaskIncrementMutexHeldCount 00000024  0000206c  0000206c  00002220  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
101 .bss.uxSchedulerSuspended 00000001  008006ba  008006ba  000024b3  2**0
                  ALLOC
102 .data.xNextTaskUnblockTime 00000002  008006a8  000022fc  000024b0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
103 .bss.uxTaskNumber 00000001  008006bb  008006bb  000024b3  2**0
                  ALLOC
104 .bss.xNumOfOverflows 00000001  008006bc  008006bc  000024b3  2**0
                  ALLOC
105 .bss.xYieldPending 00000001  008006bd  008006bd  000024b3  2**0
                  ALLOC
106 .bss.uxPendedTicks 00000001  008006be  008006be  000024b3  2**0
                  ALLOC
107 .bss.xSchedulerRunning 00000001  008006bf  008006bf  000024b3  2**0
                  ALLOC
108 .bss.uxTopReadyPriority 00000001  008006c0  008006c0  000024b3  2**0
                  ALLOC
109 .bss.xTickCount 00000002  008006aa  008006aa  000024b3  2**0
                  ALLOC
110 .bss.uxCurrentNumberOfTasks 00000001  008006c1  008006c1  000024b3  2**0
                  ALLOC
111 .bss.uxTasksDeleted 00000001  008006c2  008006c2  000024b3  2**0
                  ALLOC
112 .bss.xTasksWaitingTermination 00000009  0080067e  0080067e  000024b3  2**0
                  ALLOC
113 .bss.xPendingReadyList 00000009  00800687  00800687  000024b3  2**0
                  ALLOC
114 .bss.pxOverflowDelayedTaskList 00000002  008006ac  008006ac  000024b3  2**0
                  ALLOC
115 .bss.pxDelayedTaskList 00000002  008006ae  008006ae  000024b3  2**0
                  ALLOC
116 .bss.xDelayedTaskList2 00000009  00800690  00800690  000024b3  2**0
                  ALLOC
117 .bss.xDelayedTaskList1 00000009  00800699  00800699  000024b3  2**0
                  ALLOC
118 .bss.pxReadyTasksLists 00000024  0080065a  0080065a  000024b3  2**0
                  ALLOC
119 .bss.pxCurrentTCB 00000002  008006b0  008006b0  000024b3  2**0
                  ALLOC
120 .text         0000000a  000022b4  000022b4  00002468  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
121 .text         0000005e  00001a3a  00001a3a  00001bee  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
122 .text         0000007a  000015b6  000015b6  0000176a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
123 .text         00000048  00001d2e  00001d2e  00001ee2  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
124 .text         00000044  00001dba  00001dba  00001f6e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
125 .text         0000000e  00002238  00002238  000023ec  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
126 .text         0000000a  000022be  000022be  00002472  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
127 .text         00000008  000022d8  000022d8  0000248c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
128 .text         000000d4  00000d5e  00000d5e  00000f12  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
129 .text         0000000c  00002292  00002292  00002446  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
130 .text         00000006  000022e6  000022e6  0000249a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
131 .text         0000000e  00002246  00002246  000023fa  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
132 .text         0000000e  00002254  00002254  00002408  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
133 .text         00000022  00002090  00002090  00002244  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
134 .text.libgcc.div 00000044  00001dfe  00001dfe  00001fb2  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
135 .text.libgcc.div 0000002e  00001fcc  00001fcc  00002180  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
136 .text.libgcc.div 00000010  0000220a  0000220a  000023be  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
137 .text.libgcc  0000000c  0000229e  0000229e  00002452  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
138 .text.libgcc  00000010  0000221a  0000221a  000023ce  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
139 .text.__dummy_fini 00000002  000022f6  000022f6  000024aa  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
140 .text.__dummy_funcs_on_exit 00000002  000022f8  000022f8  000024ac  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
141 .text.__dummy_simulator_exit 00000002  000022fa  000022fa  000024ae  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
142 .text.exit    00000016  000021be  000021be  00002372  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
143 .text.memcpy  00000032  00001f6a  00001f6a  0000211e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
144 .text._Exit   00000004  000022f0  000022f0  000024a4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
145 .text.avrlibc 00000012  000021f8  000021f8  000023ac  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
146 .text.avrlibc 00000022  000020b2  000020b2  00002266  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
147 .text.avrlibc 0000001a  00002162  00002162  00002316  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 47 00 	jmp	0x8e	; 0x8e <__ctors_end>
   4:	0c 94 9d 0a 	jmp	0x153a	; 0x153a <__vector_1>
   8:	0c 94 76 11 	jmp	0x22ec	; 0x22ec <__bad_interrupt>
   c:	0c 94 76 11 	jmp	0x22ec	; 0x22ec <__bad_interrupt>
  10:	0c 94 76 11 	jmp	0x22ec	; 0x22ec <__bad_interrupt>
  14:	0c 94 76 11 	jmp	0x22ec	; 0x22ec <__bad_interrupt>
  18:	0c 94 76 11 	jmp	0x22ec	; 0x22ec <__bad_interrupt>
  1c:	0c 94 70 11 	jmp	0x22e0	; 0x22e0 <__vector_7>
  20:	0c 94 76 11 	jmp	0x22ec	; 0x22ec <__bad_interrupt>
  24:	0c 94 76 11 	jmp	0x22ec	; 0x22ec <__bad_interrupt>
  28:	0c 94 76 11 	jmp	0x22ec	; 0x22ec <__bad_interrupt>
  2c:	0c 94 76 11 	jmp	0x22ec	; 0x22ec <__bad_interrupt>
  30:	0c 94 76 11 	jmp	0x22ec	; 0x22ec <__bad_interrupt>
  34:	0c 94 76 11 	jmp	0x22ec	; 0x22ec <__bad_interrupt>
  38:	0c 94 76 11 	jmp	0x22ec	; 0x22ec <__bad_interrupt>
  3c:	0c 94 76 11 	jmp	0x22ec	; 0x22ec <__bad_interrupt>
  40:	0c 94 76 11 	jmp	0x22ec	; 0x22ec <__bad_interrupt>
  44:	0c 94 76 11 	jmp	0x22ec	; 0x22ec <__bad_interrupt>
  48:	0c 94 76 11 	jmp	0x22ec	; 0x22ec <__bad_interrupt>
  4c:	0c 94 76 11 	jmp	0x22ec	; 0x22ec <__bad_interrupt>
  50:	0c 94 76 11 	jmp	0x22ec	; 0x22ec <__bad_interrupt>
  54:	25 0b       	sbc	r18, r21
  56:	29 0b       	sbc	r18, r25
  58:	2e 0b       	sbc	r18, r30
  5a:	33 0b       	sbc	r19, r19
  5c:	38 0b       	sbc	r19, r24
  5e:	3d 0b       	sbc	r19, r29
  60:	42 0b       	sbc	r20, r18
  62:	47 0b       	sbc	r20, r23

00000064 <.dinit>:
  64:	00 60       	ori	r16, 0x00	; 0
  66:	06 a8       	ldd	r0, Z+54	; 0x36
  68:	80 06       	cpc	r8, r16
  6a:	a8 06       	cpc	r10, r24
  6c:	aa 00       	.word	0x00aa	; ????
  6e:	22 fc       	sbrc	r2, 2
  70:	06 aa       	std	Z+54, r0	; 0x36
  72:	06 b2       	in	r0, 0x16	; 22
  74:	80 06       	cpc	r8, r16
  76:	b2 06       	cpc	r11, r18
  78:	b3 00       	.word	0x00b3	; ????
  7a:	01 11       	cpse	r16, r1
  7c:	06 b3       	in	r16, 0x16	; 22
  7e:	06 b6       	in	r0, 0x36	; 54
  80:	80 06       	cpc	r8, r16
  82:	b6 06       	cpc	r11, r22
  84:	b7 00       	.word	0x00b7	; ????
  86:	22 fe       	sbrs	r2, 2
  88:	06 b7       	in	r16, 0x36	; 54
  8a:	06 c3       	rjmp	.+1548   	; 0x698 <xQueueGenericSend+0x118>
  8c:	80 00       	.word	0x0080	; ????

0000008e <__ctors_end>:
  8e:	11 24       	eor	r1, r1
  90:	1f be       	out	0x3f, r1	; 63
  92:	cf e5       	ldi	r28, 0x5F	; 95
  94:	d8 e0       	ldi	r29, 0x08	; 8
  96:	de bf       	out	0x3e, r29	; 62
  98:	cd bf       	out	0x3d, r28	; 61

0000009a <__do_copy_data>:
  9a:	e4 e6       	ldi	r30, 0x64	; 100
  9c:	f0 e0       	ldi	r31, 0x00	; 0
  9e:	40 e0       	ldi	r20, 0x00	; 0
  a0:	17 c0       	rjmp	.+46     	; 0xd0 <__do_clear_bss+0x8>
  a2:	b5 91       	lpm	r27, Z+
  a4:	a5 91       	lpm	r26, Z+
  a6:	35 91       	lpm	r19, Z+
  a8:	25 91       	lpm	r18, Z+
  aa:	05 91       	lpm	r16, Z+
  ac:	07 fd       	sbrc	r16, 7
  ae:	0c c0       	rjmp	.+24     	; 0xc8 <__do_clear_bss>
  b0:	95 91       	lpm	r25, Z+
  b2:	85 91       	lpm	r24, Z+
  b4:	ef 01       	movw	r28, r30
  b6:	f9 2f       	mov	r31, r25
  b8:	e8 2f       	mov	r30, r24
  ba:	05 90       	lpm	r0, Z+
  bc:	0d 92       	st	X+, r0
  be:	a2 17       	cp	r26, r18
  c0:	b3 07       	cpc	r27, r19
  c2:	d9 f7       	brne	.-10     	; 0xba <__do_copy_data+0x20>
  c4:	fe 01       	movw	r30, r28
  c6:	04 c0       	rjmp	.+8      	; 0xd0 <__do_clear_bss+0x8>

000000c8 <__do_clear_bss>:
  c8:	1d 92       	st	X+, r1
  ca:	a2 17       	cp	r26, r18
  cc:	b3 07       	cpc	r27, r19
  ce:	e1 f7       	brne	.-8      	; 0xc8 <__do_clear_bss>
  d0:	ed 38       	cpi	r30, 0x8D	; 141
  d2:	f4 07       	cpc	r31, r20
  d4:	31 f7       	brne	.-52     	; 0xa2 <__do_copy_data+0x8>
  d6:	0e 94 6f 04 	call	0x8de	; 0x8de <main>
  da:	0c 94 df 10 	jmp	0x21be	; 0x21be <exit>

000000de <_exit>:
  de:	f8 94       	cli

000000e0 <__stop_program>:
  e0:	ff cf       	rjmp	.-2      	; 0xe0 <__stop_program>

Disassembly of section .text:

000022ec <__bad_interrupt>:
    22ec:	0c 94 00 00 	jmp	0	; 0x0 <__TEXT_REGION_ORIGIN__>

Disassembly of section .text.Initialize_E2PROM_State:

0000217c <Initialize_E2PROM_State>:
}

void Initialize_E2PROM_State(void){
	
	/* It should have a normal state first	*/
	eeprom_update_byte (&EEPROM_State_Add, (uint8_t)Normal_state);	
    217c:	60 e0       	ldi	r22, 0x00	; 0
    217e:	82 eb       	ldi	r24, 0xB2	; 178
    2180:	96 e0       	ldi	r25, 0x06	; 6
    2182:	0e 94 59 10 	call	0x20b2	; 0x20b2 <eeprom_update_byte>
	eeprom_update_byte (&EEPROM_State_Add, (uint8_t)Normal_state);	
    2186:	60 e0       	ldi	r22, 0x00	; 0
    2188:	82 eb       	ldi	r24, 0xB2	; 178
    218a:	96 e0       	ldi	r25, 0x06	; 6
    218c:	0e 94 59 10 	call	0x20b2	; 0x20b2 <eeprom_update_byte>
    2190:	08 95       	ret

Disassembly of section .text.Read_E2PROM_State:

00002262 <Read_E2PROM_State>:
}

uint8_t Read_E2PROM_State (void){
	
	/*	read the state	*/
	uint8_t x= eeprom_read_byte (&EEPROM_State_Add); 		
    2262:	62 eb       	ldi	r22, 0xB2	; 178
    2264:	76 e0       	ldi	r23, 0x06	; 6
    2266:	80 e8       	ldi	r24, 0x80	; 128
    2268:	0e 94 fc 10 	call	0x21f8	; 0x21f8 <eeprom_read_byte>
	return x;
}
    226c:	08 95       	ret

Disassembly of section .text.App_Init:

0000191c <App_Init>:
void handle_event(temp T,uint8_t *counter,dc_motor DC_fan,uint8_t Speed, E2PROM_State* S,uint8_t* reset){
	
	/*	check the state	*/
	check_State(T,counter,S);
	handle_State(T,DC_fan,Speed,S,reset);
}
    191c:	0f 93       	push	r16
    191e:	80 91 b3 06 	lds	r24, 0x06B3	; 0x8006b3 <DC_fan1>
    1922:	0e 94 d4 0d 	call	0x1ba8	; 0x1ba8 <DC_Initialize>
    1926:	0e 94 be 10 	call	0x217c	; 0x217c <Initialize_E2PROM_State>
    192a:	0e 94 37 11 	call	0x226e	; 0x226e <Initialize_TEMP_SENSOR>
    192e:	60 e0       	ldi	r22, 0x00	; 0
    1930:	85 e0       	ldi	r24, 0x05	; 5
    1932:	0e 94 15 11 	call	0x222a	; 0x222a <ADC_Initialize>
    1936:	8b b3       	in	r24, 0x1b	; 27
    1938:	40 e0       	ldi	r20, 0x00	; 0
    193a:	60 e0       	ldi	r22, 0x00	; 0
    193c:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <DIO_SetPinDirection>
    1940:	00 e0       	ldi	r16, 0x00	; 0
    1942:	23 e0       	ldi	r18, 0x03	; 3
    1944:	40 e0       	ldi	r20, 0x00	; 0
    1946:	61 e0       	ldi	r22, 0x01	; 1
    1948:	80 e6       	ldi	r24, 0x60	; 96
    194a:	90 e0       	ldi	r25, 0x00	; 0
    194c:	0e 94 57 03 	call	0x6ae	; 0x6ae <UART_Initialize_WithoutInterrupt>
    1950:	88 23       	and	r24, r24
    1952:	91 f0       	breq	.+36     	; 0x1978 <App_Init+0x5c>
    1954:	82 e0       	ldi	r24, 0x02	; 2
    1956:	0e 94 a8 0d 	call	0x1b50	; 0x1b50 <External_Interrupt0_Initalize>
    195a:	0e 94 31 11 	call	0x2262	; 0x2262 <Read_E2PROM_State>
    195e:	81 11       	cpse	r24, r1
    1960:	05 c0       	rjmp	.+10     	; 0x196c <App_Init+0x50>
    1962:	60 e0       	ldi	r22, 0x00	; 0
    1964:	80 91 b3 06 	lds	r24, 0x06B3	; 0x8006b3 <DC_fan1>
    1968:	0e 94 88 09 	call	0x1310	; 0x1310 <DC_Start>
    196c:	8f e1       	ldi	r24, 0x1F	; 31
    196e:	9e e4       	ldi	r25, 0x4E	; 78
    1970:	01 97       	sbiw	r24, 0x01	; 1
    1972:	f1 f7       	brne	.-4      	; 0x1970 <App_Init+0x54>
    1974:	00 c0       	rjmp	.+0      	; 0x1976 <App_Init+0x5a>
    1976:	00 00       	nop
    1978:	0f 91       	pop	r16
    197a:	08 95       	ret

Disassembly of section .text.check_State:

000011d8 <check_State>:
    11d8:	cf 92       	push	r12
    11da:	df 92       	push	r13
    11dc:	ef 92       	push	r14
    11de:	ff 92       	push	r15
    11e0:	0f 93       	push	r16
    11e2:	1f 93       	push	r17
    11e4:	cf 93       	push	r28
    11e6:	df 93       	push	r29
    11e8:	8b 01       	movw	r16, r22
    11ea:	ea 01       	movw	r28, r20
    11ec:	bc 01       	movw	r22, r24
    11ee:	80 e0       	ldi	r24, 0x00	; 0
    11f0:	90 e0       	ldi	r25, 0x00	; 0
    11f2:	0e 94 db 0a 	call	0x15b6	; 0x15b6 <__floatunsisf>
    11f6:	6b 01       	movw	r12, r22
    11f8:	7c 01       	movw	r14, r24
    11fa:	20 e0       	ldi	r18, 0x00	; 0
    11fc:	30 e0       	ldi	r19, 0x00	; 0
    11fe:	48 e4       	ldi	r20, 0x48	; 72
    1200:	52 e4       	ldi	r21, 0x42	; 66
    1202:	0e 94 5a 11 	call	0x22b4	; 0x22b4 <__cmpsf2>
    1206:	88 23       	and	r24, r24
    1208:	64 f4       	brge	.+24     	; 0x1222 <check_State+0x4a>
    120a:	88 81       	ld	r24, Y
    120c:	88 23       	and	r24, r24
    120e:	49 f0       	breq	.+18     	; 0x1222 <check_State+0x4a>
    1210:	f8 01       	movw	r30, r16
    1212:	10 82       	st	Z, r1
    1214:	18 82       	st	Y, r1
    1216:	60 e0       	ldi	r22, 0x00	; 0
    1218:	82 eb       	ldi	r24, 0xB2	; 178
    121a:	96 e0       	ldi	r25, 0x06	; 6
    121c:	0e 94 b1 10 	call	0x2162	; 0x2162 <eeprom_write_byte>
    1220:	14 c0       	rjmp	.+40     	; 0x124a <check_State+0x72>
    1222:	20 e0       	ldi	r18, 0x00	; 0
    1224:	30 e0       	ldi	r19, 0x00	; 0
    1226:	48 e4       	ldi	r20, 0x48	; 72
    1228:	52 e4       	ldi	r21, 0x42	; 66
    122a:	c7 01       	movw	r24, r14
    122c:	b6 01       	movw	r22, r12
    122e:	0e 94 5f 11 	call	0x22be	; 0x22be <__gesf2>
    1232:	88 23       	and	r24, r24
    1234:	54 f0       	brlt	.+20     	; 0x124a <check_State+0x72>
    1236:	88 81       	ld	r24, Y
    1238:	81 11       	cpse	r24, r1
    123a:	07 c0       	rjmp	.+14     	; 0x124a <check_State+0x72>
    123c:	81 e0       	ldi	r24, 0x01	; 1
    123e:	88 83       	st	Y, r24
    1240:	61 e0       	ldi	r22, 0x01	; 1
    1242:	82 eb       	ldi	r24, 0xB2	; 178
    1244:	96 e0       	ldi	r25, 0x06	; 6
    1246:	0e 94 b1 10 	call	0x2162	; 0x2162 <eeprom_write_byte>
    124a:	f8 01       	movw	r30, r16
    124c:	80 81       	ld	r24, Z
    124e:	8e 30       	cpi	r24, 0x0E	; 14
    1250:	50 f0       	brcs	.+20     	; 0x1266 <check_State+0x8e>
    1252:	88 81       	ld	r24, Y
    1254:	82 30       	cpi	r24, 0x02	; 2
    1256:	39 f0       	breq	.+14     	; 0x1266 <check_State+0x8e>
    1258:	82 e0       	ldi	r24, 0x02	; 2
    125a:	88 83       	st	Y, r24
    125c:	62 e0       	ldi	r22, 0x02	; 2
    125e:	82 eb       	ldi	r24, 0xB2	; 178
    1260:	96 e0       	ldi	r25, 0x06	; 6
    1262:	0e 94 b1 10 	call	0x2162	; 0x2162 <eeprom_write_byte>
    1266:	df 91       	pop	r29
    1268:	cf 91       	pop	r28
    126a:	1f 91       	pop	r17
    126c:	0f 91       	pop	r16
    126e:	ff 90       	pop	r15
    1270:	ef 90       	pop	r14
    1272:	df 90       	pop	r13
    1274:	cf 90       	pop	r12
    1276:	08 95       	ret

Disassembly of section .text.handle_State:

000007ce <handle_State>:
 7ce:	8f 92       	push	r8
 7d0:	9f 92       	push	r9
 7d2:	af 92       	push	r10
 7d4:	bf 92       	push	r11
 7d6:	ef 92       	push	r14
 7d8:	ff 92       	push	r15
 7da:	0f 93       	push	r16
 7dc:	1f 93       	push	r17
 7de:	cf 93       	push	r28
 7e0:	df 93       	push	r29
 7e2:	7c 01       	movw	r14, r24
 7e4:	c6 2f       	mov	r28, r22
 7e6:	d4 2f       	mov	r29, r20
 7e8:	f9 01       	movw	r30, r18
 7ea:	80 81       	ld	r24, Z
 7ec:	81 30       	cpi	r24, 0x01	; 1
 7ee:	09 f4       	brne	.+2      	; 0x7f2 <handle_State+0x24>
 7f0:	55 c0       	rjmp	.+170    	; 0x89c <__stack+0x3d>
 7f2:	20 f0       	brcs	.+8      	; 0x7fc <handle_State+0x2e>
 7f4:	82 30       	cpi	r24, 0x02	; 2
 7f6:	09 f4       	brne	.+2      	; 0x7fa <handle_State+0x2c>
 7f8:	5b c0       	rjmp	.+182    	; 0x8b0 <__stack+0x51>
 7fa:	66 c0       	rjmp	.+204    	; 0x8c8 <__stack+0x69>
 7fc:	b7 01       	movw	r22, r14
 7fe:	80 e0       	ldi	r24, 0x00	; 0
 800:	90 e0       	ldi	r25, 0x00	; 0
 802:	0e 94 db 0a 	call	0x15b6	; 0x15b6 <__floatunsisf>
 806:	4b 01       	movw	r8, r22
 808:	5c 01       	movw	r10, r24
 80a:	20 e0       	ldi	r18, 0x00	; 0
 80c:	30 e0       	ldi	r19, 0x00	; 0
 80e:	40 ea       	ldi	r20, 0xA0	; 160
 810:	51 e4       	ldi	r21, 0x41	; 65
 812:	0e 94 5a 11 	call	0x22b4	; 0x22b4 <__cmpsf2>
 816:	18 16       	cp	r1, r24
 818:	24 f0       	brlt	.+8      	; 0x822 <__DATA_REGION_LENGTH__+0x22>
 81a:	8c 2f       	mov	r24, r28
 81c:	0e 94 25 0e 	call	0x1c4a	; 0x1c4a <DC_Stop>
 820:	53 c0       	rjmp	.+166    	; 0x8c8 <__stack+0x69>
 822:	20 e0       	ldi	r18, 0x00	; 0
 824:	30 e0       	ldi	r19, 0x00	; 0
 826:	40 ea       	ldi	r20, 0xA0	; 160
 828:	51 e4       	ldi	r21, 0x41	; 65
 82a:	c5 01       	movw	r24, r10
 82c:	b4 01       	movw	r22, r8
 82e:	0e 94 5f 11 	call	0x22be	; 0x22be <__gesf2>
 832:	18 16       	cp	r1, r24
 834:	14 f5       	brge	.+68     	; 0x87a <__stack+0x1b>
 836:	20 e0       	ldi	r18, 0x00	; 0
 838:	30 e0       	ldi	r19, 0x00	; 0
 83a:	40 e2       	ldi	r20, 0x20	; 32
 83c:	52 e4       	ldi	r21, 0x42	; 66
 83e:	c5 01       	movw	r24, r10
 840:	b4 01       	movw	r22, r8
 842:	0e 94 5a 11 	call	0x22b4	; 0x22b4 <__cmpsf2>
 846:	18 16       	cp	r1, r24
 848:	c4 f0       	brlt	.+48     	; 0x87a <__stack+0x1b>
 84a:	60 e0       	ldi	r22, 0x00	; 0
 84c:	8c 2f       	mov	r24, r28
 84e:	0e 94 88 09 	call	0x1310	; 0x1310 <DC_Start>
 852:	81 e0       	ldi	r24, 0x01	; 1
 854:	da 3f       	cpi	r29, 0xFA	; 250
 856:	08 f4       	brcc	.+2      	; 0x85a <__DATA_REGION_LENGTH__+0x5a>
 858:	80 e0       	ldi	r24, 0x00	; 0
 85a:	90 e0       	ldi	r25, 0x00	; 0
 85c:	8e 9d       	mul	r24, r14
 85e:	b0 01       	movw	r22, r0
 860:	8f 9d       	mul	r24, r15
 862:	70 0d       	add	r23, r0
 864:	9e 9d       	mul	r25, r14
 866:	70 0d       	add	r23, r0
 868:	11 24       	eor	r1, r1
 86a:	66 0f       	add	r22, r22
 86c:	77 1f       	adc	r23, r23
 86e:	66 0f       	add	r22, r22
 870:	77 1f       	adc	r23, r23
 872:	8c 2f       	mov	r24, r28
 874:	0e 94 fd 0f 	call	0x1ffa	; 0x1ffa <DC_Change_Speed>
 878:	27 c0       	rjmp	.+78     	; 0x8c8 <__stack+0x69>
 87a:	f9 e2       	ldi	r31, 0x29	; 41
 87c:	ef 1a       	sub	r14, r31
 87e:	f1 08       	sbc	r15, r1
 880:	8a e0       	ldi	r24, 0x0A	; 10
 882:	e8 16       	cp	r14, r24
 884:	f1 04       	cpc	r15, r1
 886:	00 f5       	brcc	.+64     	; 0x8c8 <__stack+0x69>
 888:	60 e0       	ldi	r22, 0x00	; 0
 88a:	8c 2f       	mov	r24, r28
 88c:	0e 94 88 09 	call	0x1310	; 0x1310 <DC_Start>
 890:	60 ea       	ldi	r22, 0xA0	; 160
 892:	70 e0       	ldi	r23, 0x00	; 0
 894:	8c 2f       	mov	r24, r28
 896:	0e 94 fd 0f 	call	0x1ffa	; 0x1ffa <DC_Change_Speed>
 89a:	16 c0       	rjmp	.+44     	; 0x8c8 <__stack+0x69>
 89c:	60 e0       	ldi	r22, 0x00	; 0
 89e:	8c 2f       	mov	r24, r28
 8a0:	0e 94 88 09 	call	0x1310	; 0x1310 <DC_Start>
 8a4:	60 ea       	ldi	r22, 0xA0	; 160
 8a6:	70 e0       	ldi	r23, 0x00	; 0
 8a8:	8c 2f       	mov	r24, r28
 8aa:	0e 94 fd 0f 	call	0x1ffa	; 0x1ffa <DC_Change_Speed>
 8ae:	0c c0       	rjmp	.+24     	; 0x8c8 <__stack+0x69>
 8b0:	60 e0       	ldi	r22, 0x00	; 0
 8b2:	8c 2f       	mov	r24, r28
 8b4:	0e 94 88 09 	call	0x1310	; 0x1310 <DC_Start>
 8b8:	60 ea       	ldi	r22, 0xA0	; 160
 8ba:	70 e0       	ldi	r23, 0x00	; 0
 8bc:	8c 2f       	mov	r24, r28
 8be:	0e 94 fd 0f 	call	0x1ffa	; 0x1ffa <DC_Change_Speed>
 8c2:	81 e0       	ldi	r24, 0x01	; 1
 8c4:	f8 01       	movw	r30, r16
 8c6:	80 83       	st	Z, r24
 8c8:	df 91       	pop	r29
 8ca:	cf 91       	pop	r28
 8cc:	1f 91       	pop	r17
 8ce:	0f 91       	pop	r16
 8d0:	ff 90       	pop	r15
 8d2:	ef 90       	pop	r14
 8d4:	bf 90       	pop	r11
 8d6:	af 90       	pop	r10
 8d8:	9f 90       	pop	r9
 8da:	8f 90       	pop	r8
 8dc:	08 95       	ret

Disassembly of section .text.UART_Transmit_State:

00001ce4 <UART_Transmit_State>:
	}

}

void UART_Transmit_State(const temp T,uint8_t counter,uint8_t *bot1f){
	if (T>=50)
    1ce4:	82 33       	cpi	r24, 0x32	; 50
    1ce6:	91 05       	cpc	r25, r1
    1ce8:	70 f0       	brcs	.+28     	; 0x1d06 <UART_Transmit_State+0x22>
	{	
		if (counter<Emergency_counter_max)
    1cea:	6e 30       	cpi	r22, 0x0E	; 14
    1cec:	38 f4       	brcc	.+14     	; 0x1cfc <UART_Transmit_State+0x18>
		{	//Emergency
			/* Reset the flag	*/
			*bot1f=0;
    1cee:	fa 01       	movw	r30, r20
    1cf0:	10 82       	st	Z, r1
			//send the emergency signal
			uart_status x=UART_Transmit_Word(Emergency_Mes);
    1cf2:	8c e2       	ldi	r24, 0x2C	; 44
    1cf4:	91 e0       	ldi	r25, 0x01	; 1
    1cf6:	0e 94 88 10 	call	0x2110	; 0x2110 <UART_Transmit_Word>
    1cfa:	08 95       	ret
		} 
		else
		{
			//Abnormal
			uart_status x=UART_Transmit_Word(Abnormal_Mes);
    1cfc:	8e e5       	ldi	r24, 0x5E	; 94
    1cfe:	91 e0       	ldi	r25, 0x01	; 1
    1d00:	0e 94 88 10 	call	0x2110	; 0x2110 <UART_Transmit_Word>
    1d04:	08 95       	ret
		}

	}
	else if (T>40 && T<=50 && *bot1f==1)
    1d06:	9c 01       	movw	r18, r24
    1d08:	29 52       	subi	r18, 0x29	; 41
    1d0a:	31 09       	sbc	r19, r1
    1d0c:	2a 30       	cpi	r18, 0x0A	; 10
    1d0e:	31 05       	cpc	r19, r1
    1d10:	48 f4       	brcc	.+18     	; 0x1d24 <UART_Transmit_State+0x40>
    1d12:	fa 01       	movw	r30, r20
    1d14:	20 81       	ld	r18, Z
    1d16:	21 30       	cpi	r18, 0x01	; 1
    1d18:	29 f4       	brne	.+10     	; 0x1d24 <UART_Transmit_State+0x40>
	{	
		//send the off signal
		uart_status x=UART_Transmit_Word(Off_Mes);
    1d1a:	8f ef       	ldi	r24, 0xFF	; 255
    1d1c:	90 e0       	ldi	r25, 0x00	; 0
    1d1e:	0e 94 88 10 	call	0x2110	; 0x2110 <UART_Transmit_Word>
			uart_status x=UART_Transmit_Word(Abnormal_Mes);
		}

	}
	else if (T>40 && T<=50 && *bot1f==1)
	{	
    1d22:	08 95       	ret
		//send the off signal
		uart_status x=UART_Transmit_Word(Off_Mes);
	}
	else{
		/* Reset the flag	*/
		*bot1f=0;
    1d24:	fa 01       	movw	r30, r20
    1d26:	10 82       	st	Z, r1
		uart_status x=UART_Transmit_Word(T);
    1d28:	0e 94 88 10 	call	0x2110	; 0x2110 <UART_Transmit_Word>
    1d2c:	08 95       	ret

Disassembly of section .text.Initialize_TEMP_SENSOR:

0000226e <Initialize_TEMP_SENSOR>:

#include "LM35_TMP_Sensor_Private.h"

void Initialize_TEMP_SENSOR(void)
{
	DIO_SetPinDirection(TEMP_SEN_PORT, TEMP_SEN_PIN, DIO_OUTPUT);
    226e:	41 e0       	ldi	r20, 0x01	; 1
    2270:	60 e0       	ldi	r22, 0x00	; 0
    2272:	80 e0       	ldi	r24, 0x00	; 0
    2274:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <DIO_SetPinDirection>
    2278:	08 95       	ret

Disassembly of section .text.Read_TEMP_SENSOR:

00001f9c <Read_TEMP_SENSOR>:
}

temp Read_TEMP_SENSOR(void){
	uint16_t temp_volt=ADC_Read(TEMP_SEN_PIN);
    1f9c:	80 e0       	ldi	r24, 0x00	; 0
    1f9e:	0e 94 18 0b 	call	0x1630	; 0x1630 <ADC_Read>
	temp temp_read = temp_volt*500.0/1024.0 ;
    1fa2:	bc 01       	movw	r22, r24
    1fa4:	80 e0       	ldi	r24, 0x00	; 0
    1fa6:	90 e0       	ldi	r25, 0x00	; 0
    1fa8:	0e 94 db 0a 	call	0x15b6	; 0x15b6 <__floatunsisf>
    1fac:	20 e0       	ldi	r18, 0x00	; 0
    1fae:	30 e0       	ldi	r19, 0x00	; 0
    1fb0:	4a ef       	ldi	r20, 0xFA	; 250
    1fb2:	53 e4       	ldi	r21, 0x43	; 67
    1fb4:	0e 94 6c 11 	call	0x22d8	; 0x22d8 <__mulsf3>
    1fb8:	20 e0       	ldi	r18, 0x00	; 0
    1fba:	30 e0       	ldi	r19, 0x00	; 0
    1fbc:	40 e8       	ldi	r20, 0x80	; 128
    1fbe:	5a e3       	ldi	r21, 0x3A	; 58
    1fc0:	0e 94 6c 11 	call	0x22d8	; 0x22d8 <__mulsf3>
    1fc4:	0e 94 1d 0d 	call	0x1a3a	; 0x1a3a <__fixunssfsi>
	return temp_read;
    1fc8:	cb 01       	movw	r24, r22
    1fca:	08 95       	ret

Disassembly of section .text.DC_Initialize:

00001ba8 <DC_Initialize>:

#include "DC_Private.h"

void DC_Initialize(dc_motor motor)
{	
	switch(motor)
    1ba8:	88 23       	and	r24, r24
    1baa:	19 f0       	breq	.+6      	; 0x1bb2 <DC_Initialize+0xa>
    1bac:	81 30       	cpi	r24, 0x01	; 1
    1bae:	a9 f0       	breq	.+42     	; 0x1bda <DC_Initialize+0x32>
    1bb0:	08 95       	ret
	{
		case DC_Motor1:
		DIO_SetPinDirection(DC_Enable_Port, DC_Enable1_Pin, DC_OUTPUT);
    1bb2:	41 e0       	ldi	r20, 0x01	; 1
    1bb4:	65 e0       	ldi	r22, 0x05	; 5
    1bb6:	83 e0       	ldi	r24, 0x03	; 3
    1bb8:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <DIO_SetPinDirection>
		DIO_SetPinDirection(DC_Motor_Port, DC_Motor1_A1, DC_OUTPUT);
    1bbc:	41 e0       	ldi	r20, 0x01	; 1
    1bbe:	61 e0       	ldi	r22, 0x01	; 1
    1bc0:	82 e0       	ldi	r24, 0x02	; 2
    1bc2:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <DIO_SetPinDirection>
		DIO_SetPinDirection(DC_Motor_Port, DC_Motor1_A2, DC_OUTPUT);
    1bc6:	41 e0       	ldi	r20, 0x01	; 1
    1bc8:	62 e0       	ldi	r22, 0x02	; 2
    1bca:	82 e0       	ldi	r24, 0x02	; 2
    1bcc:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <DIO_SetPinDirection>
		// Set Timer1 to Fast PWM mode with 8-bit resolution
		TCCR1A = (1 << WGM10) | (1 << WGM12) | (1 << COM1A1); // Fast PWM, Clear OC1A on Compare Match
    1bd0:	89 e8       	ldi	r24, 0x89	; 137
    1bd2:	8f bd       	out	0x2f, r24	; 47
		TCCR1B = (1 << WGM12) | (1 << CS11) | (1 << CS10);    // Prescaler = 64, start the timer
    1bd4:	8b e0       	ldi	r24, 0x0B	; 11
    1bd6:	8e bd       	out	0x2e, r24	; 46
		break;
    1bd8:	08 95       	ret
		case DC_Motor2:
		DIO_SetPinDirection(DC_Enable_Port, DC_Enable2_Pin, DC_OUTPUT);
    1bda:	41 e0       	ldi	r20, 0x01	; 1
    1bdc:	62 e0       	ldi	r22, 0x02	; 2
    1bde:	83 e0       	ldi	r24, 0x03	; 3
    1be0:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <DIO_SetPinDirection>
		DIO_SetPinDirection(DC_Motor_Port, DC_Motor2_A3, DC_OUTPUT);
    1be4:	41 e0       	ldi	r20, 0x01	; 1
    1be6:	62 e0       	ldi	r22, 0x02	; 2
    1be8:	82 e0       	ldi	r24, 0x02	; 2
    1bea:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <DIO_SetPinDirection>
		DIO_SetPinDirection(DC_Motor_Port, DC_Motor2_A4, DC_OUTPUT);
    1bee:	41 e0       	ldi	r20, 0x01	; 1
    1bf0:	62 e0       	ldi	r22, 0x02	; 2
    1bf2:	82 e0       	ldi	r24, 0x02	; 2
    1bf4:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <DIO_SetPinDirection>
    1bf8:	08 95       	ret

Disassembly of section .text.DC_Start:

00001310 <DC_Start>:
	}
	
}

void DC_Start(dc_motor motor, dc_motor_direction direction)
{	
    1310:	cf 93       	push	r28
    1312:	c6 2f       	mov	r28, r22
	switch(motor)
    1314:	88 23       	and	r24, r24
    1316:	19 f0       	breq	.+6      	; 0x131e <DC_Start+0xe>
    1318:	81 30       	cpi	r24, 0x01	; 1
    131a:	09 f1       	breq	.+66     	; 0x135e <DC_Start+0x4e>
    131c:	3f c0       	rjmp	.+126    	; 0x139c <DC_Start+0x8c>
	{
		case DC_Motor1:
		DIO_SetPinValue(DC_Enable_Port, DC_Enable1_Pin, DC_HIGH);
    131e:	41 e0       	ldi	r20, 0x01	; 1
    1320:	65 e0       	ldi	r22, 0x05	; 5
    1322:	83 e0       	ldi	r24, 0x03	; 3
    1324:	0e 94 61 05 	call	0xac2	; 0xac2 <DIO_SetPinValue>
		switch(direction)
    1328:	cc 23       	and	r28, r28
    132a:	19 f0       	breq	.+6      	; 0x1332 <DC_Start+0x22>
    132c:	c1 30       	cpi	r28, 0x01	; 1
    132e:	61 f0       	breq	.+24     	; 0x1348 <DC_Start+0x38>
    1330:	35 c0       	rjmp	.+106    	; 0x139c <DC_Start+0x8c>
		{
			case DC_CW:
			DIO_SetPinValue(DC_Motor_Port, DC_Motor1_A1, DC_HIGH);
    1332:	41 e0       	ldi	r20, 0x01	; 1
    1334:	61 e0       	ldi	r22, 0x01	; 1
    1336:	82 e0       	ldi	r24, 0x02	; 2
    1338:	0e 94 61 05 	call	0xac2	; 0xac2 <DIO_SetPinValue>
			DIO_SetPinValue(DC_Motor_Port, DC_Motor1_A2, DC_LOW);
    133c:	40 e0       	ldi	r20, 0x00	; 0
    133e:	62 e0       	ldi	r22, 0x02	; 2
    1340:	82 e0       	ldi	r24, 0x02	; 2
    1342:	0e 94 61 05 	call	0xac2	; 0xac2 <DIO_SetPinValue>
			break;
    1346:	2a c0       	rjmp	.+84     	; 0x139c <DC_Start+0x8c>
			case DC_CCW:
			DIO_SetPinValue(DC_Motor_Port, DC_Motor1_A1, DC_LOW);
    1348:	40 e0       	ldi	r20, 0x00	; 0
    134a:	61 e0       	ldi	r22, 0x01	; 1
    134c:	82 e0       	ldi	r24, 0x02	; 2
    134e:	0e 94 61 05 	call	0xac2	; 0xac2 <DIO_SetPinValue>
			DIO_SetPinValue(DC_Motor_Port, DC_Motor1_A2, DC_HIGH);
    1352:	41 e0       	ldi	r20, 0x01	; 1
    1354:	62 e0       	ldi	r22, 0x02	; 2
    1356:	82 e0       	ldi	r24, 0x02	; 2
    1358:	0e 94 61 05 	call	0xac2	; 0xac2 <DIO_SetPinValue>
			break;
    135c:	1f c0       	rjmp	.+62     	; 0x139c <DC_Start+0x8c>
		}
		break;
		case DC_Motor2:
		DIO_SetPinValue(DC_Enable_Port, DC_Enable2_Pin, DC_HIGH);
    135e:	41 e0       	ldi	r20, 0x01	; 1
    1360:	62 e0       	ldi	r22, 0x02	; 2
    1362:	83 e0       	ldi	r24, 0x03	; 3
    1364:	0e 94 61 05 	call	0xac2	; 0xac2 <DIO_SetPinValue>
		switch(direction)
    1368:	cc 23       	and	r28, r28
    136a:	19 f0       	breq	.+6      	; 0x1372 <DC_Start+0x62>
    136c:	c1 30       	cpi	r28, 0x01	; 1
    136e:	61 f0       	breq	.+24     	; 0x1388 <DC_Start+0x78>
    1370:	15 c0       	rjmp	.+42     	; 0x139c <DC_Start+0x8c>
		{
			case DC_CW:
			DIO_SetPinValue(DC_Motor_Port, DC_Motor2_A3, DC_HIGH);
    1372:	41 e0       	ldi	r20, 0x01	; 1
    1374:	62 e0       	ldi	r22, 0x02	; 2
    1376:	82 e0       	ldi	r24, 0x02	; 2
    1378:	0e 94 61 05 	call	0xac2	; 0xac2 <DIO_SetPinValue>
			DIO_SetPinValue(DC_Motor_Port, DC_Motor2_A4, DC_LOW);
    137c:	40 e0       	ldi	r20, 0x00	; 0
    137e:	62 e0       	ldi	r22, 0x02	; 2
    1380:	82 e0       	ldi	r24, 0x02	; 2
    1382:	0e 94 61 05 	call	0xac2	; 0xac2 <DIO_SetPinValue>
			break;
    1386:	0a c0       	rjmp	.+20     	; 0x139c <DC_Start+0x8c>
			case DC_CCW:
			DIO_SetPinValue(DC_Motor_Port, DC_Motor2_A3, DC_LOW);
    1388:	40 e0       	ldi	r20, 0x00	; 0
    138a:	62 e0       	ldi	r22, 0x02	; 2
    138c:	82 e0       	ldi	r24, 0x02	; 2
    138e:	0e 94 61 05 	call	0xac2	; 0xac2 <DIO_SetPinValue>
			DIO_SetPinValue(DC_Motor_Port, DC_Motor2_A4, DC_HIGH);
    1392:	41 e0       	ldi	r20, 0x01	; 1
    1394:	62 e0       	ldi	r22, 0x02	; 2
    1396:	82 e0       	ldi	r24, 0x02	; 2
    1398:	0e 94 61 05 	call	0xac2	; 0xac2 <DIO_SetPinValue>
			break;
		}
		break;
	}
}
    139c:	cf 91       	pop	r28
    139e:	08 95       	ret

Disassembly of section .text.DC_Stop:

00001c4a <DC_Stop>:

void DC_Stop(dc_motor motor)
{
	switch(motor)
    1c4a:	88 23       	and	r24, r24
    1c4c:	19 f0       	breq	.+6      	; 0x1c54 <DC_Stop+0xa>
    1c4e:	81 30       	cpi	r24, 0x01	; 1
    1c50:	99 f0       	breq	.+38     	; 0x1c78 <DC_Stop+0x2e>
    1c52:	08 95       	ret
	{
		case DC_Motor1:
		// Stop the pulse
		OCR1A=0;
    1c54:	1b bc       	out	0x2b, r1	; 43
    1c56:	1a bc       	out	0x2a, r1	; 42
		DIO_SetPinValue(DC_Enable_Port, DC_Enable1_Pin, DC_LOW);
    1c58:	40 e0       	ldi	r20, 0x00	; 0
    1c5a:	65 e0       	ldi	r22, 0x05	; 5
    1c5c:	83 e0       	ldi	r24, 0x03	; 3
    1c5e:	0e 94 61 05 	call	0xac2	; 0xac2 <DIO_SetPinValue>
		DIO_SetPinValue(DC_Motor_Port, DC_Motor1_A1, DC_LOW);
    1c62:	40 e0       	ldi	r20, 0x00	; 0
    1c64:	61 e0       	ldi	r22, 0x01	; 1
    1c66:	82 e0       	ldi	r24, 0x02	; 2
    1c68:	0e 94 61 05 	call	0xac2	; 0xac2 <DIO_SetPinValue>
		DIO_SetPinValue(DC_Motor_Port, DC_Motor1_A2, DC_LOW);
    1c6c:	40 e0       	ldi	r20, 0x00	; 0
    1c6e:	62 e0       	ldi	r22, 0x02	; 2
    1c70:	82 e0       	ldi	r24, 0x02	; 2
    1c72:	0e 94 61 05 	call	0xac2	; 0xac2 <DIO_SetPinValue>
		break;
    1c76:	08 95       	ret
		case DC_Motor2:
		DIO_SetPinValue(DC_Enable_Port, DC_Enable2_Pin, DC_LOW);
    1c78:	40 e0       	ldi	r20, 0x00	; 0
    1c7a:	62 e0       	ldi	r22, 0x02	; 2
    1c7c:	83 e0       	ldi	r24, 0x03	; 3
    1c7e:	0e 94 61 05 	call	0xac2	; 0xac2 <DIO_SetPinValue>
		DIO_SetPinValue(DC_Motor_Port, DC_Motor2_A3, DC_LOW);
    1c82:	40 e0       	ldi	r20, 0x00	; 0
    1c84:	62 e0       	ldi	r22, 0x02	; 2
    1c86:	82 e0       	ldi	r24, 0x02	; 2
    1c88:	0e 94 61 05 	call	0xac2	; 0xac2 <DIO_SetPinValue>
		DIO_SetPinValue(DC_Motor_Port, DC_Motor2_A4, DC_LOW);
    1c8c:	40 e0       	ldi	r20, 0x00	; 0
    1c8e:	62 e0       	ldi	r22, 0x02	; 2
    1c90:	82 e0       	ldi	r24, 0x02	; 2
    1c92:	0e 94 61 05 	call	0xac2	; 0xac2 <DIO_SetPinValue>
    1c96:	08 95       	ret

Disassembly of section .text.DC_Change_Speed:

00001ffa <DC_Change_Speed>:
		break;
	}
}

void DC_Change_Speed(dc_motor motor,uint16_t speed)
{	switch (motor){
    1ffa:	88 23       	and	r24, r24
    1ffc:	19 f0       	breq	.+6      	; 0x2004 <DC_Change_Speed+0xa>
    1ffe:	81 30       	cpi	r24, 0x01	; 1
    2000:	41 f0       	breq	.+16     	; 0x2012 <DC_Change_Speed+0x18>
    2002:	08 95       	ret
		case DC_Motor1:
			OCR1A = speed/4;
    2004:	76 95       	lsr	r23
    2006:	67 95       	ror	r22
    2008:	76 95       	lsr	r23
    200a:	67 95       	ror	r22
    200c:	7b bd       	out	0x2b, r23	; 43
    200e:	6a bd       	out	0x2a, r22	; 42
		break;
    2010:	08 95       	ret
		case DC_Motor2:
			OCR1B = speed/4;
    2012:	76 95       	lsr	r23
    2014:	67 95       	ror	r22
    2016:	76 95       	lsr	r23
    2018:	67 95       	ror	r22
    201a:	79 bd       	out	0x29, r23	; 41
    201c:	68 bd       	out	0x28, r22	; 40
    201e:	08 95       	ret

Disassembly of section .text.tmp:

00002192 <tmp>:
		}
		else{
			
		}
		*/
		temperature=Read_TEMP_SENSOR();
    2192:	0e 94 ce 0f 	call	0x1f9c	; 0x1f9c <Read_TEMP_SENSOR>
    2196:	90 93 a3 06 	sts	0x06A3, r25	; 0x8006a3 <temperature+0x1>
    219a:	80 93 a2 06 	sts	0x06A2, r24	; 0x8006a2 <temperature>
		vTaskDelay(100);
    219e:	84 e6       	ldi	r24, 0x64	; 100
    21a0:	90 e0       	ldi	r25, 0x00	; 0
    21a2:	0e 94 bb 0e 	call	0x1d76	; 0x1d76 <vTaskDelay>
    21a6:	f5 cf       	rjmp	.-22     	; 0x2192 <tmp>

Disassembly of section .text.uart:

000020d4 <uart>:
}

void uart(void *par){
	
	while(1){
		UART_Transmit_State(temperature,temp_counter,&buttonPressed);
    20d4:	60 91 b7 06 	lds	r22, 0x06B7	; 0x8006b7 <temp_counter>
    20d8:	80 91 a2 06 	lds	r24, 0x06A2	; 0x8006a2 <temperature>
    20dc:	90 91 a3 06 	lds	r25, 0x06A3	; 0x8006a3 <temperature+0x1>
    20e0:	44 eb       	ldi	r20, 0xB4	; 180
    20e2:	56 e0       	ldi	r21, 0x06	; 6
    20e4:	0e 94 72 0e 	call	0x1ce4	; 0x1ce4 <UART_Transmit_State>
		vTaskDelay(100);
    20e8:	84 e6       	ldi	r24, 0x64	; 100
    20ea:	90 e0       	ldi	r25, 0x00	; 0
    20ec:	0e 94 bb 0e 	call	0x1d76	; 0x1d76 <vTaskDelay>
    20f0:	f1 cf       	rjmp	.-30     	; 0x20d4 <uart>

Disassembly of section .text.eestate:

000020f2 <eestate>:
}

void eestate(void *par){
	
	while(1){
		check_State(temperature,&temp_counter,&currentState);
    20f2:	80 91 a2 06 	lds	r24, 0x06A2	; 0x8006a2 <temperature>
    20f6:	90 91 a3 06 	lds	r25, 0x06A3	; 0x8006a3 <temperature+0x1>
    20fa:	45 eb       	ldi	r20, 0xB5	; 181
    20fc:	56 e0       	ldi	r21, 0x06	; 6
    20fe:	67 eb       	ldi	r22, 0xB7	; 183
    2100:	76 e0       	ldi	r23, 0x06	; 6
    2102:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <check_State>
		vTaskDelay(2000);
    2106:	80 ed       	ldi	r24, 0xD0	; 208
    2108:	97 e0       	ldi	r25, 0x07	; 7
    210a:	0e 94 bb 0e 	call	0x1d76	; 0x1d76 <vTaskDelay>
    210e:	f1 cf       	rjmp	.-30     	; 0x20f2 <eestate>

Disassembly of section .text.fan1:

00002020 <fan1>:
}

void fan1(void *par){

	while(1){
		handle_State(temperature,DC_fan1,Speed_Scale,&currentState,&reset);
    2020:	80 91 a2 06 	lds	r24, 0x06A2	; 0x8006a2 <temperature>
    2024:	90 91 a3 06 	lds	r25, 0x06A3	; 0x8006a3 <temperature+0x1>
    2028:	09 eb       	ldi	r16, 0xB9	; 185
    202a:	16 e0       	ldi	r17, 0x06	; 6
    202c:	25 eb       	ldi	r18, 0xB5	; 181
    202e:	36 e0       	ldi	r19, 0x06	; 6
    2030:	40 91 b6 06 	lds	r20, 0x06B6	; 0x8006b6 <Speed_Scale>
    2034:	60 91 b3 06 	lds	r22, 0x06B3	; 0x8006b3 <DC_fan1>
    2038:	0e 94 e7 03 	call	0x7ce	; 0x7ce <handle_State>
		vTaskDelay(80);
    203c:	80 e5       	ldi	r24, 0x50	; 80
    203e:	90 e0       	ldi	r25, 0x00	; 0
    2040:	0e 94 bb 0e 	call	0x1d76	; 0x1d76 <vTaskDelay>
    2044:	ed cf       	rjmp	.-38     	; 0x2020 <fan1>

Disassembly of section .text.main:

000008de <main>:




int main(void)
{	
 8de:	af 92       	push	r10
 8e0:	bf 92       	push	r11
 8e2:	cf 92       	push	r12
 8e4:	df 92       	push	r13
 8e6:	ef 92       	push	r14
 8e8:	0f 93       	push	r16
 8ea:	1f 93       	push	r17
	
	App_Init();
 8ec:	0e 94 8e 0c 	call	0x191c	; 0x191c <App_Init>
	
	//LED_Semaphore=xSemaphoreCreateBinary();
	Bot1_Semaphore=xSemaphoreCreateBinary();
 8f0:	43 e0       	ldi	r20, 0x03	; 3
 8f2:	60 e0       	ldi	r22, 0x00	; 0
 8f4:	81 e0       	ldi	r24, 0x01	; 1
 8f6:	0e 94 4c 0d 	call	0x1a98	; 0x1a98 <xQueueGenericCreate>
 8fa:	90 93 63 00 	sts	0x0063, r25	; 0x800063 <Bot1_Semaphore+0x1>
 8fe:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <Bot1_Semaphore>
	xSemaphoreTake(Bot1_Semaphore, 0);
 902:	20 e0       	ldi	r18, 0x00	; 0
 904:	40 e0       	ldi	r20, 0x00	; 0
 906:	50 e0       	ldi	r21, 0x00	; 0
 908:	60 e0       	ldi	r22, 0x00	; 0
 90a:	70 e0       	ldi	r23, 0x00	; 0
 90c:	0e 94 89 00 	call	0x112	; 0x112 <xQueueGenericReceive>
	
	

	xTaskCreate(&tmp,"TMP_TASK",100,NULL,0,xHanleTMP);
 910:	c0 90 76 00 	lds	r12, 0x0076	; 0x800076 <xHanleTMP>
 914:	d0 90 77 00 	lds	r13, 0x0077	; 0x800077 <xHanleTMP+0x1>
 918:	1f 92       	push	r1
 91a:	1f 92       	push	r1
 91c:	1f 92       	push	r1
 91e:	a1 2c       	mov	r10, r1
 920:	b1 2c       	mov	r11, r1
 922:	e1 2c       	mov	r14, r1
 924:	00 e0       	ldi	r16, 0x00	; 0
 926:	10 e0       	ldi	r17, 0x00	; 0
 928:	24 e6       	ldi	r18, 0x64	; 100
 92a:	30 e0       	ldi	r19, 0x00	; 0
 92c:	42 ee       	ldi	r20, 0xE2	; 226
 92e:	50 e0       	ldi	r21, 0x00	; 0
 930:	60 e0       	ldi	r22, 0x00	; 0
 932:	89 ec       	ldi	r24, 0xC9	; 201
 934:	90 e1       	ldi	r25, 0x10	; 16
 936:	0e 94 48 01 	call	0x290	; 0x290 <xTaskGenericCreate>
	xTaskCreate(&uart,"UART_TASK",100,NULL,3,xHanleUART);
 93a:	c0 90 6a 00 	lds	r12, 0x006A	; 0x80006a <xHanleUART>
 93e:	d0 90 6b 00 	lds	r13, 0x006B	; 0x80006b <xHanleUART+0x1>
 942:	1f 92       	push	r1
 944:	1f 92       	push	r1
 946:	1f 92       	push	r1
 948:	0f 2e       	mov	r0, r31
 94a:	f3 e0       	ldi	r31, 0x03	; 3
 94c:	ef 2e       	mov	r14, r31
 94e:	f0 2d       	mov	r31, r0
 950:	24 e6       	ldi	r18, 0x64	; 100
 952:	30 e0       	ldi	r19, 0x00	; 0
 954:	4b ee       	ldi	r20, 0xEB	; 235
 956:	50 e0       	ldi	r21, 0x00	; 0
 958:	60 e0       	ldi	r22, 0x00	; 0
 95a:	8a e6       	ldi	r24, 0x6A	; 106
 95c:	90 e1       	ldi	r25, 0x10	; 16
 95e:	0e 94 48 01 	call	0x290	; 0x290 <xTaskGenericCreate>
	xTaskCreate(&eestate,"EESTATE_TASK",100,NULL,0,xHanleEEState);
 962:	c0 90 60 00 	lds	r12, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 966:	d0 90 61 00 	lds	r13, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
 96a:	1f 92       	push	r1
 96c:	1f 92       	push	r1
 96e:	1f 92       	push	r1
 970:	e1 2c       	mov	r14, r1
 972:	24 e6       	ldi	r18, 0x64	; 100
 974:	30 e0       	ldi	r19, 0x00	; 0
 976:	45 ef       	ldi	r20, 0xF5	; 245
 978:	50 e0       	ldi	r21, 0x00	; 0
 97a:	60 e0       	ldi	r22, 0x00	; 0
 97c:	89 e7       	ldi	r24, 0x79	; 121
 97e:	90 e1       	ldi	r25, 0x10	; 16
 980:	0e 94 48 01 	call	0x290	; 0x290 <xTaskGenericCreate>
	xTaskCreate(&fan1,"FAN1_TASK",100,NULL,2,xHanleFan1);
 984:	c0 90 64 00 	lds	r12, 0x0064	; 0x800064 <xHanleFan1>
 988:	d0 90 65 00 	lds	r13, 0x0065	; 0x800065 <xHanleFan1+0x1>
 98c:	1f 92       	push	r1
 98e:	1f 92       	push	r1
 990:	1f 92       	push	r1
 992:	68 94       	set
 994:	ee 24       	eor	r14, r14
 996:	e1 f8       	bld	r14, 1
 998:	24 e6       	ldi	r18, 0x64	; 100
 99a:	30 e0       	ldi	r19, 0x00	; 0
 99c:	42 e0       	ldi	r20, 0x02	; 2
 99e:	51 e0       	ldi	r21, 0x01	; 1
 9a0:	60 e0       	ldi	r22, 0x00	; 0
 9a2:	80 e1       	ldi	r24, 0x10	; 16
 9a4:	90 e1       	ldi	r25, 0x10	; 16
 9a6:	0e 94 48 01 	call	0x290	; 0x290 <xTaskGenericCreate>

		
	vTaskStartScheduler();
 9aa:	0e 94 be 0c 	call	0x197c	; 0x197c <vTaskStartScheduler>
	//Recieve the message (Speed)
	UART_Receive_Speed(&Speed_Scale);
	*/
		
	//check if need reset
	if(reset==1){
 9ae:	80 91 b9 06 	lds	r24, 0x06B9	; 0x8006b9 <reset>
 9b2:	2d b7       	in	r18, 0x3d	; 61
 9b4:	3e b7       	in	r19, 0x3e	; 62
 9b6:	24 5f       	subi	r18, 0xF4	; 244
 9b8:	3f 4f       	sbci	r19, 0xFF	; 255
 9ba:	0f b6       	in	r0, 0x3f	; 63
 9bc:	f8 94       	cli
 9be:	3e bf       	out	0x3e, r19	; 62
 9c0:	0f be       	out	0x3f, r0	; 63
 9c2:	2d bf       	out	0x3d, r18	; 61
 9c4:	81 30       	cpi	r24, 0x01	; 1
 9c6:	11 f4       	brne	.+4      	; 0x9cc <main+0xee>
		//Watch dog
		WDT_ON();
 9c8:	0e 94 3d 11 	call	0x227a	; 0x227a <WDT_ON>
	}
		
}
 9cc:	80 e0       	ldi	r24, 0x00	; 0
 9ce:	90 e0       	ldi	r25, 0x00	; 0
 9d0:	1f 91       	pop	r17
 9d2:	0f 91       	pop	r16
 9d4:	ef 90       	pop	r14
 9d6:	df 90       	pop	r13
 9d8:	cf 90       	pop	r12
 9da:	bf 90       	pop	r11
 9dc:	af 90       	pop	r10
 9de:	08 95       	ret

Disassembly of section .text.__vector_1:

0000153a <__vector_1>:

/*	Interrupt Service Routine for INT0 (bot1)	 */
ISR(INT0_vect)
{
    153a:	1f 92       	push	r1
    153c:	0f 92       	push	r0
    153e:	0f b6       	in	r0, 0x3f	; 63
    1540:	0f 92       	push	r0
    1542:	11 24       	eor	r1, r1
    1544:	0f 93       	push	r16
    1546:	2f 93       	push	r18
    1548:	3f 93       	push	r19
    154a:	4f 93       	push	r20
    154c:	5f 93       	push	r21
    154e:	6f 93       	push	r22
    1550:	7f 93       	push	r23
    1552:	8f 93       	push	r24
    1554:	9f 93       	push	r25
    1556:	af 93       	push	r26
    1558:	bf 93       	push	r27
    155a:	ef 93       	push	r30
    155c:	ff 93       	push	r31
	bot1_intur++;
    155e:	80 91 b8 06 	lds	r24, 0x06B8	; 0x8006b8 <bot1_intur>
    1562:	8f 5f       	subi	r24, 0xFF	; 255
    1564:	80 93 b8 06 	sts	0x06B8, r24	; 0x8006b8 <bot1_intur>
	xSemaphoreGive(Bot1_Semaphore);		/* Set the semaphore */
    1568:	00 e0       	ldi	r16, 0x00	; 0
    156a:	20 e0       	ldi	r18, 0x00	; 0
    156c:	30 e0       	ldi	r19, 0x00	; 0
    156e:	40 e0       	ldi	r20, 0x00	; 0
    1570:	50 e0       	ldi	r21, 0x00	; 0
    1572:	60 e0       	ldi	r22, 0x00	; 0
    1574:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <Bot1_Semaphore>
    1578:	90 91 63 00 	lds	r25, 0x0063	; 0x800063 <Bot1_Semaphore+0x1>
    157c:	0e 94 c0 02 	call	0x580	; 0x580 <xQueueGenericSend>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1580:	2f e7       	ldi	r18, 0x7F	; 127
    1582:	88 e3       	ldi	r24, 0x38	; 56
    1584:	91 e0       	ldi	r25, 0x01	; 1
    1586:	21 50       	subi	r18, 0x01	; 1
    1588:	80 40       	sbci	r24, 0x00	; 0
    158a:	90 40       	sbci	r25, 0x00	; 0
    158c:	e1 f7       	brne	.-8      	; 0x1586 <__vector_1+0x4c>
    158e:	00 c0       	rjmp	.+0      	; 0x1590 <__vector_1+0x56>
    1590:	00 00       	nop
	_delay_ms(50);  	/* Software debouncing control delay */
}
    1592:	ff 91       	pop	r31
    1594:	ef 91       	pop	r30
    1596:	bf 91       	pop	r27
    1598:	af 91       	pop	r26
    159a:	9f 91       	pop	r25
    159c:	8f 91       	pop	r24
    159e:	7f 91       	pop	r23
    15a0:	6f 91       	pop	r22
    15a2:	5f 91       	pop	r21
    15a4:	4f 91       	pop	r20
    15a6:	3f 91       	pop	r19
    15a8:	2f 91       	pop	r18
    15aa:	0f 91       	pop	r16
    15ac:	0f 90       	pop	r0
    15ae:	0f be       	out	0x3f, r0	; 63
    15b0:	0f 90       	pop	r0
    15b2:	1f 90       	pop	r1
    15b4:	18 95       	reti

Disassembly of section .text.ADC_Initialize:

0000222a <ADC_Initialize>:

#include "ADC_Private.h"

void ADC_Initialize(adc_vref voltage , adc_prescaler prescaler)
{
	ADMUX |= 0x40;
    222a:	87 b1       	in	r24, 0x07	; 7
    222c:	80 64       	ori	r24, 0x40	; 64
    222e:	87 b9       	out	0x07, r24	; 7
	ADCSRA |= 0xA7;
    2230:	86 b1       	in	r24, 0x06	; 6
    2232:	87 6a       	ori	r24, 0xA7	; 167
    2234:	86 b9       	out	0x06, r24	; 6
    2236:	08 95       	ret

Disassembly of section .text.ADC_Read:

00001630 <ADC_Read>:
}

uint16_t ADC_Read(adc_channel channel)
{
    1630:	e8 2f       	mov	r30, r24
	uint16_t val = 0;

	// Clear the ADC result register by reading it once
	uint16_t dummy = ADC_VAL;
    1632:	84 b1       	in	r24, 0x04	; 4
    1634:	95 b1       	in	r25, 0x05	; 5

	// Select the ADC channel
	switch (channel)
    1636:	8e 2f       	mov	r24, r30
    1638:	90 e0       	ldi	r25, 0x00	; 0
    163a:	88 30       	cpi	r24, 0x08	; 8
    163c:	91 05       	cpc	r25, r1
    163e:	50 f5       	brcc	.+84     	; 0x1694 <ADC_Read+0x64>
    1640:	fc 01       	movw	r30, r24
    1642:	e6 5d       	subi	r30, 0xD6	; 214
    1644:	ff 4f       	sbci	r31, 0xFF	; 255
    1646:	0c 94 4f 11 	jmp	0x229e	; 0x229e <__tablejump2__>
	{
		case ADC_0:
		ADMUX = (ADMUX & 0xF8) | 0x00; // Clear the channel bits and set ADC0
    164a:	87 b1       	in	r24, 0x07	; 7
    164c:	88 7f       	andi	r24, 0xF8	; 248
    164e:	87 b9       	out	0x07, r24	; 7
		break;
    1650:	21 c0       	rjmp	.+66     	; 0x1694 <ADC_Read+0x64>
		case ADC_1:
		ADMUX = (ADMUX & 0xF8) | 0x01; // Clear the channel bits and set ADC1
    1652:	87 b1       	in	r24, 0x07	; 7
    1654:	88 7f       	andi	r24, 0xF8	; 248
    1656:	81 60       	ori	r24, 0x01	; 1
    1658:	87 b9       	out	0x07, r24	; 7
		break;
    165a:	1c c0       	rjmp	.+56     	; 0x1694 <ADC_Read+0x64>
		case ADC_2:
		ADMUX = (ADMUX & 0xF8) | 0x02; // Clear the channel bits and set ADC2
    165c:	87 b1       	in	r24, 0x07	; 7
    165e:	88 7f       	andi	r24, 0xF8	; 248
    1660:	82 60       	ori	r24, 0x02	; 2
    1662:	87 b9       	out	0x07, r24	; 7
		break;
    1664:	17 c0       	rjmp	.+46     	; 0x1694 <ADC_Read+0x64>
		case ADC_3:
		ADMUX = (ADMUX & 0xF8) | 0x03; // Clear the channel bits and set ADC3
    1666:	87 b1       	in	r24, 0x07	; 7
    1668:	88 7f       	andi	r24, 0xF8	; 248
    166a:	83 60       	ori	r24, 0x03	; 3
    166c:	87 b9       	out	0x07, r24	; 7
		break;
    166e:	12 c0       	rjmp	.+36     	; 0x1694 <ADC_Read+0x64>
		case ADC_4:
		ADMUX = (ADMUX & 0xF8) | 0x04; // Clear the channel bits and set ADC4
    1670:	87 b1       	in	r24, 0x07	; 7
    1672:	88 7f       	andi	r24, 0xF8	; 248
    1674:	84 60       	ori	r24, 0x04	; 4
    1676:	87 b9       	out	0x07, r24	; 7
		break;
    1678:	0d c0       	rjmp	.+26     	; 0x1694 <ADC_Read+0x64>
		case ADC_5:
		ADMUX = (ADMUX & 0xF8) | 0x05; // Clear the channel bits and set ADC5
    167a:	87 b1       	in	r24, 0x07	; 7
    167c:	88 7f       	andi	r24, 0xF8	; 248
    167e:	85 60       	ori	r24, 0x05	; 5
    1680:	87 b9       	out	0x07, r24	; 7
		break;
    1682:	08 c0       	rjmp	.+16     	; 0x1694 <ADC_Read+0x64>
		case ADC_6:
		ADMUX = (ADMUX & 0xF8) | 0x06; // Clear the channel bits and set ADC6
    1684:	87 b1       	in	r24, 0x07	; 7
    1686:	88 7f       	andi	r24, 0xF8	; 248
    1688:	86 60       	ori	r24, 0x06	; 6
    168a:	87 b9       	out	0x07, r24	; 7
		break;
    168c:	03 c0       	rjmp	.+6      	; 0x1694 <ADC_Read+0x64>
		case ADC_7:
		ADMUX = (ADMUX & 0xF8) | 0x07; // Clear the channel bits and set ADC7
    168e:	87 b1       	in	r24, 0x07	; 7
    1690:	87 60       	ori	r24, 0x07	; 7
    1692:	87 b9       	out	0x07, r24	; 7
		break;
	}

	// Start ADC conversion
	ADCSRA |= (1 << ADSC);
    1694:	86 b1       	in	r24, 0x06	; 6
    1696:	80 64       	ori	r24, 0x40	; 64
    1698:	86 b9       	out	0x06, r24	; 6

	// Wait for conversion to complete
	while (ADCSRA & (1 << ADSC));
    169a:	36 99       	sbic	0x06, 6	; 6
    169c:	fe cf       	rjmp	.-4      	; 0x169a <ADC_Read+0x6a>

	// Read the converted value
	val = ADC_VAL;
    169e:	84 b1       	in	r24, 0x04	; 4
    16a0:	95 b1       	in	r25, 0x05	; 5

	return val;
}
    16a2:	08 95       	ret

Disassembly of section .text.DIO_SetPinDirection:

000009e0 <DIO_SetPinDirection>:
#include "DIO_Private.h"

/*------------------------PINS---------------------------*/
void DIO_SetPinDirection(port Port, pin Pin, state State)
{
	switch(State)
 9e0:	44 23       	and	r20, r20
 9e2:	19 f0       	breq	.+6      	; 0x9ea <DIO_SetPinDirection+0xa>
 9e4:	41 30       	cpi	r20, 0x01	; 1
 9e6:	c9 f1       	breq	.+114    	; 0xa5a <DIO_SetPinDirection+0x7a>
 9e8:	08 95       	ret
	{
		case DIO_INPUT:
		switch (Port)
 9ea:	81 30       	cpi	r24, 0x01	; 1
 9ec:	91 f0       	breq	.+36     	; 0xa12 <DIO_SetPinDirection+0x32>
 9ee:	28 f0       	brcs	.+10     	; 0x9fa <DIO_SetPinDirection+0x1a>
 9f0:	82 30       	cpi	r24, 0x02	; 2
 9f2:	d9 f0       	breq	.+54     	; 0xa2a <DIO_SetPinDirection+0x4a>
 9f4:	83 30       	cpi	r24, 0x03	; 3
 9f6:	29 f1       	breq	.+74     	; 0xa42 <DIO_SetPinDirection+0x62>
 9f8:	08 95       	ret
		{
			case DIO_PORTA:
			CLR_BIT(DDRA, Pin);
 9fa:	2a b3       	in	r18, 0x1a	; 26
 9fc:	81 e0       	ldi	r24, 0x01	; 1
 9fe:	90 e0       	ldi	r25, 0x00	; 0
 a00:	02 c0       	rjmp	.+4      	; 0xa06 <DIO_SetPinDirection+0x26>
 a02:	88 0f       	add	r24, r24
 a04:	99 1f       	adc	r25, r25
 a06:	6a 95       	dec	r22
 a08:	e2 f7       	brpl	.-8      	; 0xa02 <DIO_SetPinDirection+0x22>
 a0a:	80 95       	com	r24
 a0c:	82 23       	and	r24, r18
 a0e:	8a bb       	out	0x1a, r24	; 26
			break;
 a10:	08 95       	ret
			case DIO_PORTB:
			CLR_BIT(DDRB, Pin);
 a12:	27 b3       	in	r18, 0x17	; 23
 a14:	81 e0       	ldi	r24, 0x01	; 1
 a16:	90 e0       	ldi	r25, 0x00	; 0
 a18:	02 c0       	rjmp	.+4      	; 0xa1e <DIO_SetPinDirection+0x3e>
 a1a:	88 0f       	add	r24, r24
 a1c:	99 1f       	adc	r25, r25
 a1e:	6a 95       	dec	r22
 a20:	e2 f7       	brpl	.-8      	; 0xa1a <DIO_SetPinDirection+0x3a>
 a22:	80 95       	com	r24
 a24:	82 23       	and	r24, r18
 a26:	87 bb       	out	0x17, r24	; 23
			break;
 a28:	08 95       	ret
			case DIO_PORTC:
			CLR_BIT(DDRC, Pin);
 a2a:	24 b3       	in	r18, 0x14	; 20
 a2c:	81 e0       	ldi	r24, 0x01	; 1
 a2e:	90 e0       	ldi	r25, 0x00	; 0
 a30:	02 c0       	rjmp	.+4      	; 0xa36 <DIO_SetPinDirection+0x56>
 a32:	88 0f       	add	r24, r24
 a34:	99 1f       	adc	r25, r25
 a36:	6a 95       	dec	r22
 a38:	e2 f7       	brpl	.-8      	; 0xa32 <DIO_SetPinDirection+0x52>
 a3a:	80 95       	com	r24
 a3c:	82 23       	and	r24, r18
 a3e:	84 bb       	out	0x14, r24	; 20
			break;
 a40:	08 95       	ret
			case DIO_PORTD:
			CLR_BIT(DDRD, Pin);
 a42:	21 b3       	in	r18, 0x11	; 17
 a44:	81 e0       	ldi	r24, 0x01	; 1
 a46:	90 e0       	ldi	r25, 0x00	; 0
 a48:	02 c0       	rjmp	.+4      	; 0xa4e <DIO_SetPinDirection+0x6e>
 a4a:	88 0f       	add	r24, r24
 a4c:	99 1f       	adc	r25, r25
 a4e:	6a 95       	dec	r22
 a50:	e2 f7       	brpl	.-8      	; 0xa4a <DIO_SetPinDirection+0x6a>
 a52:	80 95       	com	r24
 a54:	82 23       	and	r24, r18
 a56:	81 bb       	out	0x11, r24	; 17
			break;
 a58:	08 95       	ret
		}
		break;
		case DIO_OUTPUT:
		switch (Port)
 a5a:	81 30       	cpi	r24, 0x01	; 1
 a5c:	89 f0       	breq	.+34     	; 0xa80 <DIO_SetPinDirection+0xa0>
 a5e:	28 f0       	brcs	.+10     	; 0xa6a <DIO_SetPinDirection+0x8a>
 a60:	82 30       	cpi	r24, 0x02	; 2
 a62:	c9 f0       	breq	.+50     	; 0xa96 <DIO_SetPinDirection+0xb6>
 a64:	83 30       	cpi	r24, 0x03	; 3
 a66:	11 f1       	breq	.+68     	; 0xaac <DIO_SetPinDirection+0xcc>
 a68:	08 95       	ret
		{
			case DIO_PORTA:
			SET_BIT(DDRA, Pin);
 a6a:	2a b3       	in	r18, 0x1a	; 26
 a6c:	81 e0       	ldi	r24, 0x01	; 1
 a6e:	90 e0       	ldi	r25, 0x00	; 0
 a70:	02 c0       	rjmp	.+4      	; 0xa76 <DIO_SetPinDirection+0x96>
 a72:	88 0f       	add	r24, r24
 a74:	99 1f       	adc	r25, r25
 a76:	6a 95       	dec	r22
 a78:	e2 f7       	brpl	.-8      	; 0xa72 <DIO_SetPinDirection+0x92>
 a7a:	82 2b       	or	r24, r18
 a7c:	8a bb       	out	0x1a, r24	; 26
			break;
 a7e:	08 95       	ret
			case DIO_PORTB:
			SET_BIT(DDRB, Pin);
 a80:	27 b3       	in	r18, 0x17	; 23
 a82:	81 e0       	ldi	r24, 0x01	; 1
 a84:	90 e0       	ldi	r25, 0x00	; 0
 a86:	02 c0       	rjmp	.+4      	; 0xa8c <DIO_SetPinDirection+0xac>
 a88:	88 0f       	add	r24, r24
 a8a:	99 1f       	adc	r25, r25
 a8c:	6a 95       	dec	r22
 a8e:	e2 f7       	brpl	.-8      	; 0xa88 <DIO_SetPinDirection+0xa8>
 a90:	82 2b       	or	r24, r18
 a92:	87 bb       	out	0x17, r24	; 23
			break;
 a94:	08 95       	ret
			case DIO_PORTC:
			SET_BIT(DDRC, Pin);
 a96:	24 b3       	in	r18, 0x14	; 20
 a98:	81 e0       	ldi	r24, 0x01	; 1
 a9a:	90 e0       	ldi	r25, 0x00	; 0
 a9c:	02 c0       	rjmp	.+4      	; 0xaa2 <DIO_SetPinDirection+0xc2>
 a9e:	88 0f       	add	r24, r24
 aa0:	99 1f       	adc	r25, r25
 aa2:	6a 95       	dec	r22
 aa4:	e2 f7       	brpl	.-8      	; 0xa9e <DIO_SetPinDirection+0xbe>
 aa6:	82 2b       	or	r24, r18
 aa8:	84 bb       	out	0x14, r24	; 20
			break;
 aaa:	08 95       	ret
			case DIO_PORTD:
			SET_BIT(DDRD, Pin);
 aac:	21 b3       	in	r18, 0x11	; 17
 aae:	81 e0       	ldi	r24, 0x01	; 1
 ab0:	90 e0       	ldi	r25, 0x00	; 0
 ab2:	02 c0       	rjmp	.+4      	; 0xab8 <DIO_SetPinDirection+0xd8>
 ab4:	88 0f       	add	r24, r24
 ab6:	99 1f       	adc	r25, r25
 ab8:	6a 95       	dec	r22
 aba:	e2 f7       	brpl	.-8      	; 0xab4 <DIO_SetPinDirection+0xd4>
 abc:	82 2b       	or	r24, r18
 abe:	81 bb       	out	0x11, r24	; 17
 ac0:	08 95       	ret

Disassembly of section .text.DIO_SetPinValue:

00000ac2 <DIO_SetPinValue>:
		break;
	}
}
void DIO_SetPinValue(port Port, pin Pin, status Status)
{
	switch(Status)
 ac2:	44 23       	and	r20, r20
 ac4:	19 f0       	breq	.+6      	; 0xacc <DIO_SetPinValue+0xa>
 ac6:	41 30       	cpi	r20, 0x01	; 1
 ac8:	c9 f1       	breq	.+114    	; 0xb3c <DIO_SetPinValue+0x7a>
 aca:	08 95       	ret
	{
		case DIO_LOW:
		switch (Port)
 acc:	81 30       	cpi	r24, 0x01	; 1
 ace:	91 f0       	breq	.+36     	; 0xaf4 <DIO_SetPinValue+0x32>
 ad0:	28 f0       	brcs	.+10     	; 0xadc <DIO_SetPinValue+0x1a>
 ad2:	82 30       	cpi	r24, 0x02	; 2
 ad4:	d9 f0       	breq	.+54     	; 0xb0c <DIO_SetPinValue+0x4a>
 ad6:	83 30       	cpi	r24, 0x03	; 3
 ad8:	29 f1       	breq	.+74     	; 0xb24 <DIO_SetPinValue+0x62>
 ada:	08 95       	ret
		{
			case DIO_PORTA:
			CLR_BIT(PORTA, Pin);
 adc:	2b b3       	in	r18, 0x1b	; 27
 ade:	81 e0       	ldi	r24, 0x01	; 1
 ae0:	90 e0       	ldi	r25, 0x00	; 0
 ae2:	02 c0       	rjmp	.+4      	; 0xae8 <DIO_SetPinValue+0x26>
 ae4:	88 0f       	add	r24, r24
 ae6:	99 1f       	adc	r25, r25
 ae8:	6a 95       	dec	r22
 aea:	e2 f7       	brpl	.-8      	; 0xae4 <DIO_SetPinValue+0x22>
 aec:	80 95       	com	r24
 aee:	82 23       	and	r24, r18
 af0:	8b bb       	out	0x1b, r24	; 27
			break;
 af2:	08 95       	ret
			case DIO_PORTB:
			CLR_BIT(PORTB, Pin);
 af4:	28 b3       	in	r18, 0x18	; 24
 af6:	81 e0       	ldi	r24, 0x01	; 1
 af8:	90 e0       	ldi	r25, 0x00	; 0
 afa:	02 c0       	rjmp	.+4      	; 0xb00 <DIO_SetPinValue+0x3e>
 afc:	88 0f       	add	r24, r24
 afe:	99 1f       	adc	r25, r25
 b00:	6a 95       	dec	r22
 b02:	e2 f7       	brpl	.-8      	; 0xafc <DIO_SetPinValue+0x3a>
 b04:	80 95       	com	r24
 b06:	82 23       	and	r24, r18
 b08:	88 bb       	out	0x18, r24	; 24
			break;
 b0a:	08 95       	ret
			case DIO_PORTC:
			CLR_BIT(PORTC, Pin);
 b0c:	25 b3       	in	r18, 0x15	; 21
 b0e:	81 e0       	ldi	r24, 0x01	; 1
 b10:	90 e0       	ldi	r25, 0x00	; 0
 b12:	02 c0       	rjmp	.+4      	; 0xb18 <DIO_SetPinValue+0x56>
 b14:	88 0f       	add	r24, r24
 b16:	99 1f       	adc	r25, r25
 b18:	6a 95       	dec	r22
 b1a:	e2 f7       	brpl	.-8      	; 0xb14 <DIO_SetPinValue+0x52>
 b1c:	80 95       	com	r24
 b1e:	82 23       	and	r24, r18
 b20:	85 bb       	out	0x15, r24	; 21
			break;
 b22:	08 95       	ret
			case DIO_PORTD:
			CLR_BIT(PORTD, Pin);
 b24:	22 b3       	in	r18, 0x12	; 18
 b26:	81 e0       	ldi	r24, 0x01	; 1
 b28:	90 e0       	ldi	r25, 0x00	; 0
 b2a:	02 c0       	rjmp	.+4      	; 0xb30 <DIO_SetPinValue+0x6e>
 b2c:	88 0f       	add	r24, r24
 b2e:	99 1f       	adc	r25, r25
 b30:	6a 95       	dec	r22
 b32:	e2 f7       	brpl	.-8      	; 0xb2c <DIO_SetPinValue+0x6a>
 b34:	80 95       	com	r24
 b36:	82 23       	and	r24, r18
 b38:	82 bb       	out	0x12, r24	; 18
			break;
 b3a:	08 95       	ret
		}
		break;
		case DIO_HIGH:
		switch (Port)
 b3c:	81 30       	cpi	r24, 0x01	; 1
 b3e:	89 f0       	breq	.+34     	; 0xb62 <DIO_SetPinValue+0xa0>
 b40:	28 f0       	brcs	.+10     	; 0xb4c <DIO_SetPinValue+0x8a>
 b42:	82 30       	cpi	r24, 0x02	; 2
 b44:	c9 f0       	breq	.+50     	; 0xb78 <DIO_SetPinValue+0xb6>
 b46:	83 30       	cpi	r24, 0x03	; 3
 b48:	11 f1       	breq	.+68     	; 0xb8e <DIO_SetPinValue+0xcc>
 b4a:	08 95       	ret
		{
			case DIO_PORTA:
			SET_BIT(PORTA, Pin);
 b4c:	2b b3       	in	r18, 0x1b	; 27
 b4e:	81 e0       	ldi	r24, 0x01	; 1
 b50:	90 e0       	ldi	r25, 0x00	; 0
 b52:	02 c0       	rjmp	.+4      	; 0xb58 <DIO_SetPinValue+0x96>
 b54:	88 0f       	add	r24, r24
 b56:	99 1f       	adc	r25, r25
 b58:	6a 95       	dec	r22
 b5a:	e2 f7       	brpl	.-8      	; 0xb54 <DIO_SetPinValue+0x92>
 b5c:	82 2b       	or	r24, r18
 b5e:	8b bb       	out	0x1b, r24	; 27
			break;
 b60:	08 95       	ret
			case DIO_PORTB:
			SET_BIT(PORTB, Pin);
 b62:	28 b3       	in	r18, 0x18	; 24
 b64:	81 e0       	ldi	r24, 0x01	; 1
 b66:	90 e0       	ldi	r25, 0x00	; 0
 b68:	02 c0       	rjmp	.+4      	; 0xb6e <DIO_SetPinValue+0xac>
 b6a:	88 0f       	add	r24, r24
 b6c:	99 1f       	adc	r25, r25
 b6e:	6a 95       	dec	r22
 b70:	e2 f7       	brpl	.-8      	; 0xb6a <DIO_SetPinValue+0xa8>
 b72:	82 2b       	or	r24, r18
 b74:	88 bb       	out	0x18, r24	; 24
			break;
 b76:	08 95       	ret
			case DIO_PORTC:
			SET_BIT(PORTC, Pin);
 b78:	25 b3       	in	r18, 0x15	; 21
 b7a:	81 e0       	ldi	r24, 0x01	; 1
 b7c:	90 e0       	ldi	r25, 0x00	; 0
 b7e:	02 c0       	rjmp	.+4      	; 0xb84 <DIO_SetPinValue+0xc2>
 b80:	88 0f       	add	r24, r24
 b82:	99 1f       	adc	r25, r25
 b84:	6a 95       	dec	r22
 b86:	e2 f7       	brpl	.-8      	; 0xb80 <DIO_SetPinValue+0xbe>
 b88:	82 2b       	or	r24, r18
 b8a:	85 bb       	out	0x15, r24	; 21
			break;
 b8c:	08 95       	ret
			case DIO_PORTD:
			SET_BIT(PORTD, Pin);
 b8e:	22 b3       	in	r18, 0x12	; 18
 b90:	81 e0       	ldi	r24, 0x01	; 1
 b92:	90 e0       	ldi	r25, 0x00	; 0
 b94:	02 c0       	rjmp	.+4      	; 0xb9a <DIO_SetPinValue+0xd8>
 b96:	88 0f       	add	r24, r24
 b98:	99 1f       	adc	r25, r25
 b9a:	6a 95       	dec	r22
 b9c:	e2 f7       	brpl	.-8      	; 0xb96 <DIO_SetPinValue+0xd4>
 b9e:	82 2b       	or	r24, r18
 ba0:	82 bb       	out	0x12, r24	; 18
 ba2:	08 95       	ret

Disassembly of section .text.External_Interrupt0_Initalize:

00001b50 <External_Interrupt0_Initalize>:
#include "Interrupt_Private.h"

void External_Interrupt0_Initalize(int0_sense sense)
{
	// Define interrupt pin INT0 as input 
	CLR_BIT(DDRD,2);	
    1b50:	91 b3       	in	r25, 0x11	; 17
    1b52:	9b 7f       	andi	r25, 0xFB	; 251
    1b54:	91 bb       	out	0x11, r25	; 17
	// Disable global interrupt while initialization 
	cli();//Clear interrupt, CLR_BIT(SREG,7);
    1b56:	f8 94       	cli
	// Choose sensing method
	switch(sense)
    1b58:	81 30       	cpi	r24, 0x01	; 1
    1b5a:	69 f0       	breq	.+26     	; 0x1b76 <External_Interrupt0_Initalize+0x26>
    1b5c:	28 f0       	brcs	.+10     	; 0x1b68 <External_Interrupt0_Initalize+0x18>
    1b5e:	82 30       	cpi	r24, 0x02	; 2
    1b60:	c1 f0       	breq	.+48     	; 0x1b92 <External_Interrupt0_Initalize+0x42>
    1b62:	83 30       	cpi	r24, 0x03	; 3
    1b64:	79 f0       	breq	.+30     	; 0x1b84 <External_Interrupt0_Initalize+0x34>
    1b66:	1b c0       	rjmp	.+54     	; 0x1b9e <External_Interrupt0_Initalize+0x4e>
	{
		case INT0_LOW:
		CLR_BIT(MCUCR, ISC01);CLR_BIT(MCUCR, ISC00);// 0 0
    1b68:	85 b7       	in	r24, 0x35	; 53
    1b6a:	8d 7f       	andi	r24, 0xFD	; 253
    1b6c:	85 bf       	out	0x35, r24	; 53
    1b6e:	85 b7       	in	r24, 0x35	; 53
    1b70:	8e 7f       	andi	r24, 0xFE	; 254
    1b72:	85 bf       	out	0x35, r24	; 53
		break;
    1b74:	14 c0       	rjmp	.+40     	; 0x1b9e <External_Interrupt0_Initalize+0x4e>
		case INT0_HIGH:
		CLR_BIT(MCUCR, ISC01);SET_BIT(MCUCR, ISC00);// 0 1
    1b76:	85 b7       	in	r24, 0x35	; 53
    1b78:	8d 7f       	andi	r24, 0xFD	; 253
    1b7a:	85 bf       	out	0x35, r24	; 53
    1b7c:	85 b7       	in	r24, 0x35	; 53
    1b7e:	81 60       	ori	r24, 0x01	; 1
    1b80:	85 bf       	out	0x35, r24	; 53
		break;
    1b82:	0d c0       	rjmp	.+26     	; 0x1b9e <External_Interrupt0_Initalize+0x4e>
		case INT0_FALLING:
		SET_BIT(MCUCR, ISC01);CLR_BIT(MCUCR, ISC00);// 1 0
    1b84:	85 b7       	in	r24, 0x35	; 53
    1b86:	82 60       	ori	r24, 0x02	; 2
    1b88:	85 bf       	out	0x35, r24	; 53
    1b8a:	85 b7       	in	r24, 0x35	; 53
    1b8c:	8e 7f       	andi	r24, 0xFE	; 254
    1b8e:	85 bf       	out	0x35, r24	; 53
		break;
    1b90:	06 c0       	rjmp	.+12     	; 0x1b9e <External_Interrupt0_Initalize+0x4e>
		case INT0_RISING:
		SET_BIT(MCUCR, ISC01);SET_BIT(MCUCR, ISC00);// 1 1
    1b92:	85 b7       	in	r24, 0x35	; 53
    1b94:	82 60       	ori	r24, 0x02	; 2
    1b96:	85 bf       	out	0x35, r24	; 53
    1b98:	85 b7       	in	r24, 0x35	; 53
    1b9a:	81 60       	ori	r24, 0x01	; 1
    1b9c:	85 bf       	out	0x35, r24	; 53
		break;
		
	}
	// Enable peripheral interrupt 
	SET_BIT(GICR, INT0);
    1b9e:	8b b7       	in	r24, 0x3b	; 59
    1ba0:	80 64       	ori	r24, 0x40	; 64
    1ba2:	8b bf       	out	0x3b, r24	; 59
	// Enable global interrupt after initialization 
	sei();//Set interrupt, SET_BIT(SREG,7);
    1ba4:	78 94       	sei
    1ba6:	08 95       	ret

Disassembly of section .text.UART_Initialize_WithoutInterrupt:

000006ae <UART_Initialize_WithoutInterrupt>:
uart_status UART_Receive_Character(uint8_t* data)
{
	while (((UCSRA>>RXC)&0x01) != 1);//Wait until flag of receiving received
	*data = UDR;
	return UART_OK;
}
 6ae:	0f 93       	push	r16
 6b0:	31 b3       	in	r19, 0x11	; 17
 6b2:	32 60       	ori	r19, 0x02	; 2
 6b4:	31 bb       	out	0x11, r19	; 17
 6b6:	31 b3       	in	r19, 0x11	; 17
 6b8:	3e 7f       	andi	r19, 0xFE	; 254
 6ba:	31 bb       	out	0x11, r19	; 17
 6bc:	3a b1       	in	r19, 0x0a	; 10
 6be:	38 61       	ori	r19, 0x18	; 24
 6c0:	3a b9       	out	0x0a, r19	; 10
 6c2:	66 23       	and	r22, r22
 6c4:	19 f0       	breq	.+6      	; 0x6cc <UART_Initialize_WithoutInterrupt+0x1e>
 6c6:	61 30       	cpi	r22, 0x01	; 1
 6c8:	29 f0       	breq	.+10     	; 0x6d4 <UART_Initialize_WithoutInterrupt+0x26>
 6ca:	07 c0       	rjmp	.+14     	; 0x6da <UART_Initialize_WithoutInterrupt+0x2c>
 6cc:	30 b5       	in	r19, 0x20	; 32
 6ce:	3f 77       	andi	r19, 0x7F	; 127
 6d0:	30 bd       	out	0x20, r19	; 32
 6d2:	03 c0       	rjmp	.+6      	; 0x6da <UART_Initialize_WithoutInterrupt+0x2c>
 6d4:	30 b5       	in	r19, 0x20	; 32
 6d6:	30 68       	ori	r19, 0x80	; 128
 6d8:	30 bd       	out	0x20, r19	; 32
 6da:	22 30       	cpi	r18, 0x02	; 2
 6dc:	f9 f0       	breq	.+62     	; 0x71c <UART_Initialize_WithoutInterrupt+0x6e>
 6de:	28 f4       	brcc	.+10     	; 0x6ea <UART_Initialize_WithoutInterrupt+0x3c>
 6e0:	22 23       	and	r18, r18
 6e2:	41 f0       	breq	.+16     	; 0x6f4 <UART_Initialize_WithoutInterrupt+0x46>
 6e4:	21 30       	cpi	r18, 0x01	; 1
 6e6:	81 f0       	breq	.+32     	; 0x708 <UART_Initialize_WithoutInterrupt+0x5a>
 6e8:	36 c0       	rjmp	.+108    	; 0x756 <UART_Initialize_WithoutInterrupt+0xa8>
 6ea:	23 30       	cpi	r18, 0x03	; 3
 6ec:	09 f1       	breq	.+66     	; 0x730 <UART_Initialize_WithoutInterrupt+0x82>
 6ee:	24 30       	cpi	r18, 0x04	; 4
 6f0:	49 f1       	breq	.+82     	; 0x744 <UART_Initialize_WithoutInterrupt+0x96>
 6f2:	31 c0       	rjmp	.+98     	; 0x756 <UART_Initialize_WithoutInterrupt+0xa8>
 6f4:	2a b1       	in	r18, 0x0a	; 10
 6f6:	2b 7f       	andi	r18, 0xFB	; 251
 6f8:	2a b9       	out	0x0a, r18	; 10
 6fa:	20 b5       	in	r18, 0x20	; 32
 6fc:	2b 7f       	andi	r18, 0xFB	; 251
 6fe:	20 bd       	out	0x20, r18	; 32
 700:	20 b5       	in	r18, 0x20	; 32
 702:	2d 7f       	andi	r18, 0xFD	; 253
 704:	20 bd       	out	0x20, r18	; 32
 706:	27 c0       	rjmp	.+78     	; 0x756 <UART_Initialize_WithoutInterrupt+0xa8>
 708:	2a b1       	in	r18, 0x0a	; 10
 70a:	2b 7f       	andi	r18, 0xFB	; 251
 70c:	2a b9       	out	0x0a, r18	; 10
 70e:	20 b5       	in	r18, 0x20	; 32
 710:	2b 7f       	andi	r18, 0xFB	; 251
 712:	20 bd       	out	0x20, r18	; 32
 714:	20 b5       	in	r18, 0x20	; 32
 716:	22 60       	ori	r18, 0x02	; 2
 718:	20 bd       	out	0x20, r18	; 32
 71a:	1d c0       	rjmp	.+58     	; 0x756 <UART_Initialize_WithoutInterrupt+0xa8>
 71c:	2a b1       	in	r18, 0x0a	; 10
 71e:	2b 7f       	andi	r18, 0xFB	; 251
 720:	2a b9       	out	0x0a, r18	; 10
 722:	20 b5       	in	r18, 0x20	; 32
 724:	24 60       	ori	r18, 0x04	; 4
 726:	20 bd       	out	0x20, r18	; 32
 728:	20 b5       	in	r18, 0x20	; 32
 72a:	2d 7f       	andi	r18, 0xFD	; 253
 72c:	20 bd       	out	0x20, r18	; 32
 72e:	13 c0       	rjmp	.+38     	; 0x756 <UART_Initialize_WithoutInterrupt+0xa8>
 730:	2a b1       	in	r18, 0x0a	; 10
 732:	2b 7f       	andi	r18, 0xFB	; 251
 734:	2a b9       	out	0x0a, r18	; 10
 736:	20 b5       	in	r18, 0x20	; 32
 738:	24 60       	ori	r18, 0x04	; 4
 73a:	20 bd       	out	0x20, r18	; 32
 73c:	20 b5       	in	r18, 0x20	; 32
 73e:	22 60       	ori	r18, 0x02	; 2
 740:	20 bd       	out	0x20, r18	; 32
 742:	09 c0       	rjmp	.+18     	; 0x756 <UART_Initialize_WithoutInterrupt+0xa8>
 744:	2a b1       	in	r18, 0x0a	; 10
 746:	24 60       	ori	r18, 0x04	; 4
 748:	2a b9       	out	0x0a, r18	; 10
 74a:	20 b5       	in	r18, 0x20	; 32
 74c:	24 60       	ori	r18, 0x04	; 4
 74e:	20 bd       	out	0x20, r18	; 32
 750:	20 b5       	in	r18, 0x20	; 32
 752:	22 60       	ori	r18, 0x02	; 2
 754:	20 bd       	out	0x20, r18	; 32
 756:	41 30       	cpi	r20, 0x01	; 1
 758:	59 f0       	breq	.+22     	; 0x770 <UART_Initialize_WithoutInterrupt+0xc2>
 75a:	18 f0       	brcs	.+6      	; 0x762 <UART_Initialize_WithoutInterrupt+0xb4>
 75c:	42 30       	cpi	r20, 0x02	; 2
 75e:	79 f0       	breq	.+30     	; 0x77e <UART_Initialize_WithoutInterrupt+0xd0>
 760:	14 c0       	rjmp	.+40     	; 0x78a <UART_Initialize_WithoutInterrupt+0xdc>
 762:	20 b5       	in	r18, 0x20	; 32
 764:	2f 7d       	andi	r18, 0xDF	; 223
 766:	20 bd       	out	0x20, r18	; 32
 768:	20 b5       	in	r18, 0x20	; 32
 76a:	2f 7e       	andi	r18, 0xEF	; 239
 76c:	20 bd       	out	0x20, r18	; 32
 76e:	0d c0       	rjmp	.+26     	; 0x78a <UART_Initialize_WithoutInterrupt+0xdc>
 770:	20 b5       	in	r18, 0x20	; 32
 772:	20 62       	ori	r18, 0x20	; 32
 774:	20 bd       	out	0x20, r18	; 32
 776:	20 b5       	in	r18, 0x20	; 32
 778:	2f 7e       	andi	r18, 0xEF	; 239
 77a:	20 bd       	out	0x20, r18	; 32
 77c:	06 c0       	rjmp	.+12     	; 0x78a <UART_Initialize_WithoutInterrupt+0xdc>
 77e:	20 b5       	in	r18, 0x20	; 32
 780:	20 62       	ori	r18, 0x20	; 32
 782:	20 bd       	out	0x20, r18	; 32
 784:	20 b5       	in	r18, 0x20	; 32
 786:	20 61       	ori	r18, 0x10	; 16
 788:	20 bd       	out	0x20, r18	; 32
 78a:	00 23       	and	r16, r16
 78c:	19 f0       	breq	.+6      	; 0x794 <UART_Initialize_WithoutInterrupt+0xe6>
 78e:	01 30       	cpi	r16, 0x01	; 1
 790:	29 f0       	breq	.+10     	; 0x79c <UART_Initialize_WithoutInterrupt+0xee>
 792:	07 c0       	rjmp	.+14     	; 0x7a2 <UART_Initialize_WithoutInterrupt+0xf4>
 794:	20 b5       	in	r18, 0x20	; 32
 796:	27 7f       	andi	r18, 0xF7	; 247
 798:	20 bd       	out	0x20, r18	; 32
 79a:	03 c0       	rjmp	.+6      	; 0x7a2 <UART_Initialize_WithoutInterrupt+0xf4>
 79c:	20 b5       	in	r18, 0x20	; 32
 79e:	28 60       	ori	r18, 0x08	; 8
 7a0:	20 bd       	out	0x20, r18	; 32
 7a2:	9c 01       	movw	r18, r24
 7a4:	22 95       	swap	r18
 7a6:	32 95       	swap	r19
 7a8:	30 7f       	andi	r19, 0xF0	; 240
 7aa:	32 27       	eor	r19, r18
 7ac:	20 7f       	andi	r18, 0xF0	; 240
 7ae:	32 27       	eor	r19, r18
 7b0:	40 e0       	ldi	r20, 0x00	; 0
 7b2:	50 e0       	ldi	r21, 0x00	; 0
 7b4:	60 e0       	ldi	r22, 0x00	; 0
 7b6:	71 e7       	ldi	r23, 0x71	; 113
 7b8:	82 e0       	ldi	r24, 0x02	; 2
 7ba:	90 e0       	ldi	r25, 0x00	; 0
 7bc:	0e 94 e6 0f 	call	0x1fcc	; 0x1fcc <__divmodsi4>
 7c0:	21 50       	subi	r18, 0x01	; 1
 7c2:	31 09       	sbc	r19, r1
 7c4:	29 b9       	out	0x09, r18	; 9
 7c6:	30 bd       	out	0x20, r19	; 32
 7c8:	81 e0       	ldi	r24, 0x01	; 1
 7ca:	0f 91       	pop	r16
 7cc:	08 95       	ret

Disassembly of section .text.UART_Transmit_Character:

000022aa <UART_Transmit_Character>:

}
uart_status UART_Transmit_Character(uint8_t data)
{

	while ((!(UCSRA & (1 << UDRE))) ) {
    22aa:	5d 9b       	sbis	0x0b, 5	; 11
    22ac:	fe cf       	rjmp	.-4      	; 0x22aa <UART_Transmit_Character>
		// Wait until the transmit buffer is empty
	}
	
	UDR = data;
    22ae:	8c b9       	out	0x0c, r24	; 12
	//while (((UCSRA>>TXC)&0x01) != 1);//Wait until flag of transmitting received
	return UART_OK;
}
    22b0:	81 e0       	ldi	r24, 0x01	; 1
    22b2:	08 95       	ret

Disassembly of section .text.UART_Transmit_Word:

00002110 <UART_Transmit_Word>:
	while (((UCSRA>>RXC)&0x01) != 1);//Wait until flag of receiving received
	*data = UDR;
	return UART_OK;
}

uart_status UART_Transmit_Word(uint16_t data){
    2110:	cf 93       	push	r28
    2112:	df 93       	push	r29
    2114:	d8 2f       	mov	r29, r24
	uint8_t high_byte = (data >> 8) & 0xFF;
	uint8_t low_byte = data & 0xFF;
	uart_status s=UART_Transmit_Character(high_byte);
    2116:	89 2f       	mov	r24, r25
    2118:	0e 94 55 11 	call	0x22aa	; 0x22aa <UART_Transmit_Character>
    211c:	c8 2f       	mov	r28, r24
	s|= UART_Transmit_Character(low_byte);
    211e:	8d 2f       	mov	r24, r29
    2120:	0e 94 55 11 	call	0x22aa	; 0x22aa <UART_Transmit_Character>
	return s;

}
    2124:	8c 2b       	or	r24, r28
    2126:	df 91       	pop	r29
    2128:	cf 91       	pop	r28
    212a:	08 95       	ret

Disassembly of section .text.WDT_ON:

0000227a <WDT_ON>:
{
	/*
	Watchdog timer enables with typical timeout period 2.1 
	second.
	*/
	WDTCR = (1<<WDE);
    227a:	88 e0       	ldi	r24, 0x08	; 8
    227c:	81 bd       	out	0x21, r24	; 33
	WDTCR &= ~((1<<WDP2)|(1<<WDP1)|(1<<WDP0));
    227e:	81 b5       	in	r24, 0x21	; 33
    2280:	88 7f       	andi	r24, 0xF8	; 248
    2282:	81 bd       	out	0x21, r24	; 33
    2284:	08 95       	ret

Disassembly of section .text.pvPortMalloc:

00001786 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1786:	cf 93       	push	r28
    1788:	df 93       	push	r29
    178a:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    178c:	0e 94 43 11 	call	0x2286	; 0x2286 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    1790:	80 91 a4 06 	lds	r24, 0x06A4	; 0x8006a4 <pucAlignedHeap.1961>
    1794:	90 91 a5 06 	lds	r25, 0x06A5	; 0x8006a5 <pucAlignedHeap.1961+0x1>
    1798:	89 2b       	or	r24, r25
    179a:	31 f4       	brne	.+12     	; 0x17a8 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
    179c:	8f e7       	ldi	r24, 0x7F	; 127
    179e:	90 e0       	ldi	r25, 0x00	; 0
    17a0:	90 93 a5 06 	sts	0x06A5, r25	; 0x8006a5 <pucAlignedHeap.1961+0x1>
    17a4:	80 93 a4 06 	sts	0x06A4, r24	; 0x8006a4 <pucAlignedHeap.1961>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    17a8:	20 91 a6 06 	lds	r18, 0x06A6	; 0x8006a6 <xNextFreeByte>
    17ac:	30 91 a7 06 	lds	r19, 0x06A7	; 0x8006a7 <xNextFreeByte+0x1>
    17b0:	c9 01       	movw	r24, r18
    17b2:	8c 0f       	add	r24, r28
    17b4:	9d 1f       	adc	r25, r29
    17b6:	8b 3d       	cpi	r24, 0xDB	; 219
    17b8:	45 e0       	ldi	r20, 0x05	; 5
    17ba:	94 07       	cpc	r25, r20
    17bc:	70 f4       	brcc	.+28     	; 0x17da <pvPortMalloc+0x54>
    17be:	28 17       	cp	r18, r24
    17c0:	39 07       	cpc	r19, r25
    17c2:	70 f4       	brcc	.+28     	; 0x17e0 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    17c4:	c0 91 a4 06 	lds	r28, 0x06A4	; 0x8006a4 <pucAlignedHeap.1961>
    17c8:	d0 91 a5 06 	lds	r29, 0x06A5	; 0x8006a5 <pucAlignedHeap.1961+0x1>
    17cc:	c2 0f       	add	r28, r18
    17ce:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
    17d0:	90 93 a7 06 	sts	0x06A7, r25	; 0x8006a7 <xNextFreeByte+0x1>
    17d4:	80 93 a6 06 	sts	0x06A6, r24	; 0x8006a6 <xNextFreeByte>
    17d8:	05 c0       	rjmp	.+10     	; 0x17e4 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    17da:	c0 e0       	ldi	r28, 0x00	; 0
    17dc:	d0 e0       	ldi	r29, 0x00	; 0
    17de:	02 c0       	rjmp	.+4      	; 0x17e4 <pvPortMalloc+0x5e>
    17e0:	c0 e0       	ldi	r28, 0x00	; 0
    17e2:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    17e4:	0e 94 d2 05 	call	0xba4	; 0xba4 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    17e8:	ce 01       	movw	r24, r28
    17ea:	df 91       	pop	r29
    17ec:	cf 91       	pop	r28
    17ee:	08 95       	ret

Disassembly of section .text.vPortFree:

000022f4 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    22f4:	08 95       	ret

Disassembly of section .text.vListInitialise:

0000212c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    212c:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    212e:	03 96       	adiw	r24, 0x03	; 3
    2130:	92 83       	std	Z+2, r25	; 0x02
    2132:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    2134:	2f ef       	ldi	r18, 0xFF	; 255
    2136:	3f ef       	ldi	r19, 0xFF	; 255
    2138:	34 83       	std	Z+4, r19	; 0x04
    213a:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    213c:	96 83       	std	Z+6, r25	; 0x06
    213e:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2140:	90 87       	std	Z+8, r25	; 0x08
    2142:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    2144:	10 82       	st	Z, r1
    2146:	08 95       	ret

Disassembly of section .text.vListInitialiseItem:

000022c8 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    22c8:	fc 01       	movw	r30, r24
    22ca:	11 86       	std	Z+9, r1	; 0x09
    22cc:	10 86       	std	Z+8, r1	; 0x08
    22ce:	08 95       	ret

Disassembly of section .text.vListInsertEnd:

00001e42 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1e42:	cf 93       	push	r28
    1e44:	df 93       	push	r29
    1e46:	9c 01       	movw	r18, r24
    1e48:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    1e4a:	dc 01       	movw	r26, r24
    1e4c:	11 96       	adiw	r26, 0x01	; 1
    1e4e:	cd 91       	ld	r28, X+
    1e50:	dc 91       	ld	r29, X
    1e52:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1e54:	d3 83       	std	Z+3, r29	; 0x03
    1e56:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1e58:	8c 81       	ldd	r24, Y+4	; 0x04
    1e5a:	9d 81       	ldd	r25, Y+5	; 0x05
    1e5c:	95 83       	std	Z+5, r25	; 0x05
    1e5e:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1e60:	8c 81       	ldd	r24, Y+4	; 0x04
    1e62:	9d 81       	ldd	r25, Y+5	; 0x05
    1e64:	dc 01       	movw	r26, r24
    1e66:	13 96       	adiw	r26, 0x03	; 3
    1e68:	7c 93       	st	X, r23
    1e6a:	6e 93       	st	-X, r22
    1e6c:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    1e6e:	7d 83       	std	Y+5, r23	; 0x05
    1e70:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1e72:	31 87       	std	Z+9, r19	; 0x09
    1e74:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    1e76:	f9 01       	movw	r30, r18
    1e78:	80 81       	ld	r24, Z
    1e7a:	8f 5f       	subi	r24, 0xFF	; 255
    1e7c:	80 83       	st	Z, r24
}
    1e7e:	df 91       	pop	r29
    1e80:	cf 91       	pop	r28
    1e82:	08 95       	ret

Disassembly of section .text.vListInsert:

000018ba <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    18ba:	cf 93       	push	r28
    18bc:	df 93       	push	r29
    18be:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    18c0:	48 81       	ld	r20, Y
    18c2:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    18c4:	4f 3f       	cpi	r20, 0xFF	; 255
    18c6:	2f ef       	ldi	r18, 0xFF	; 255
    18c8:	52 07       	cpc	r21, r18
    18ca:	21 f4       	brne	.+8      	; 0x18d4 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    18cc:	fc 01       	movw	r30, r24
    18ce:	a7 81       	ldd	r26, Z+7	; 0x07
    18d0:	b0 85       	ldd	r27, Z+8	; 0x08
    18d2:	0d c0       	rjmp	.+26     	; 0x18ee <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    18d4:	dc 01       	movw	r26, r24
    18d6:	13 96       	adiw	r26, 0x03	; 3
    18d8:	01 c0       	rjmp	.+2      	; 0x18dc <vListInsert+0x22>
    18da:	df 01       	movw	r26, r30
    18dc:	12 96       	adiw	r26, 0x02	; 2
    18de:	ed 91       	ld	r30, X+
    18e0:	fc 91       	ld	r31, X
    18e2:	13 97       	sbiw	r26, 0x03	; 3
    18e4:	20 81       	ld	r18, Z
    18e6:	31 81       	ldd	r19, Z+1	; 0x01
    18e8:	42 17       	cp	r20, r18
    18ea:	53 07       	cpc	r21, r19
    18ec:	b0 f7       	brcc	.-20     	; 0x18da <vListInsert+0x20>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    18ee:	12 96       	adiw	r26, 0x02	; 2
    18f0:	ed 91       	ld	r30, X+
    18f2:	fc 91       	ld	r31, X
    18f4:	13 97       	sbiw	r26, 0x03	; 3
    18f6:	fb 83       	std	Y+3, r31	; 0x03
    18f8:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    18fa:	d5 83       	std	Z+5, r29	; 0x05
    18fc:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    18fe:	bd 83       	std	Y+5, r27	; 0x05
    1900:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    1902:	13 96       	adiw	r26, 0x03	; 3
    1904:	dc 93       	st	X, r29
    1906:	ce 93       	st	-X, r28
    1908:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    190a:	99 87       	std	Y+9, r25	; 0x09
    190c:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    190e:	fc 01       	movw	r30, r24
    1910:	20 81       	ld	r18, Z
    1912:	2f 5f       	subi	r18, 0xFF	; 255
    1914:	20 83       	st	Z, r18
}
    1916:	df 91       	pop	r29
    1918:	cf 91       	pop	r28
    191a:	08 95       	ret

Disassembly of section .text.uxListRemove:

00001c98 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1c98:	cf 93       	push	r28
    1c9a:	df 93       	push	r29
    1c9c:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    1c9e:	a0 85       	ldd	r26, Z+8	; 0x08
    1ca0:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1ca2:	c2 81       	ldd	r28, Z+2	; 0x02
    1ca4:	d3 81       	ldd	r29, Z+3	; 0x03
    1ca6:	84 81       	ldd	r24, Z+4	; 0x04
    1ca8:	95 81       	ldd	r25, Z+5	; 0x05
    1caa:	9d 83       	std	Y+5, r25	; 0x05
    1cac:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1cae:	c4 81       	ldd	r28, Z+4	; 0x04
    1cb0:	d5 81       	ldd	r29, Z+5	; 0x05
    1cb2:	82 81       	ldd	r24, Z+2	; 0x02
    1cb4:	93 81       	ldd	r25, Z+3	; 0x03
    1cb6:	9b 83       	std	Y+3, r25	; 0x03
    1cb8:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1cba:	11 96       	adiw	r26, 0x01	; 1
    1cbc:	8d 91       	ld	r24, X+
    1cbe:	9c 91       	ld	r25, X
    1cc0:	12 97       	sbiw	r26, 0x02	; 2
    1cc2:	e8 17       	cp	r30, r24
    1cc4:	f9 07       	cpc	r31, r25
    1cc6:	31 f4       	brne	.+12     	; 0x1cd4 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1cc8:	84 81       	ldd	r24, Z+4	; 0x04
    1cca:	95 81       	ldd	r25, Z+5	; 0x05
    1ccc:	12 96       	adiw	r26, 0x02	; 2
    1cce:	9c 93       	st	X, r25
    1cd0:	8e 93       	st	-X, r24
    1cd2:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    1cd4:	11 86       	std	Z+9, r1	; 0x09
    1cd6:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1cd8:	8c 91       	ld	r24, X
    1cda:	81 50       	subi	r24, 0x01	; 1
    1cdc:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
    1cde:	df 91       	pop	r29
    1ce0:	cf 91       	pop	r28
    1ce2:	08 95       	ret

Disassembly of section .text.prvSetupTimerInterrupt:

000021d4 <prvSetupTimerInterrupt>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
    21d4:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = ucLowByte;
    21d6:	8c e7       	ldi	r24, 0x7C	; 124
    21d8:	8a bd       	out	0x2a, r24	; 42

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    21da:	8b e0       	ldi	r24, 0x0B	; 11
    21dc:	8e bd       	out	0x2e, r24	; 46

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    21de:	89 b7       	in	r24, 0x39	; 57
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    21e0:	80 61       	ori	r24, 0x10	; 16
	TIMSK = ucLowByte;
    21e2:	89 bf       	out	0x39, r24	; 57
    21e4:	08 95       	ret

Disassembly of section .text.pxPortInitialiseStack:

00000c86 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
 c86:	31 e1       	ldi	r19, 0x11	; 17
 c88:	fc 01       	movw	r30, r24
 c8a:	30 83       	st	Z, r19
 c8c:	31 97       	sbiw	r30, 0x01	; 1
 c8e:	22 e2       	ldi	r18, 0x22	; 34
 c90:	20 83       	st	Z, r18
 c92:	31 97       	sbiw	r30, 0x01	; 1
 c94:	a3 e3       	ldi	r26, 0x33	; 51
 c96:	a0 83       	st	Z, r26
 c98:	31 97       	sbiw	r30, 0x01	; 1
 c9a:	60 83       	st	Z, r22
 c9c:	31 97       	sbiw	r30, 0x01	; 1
 c9e:	70 83       	st	Z, r23
 ca0:	31 97       	sbiw	r30, 0x01	; 1
 ca2:	10 82       	st	Z, r1
 ca4:	31 97       	sbiw	r30, 0x01	; 1
 ca6:	60 e8       	ldi	r22, 0x80	; 128
 ca8:	60 83       	st	Z, r22
 caa:	31 97       	sbiw	r30, 0x01	; 1
 cac:	10 82       	st	Z, r1
 cae:	31 97       	sbiw	r30, 0x01	; 1
 cb0:	62 e0       	ldi	r22, 0x02	; 2
 cb2:	60 83       	st	Z, r22
 cb4:	31 97       	sbiw	r30, 0x01	; 1
 cb6:	63 e0       	ldi	r22, 0x03	; 3
 cb8:	60 83       	st	Z, r22
 cba:	31 97       	sbiw	r30, 0x01	; 1
 cbc:	64 e0       	ldi	r22, 0x04	; 4
 cbe:	60 83       	st	Z, r22
 cc0:	31 97       	sbiw	r30, 0x01	; 1
 cc2:	65 e0       	ldi	r22, 0x05	; 5
 cc4:	60 83       	st	Z, r22
 cc6:	31 97       	sbiw	r30, 0x01	; 1
 cc8:	66 e0       	ldi	r22, 0x06	; 6
 cca:	60 83       	st	Z, r22
 ccc:	31 97       	sbiw	r30, 0x01	; 1
 cce:	67 e0       	ldi	r22, 0x07	; 7
 cd0:	60 83       	st	Z, r22
 cd2:	31 97       	sbiw	r30, 0x01	; 1
 cd4:	68 e0       	ldi	r22, 0x08	; 8
 cd6:	60 83       	st	Z, r22
 cd8:	31 97       	sbiw	r30, 0x01	; 1
 cda:	69 e0       	ldi	r22, 0x09	; 9
 cdc:	60 83       	st	Z, r22
 cde:	31 97       	sbiw	r30, 0x01	; 1
 ce0:	60 e1       	ldi	r22, 0x10	; 16
 ce2:	60 83       	st	Z, r22
 ce4:	31 97       	sbiw	r30, 0x01	; 1
 ce6:	30 83       	st	Z, r19
 ce8:	31 97       	sbiw	r30, 0x01	; 1
 cea:	32 e1       	ldi	r19, 0x12	; 18
 cec:	30 83       	st	Z, r19
 cee:	31 97       	sbiw	r30, 0x01	; 1
 cf0:	33 e1       	ldi	r19, 0x13	; 19
 cf2:	30 83       	st	Z, r19
 cf4:	31 97       	sbiw	r30, 0x01	; 1
 cf6:	34 e1       	ldi	r19, 0x14	; 20
 cf8:	30 83       	st	Z, r19
 cfa:	31 97       	sbiw	r30, 0x01	; 1
 cfc:	35 e1       	ldi	r19, 0x15	; 21
 cfe:	30 83       	st	Z, r19
 d00:	31 97       	sbiw	r30, 0x01	; 1
 d02:	36 e1       	ldi	r19, 0x16	; 22
 d04:	30 83       	st	Z, r19
 d06:	31 97       	sbiw	r30, 0x01	; 1
 d08:	37 e1       	ldi	r19, 0x17	; 23
 d0a:	30 83       	st	Z, r19
 d0c:	31 97       	sbiw	r30, 0x01	; 1
 d0e:	38 e1       	ldi	r19, 0x18	; 24
 d10:	30 83       	st	Z, r19
 d12:	31 97       	sbiw	r30, 0x01	; 1
 d14:	39 e1       	ldi	r19, 0x19	; 25
 d16:	30 83       	st	Z, r19
 d18:	31 97       	sbiw	r30, 0x01	; 1
 d1a:	30 e2       	ldi	r19, 0x20	; 32
 d1c:	30 83       	st	Z, r19
 d1e:	31 97       	sbiw	r30, 0x01	; 1
 d20:	31 e2       	ldi	r19, 0x21	; 33
 d22:	30 83       	st	Z, r19
 d24:	31 97       	sbiw	r30, 0x01	; 1
 d26:	20 83       	st	Z, r18
 d28:	31 97       	sbiw	r30, 0x01	; 1
 d2a:	23 e2       	ldi	r18, 0x23	; 35
 d2c:	20 83       	st	Z, r18
 d2e:	31 97       	sbiw	r30, 0x01	; 1
 d30:	40 83       	st	Z, r20
 d32:	31 97       	sbiw	r30, 0x01	; 1
 d34:	50 83       	st	Z, r21
 d36:	31 97       	sbiw	r30, 0x01	; 1
 d38:	26 e2       	ldi	r18, 0x26	; 38
 d3a:	20 83       	st	Z, r18
 d3c:	31 97       	sbiw	r30, 0x01	; 1
 d3e:	27 e2       	ldi	r18, 0x27	; 39
 d40:	20 83       	st	Z, r18
 d42:	31 97       	sbiw	r30, 0x01	; 1
 d44:	28 e2       	ldi	r18, 0x28	; 40
 d46:	20 83       	st	Z, r18
 d48:	31 97       	sbiw	r30, 0x01	; 1
 d4a:	29 e2       	ldi	r18, 0x29	; 41
 d4c:	20 83       	st	Z, r18
 d4e:	31 97       	sbiw	r30, 0x01	; 1
 d50:	20 e3       	ldi	r18, 0x30	; 48
 d52:	20 83       	st	Z, r18
 d54:	31 97       	sbiw	r30, 0x01	; 1
 d56:	21 e3       	ldi	r18, 0x31	; 49
 d58:	20 83       	st	Z, r18
 d5a:	86 97       	sbiw	r24, 0x26	; 38
 d5c:	08 95       	ret

Disassembly of section .text.xPortStartScheduler:

000019dc <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    19dc:	0e 94 ea 10 	call	0x21d4	; 0x21d4 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    19e0:	a0 91 b0 06 	lds	r26, 0x06B0	; 0x8006b0 <pxCurrentTCB>
    19e4:	b0 91 b1 06 	lds	r27, 0x06B1	; 0x8006b1 <pxCurrentTCB+0x1>
    19e8:	cd 91       	ld	r28, X+
    19ea:	cd bf       	out	0x3d, r28	; 61
    19ec:	dd 91       	ld	r29, X+
    19ee:	de bf       	out	0x3e, r29	; 62
    19f0:	ff 91       	pop	r31
    19f2:	ef 91       	pop	r30
    19f4:	df 91       	pop	r29
    19f6:	cf 91       	pop	r28
    19f8:	bf 91       	pop	r27
    19fa:	af 91       	pop	r26
    19fc:	9f 91       	pop	r25
    19fe:	8f 91       	pop	r24
    1a00:	7f 91       	pop	r23
    1a02:	6f 91       	pop	r22
    1a04:	5f 91       	pop	r21
    1a06:	4f 91       	pop	r20
    1a08:	3f 91       	pop	r19
    1a0a:	2f 91       	pop	r18
    1a0c:	1f 91       	pop	r17
    1a0e:	0f 91       	pop	r16
    1a10:	ff 90       	pop	r15
    1a12:	ef 90       	pop	r14
    1a14:	df 90       	pop	r13
    1a16:	cf 90       	pop	r12
    1a18:	bf 90       	pop	r11
    1a1a:	af 90       	pop	r10
    1a1c:	9f 90       	pop	r9
    1a1e:	8f 90       	pop	r8
    1a20:	7f 90       	pop	r7
    1a22:	6f 90       	pop	r6
    1a24:	5f 90       	pop	r5
    1a26:	4f 90       	pop	r4
    1a28:	3f 90       	pop	r3
    1a2a:	2f 90       	pop	r2
    1a2c:	1f 90       	pop	r1
    1a2e:	0f 90       	pop	r0
    1a30:	0f be       	out	0x3f, r0	; 63
    1a32:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    1a34:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    1a36:	81 e0       	ldi	r24, 0x01	; 1
    1a38:	08 95       	ret

Disassembly of section .text.vPortYield:

00001126 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1126:	0f 92       	push	r0
    1128:	0f b6       	in	r0, 0x3f	; 63
    112a:	f8 94       	cli
    112c:	0f 92       	push	r0
    112e:	1f 92       	push	r1
    1130:	11 24       	eor	r1, r1
    1132:	2f 92       	push	r2
    1134:	3f 92       	push	r3
    1136:	4f 92       	push	r4
    1138:	5f 92       	push	r5
    113a:	6f 92       	push	r6
    113c:	7f 92       	push	r7
    113e:	8f 92       	push	r8
    1140:	9f 92       	push	r9
    1142:	af 92       	push	r10
    1144:	bf 92       	push	r11
    1146:	cf 92       	push	r12
    1148:	df 92       	push	r13
    114a:	ef 92       	push	r14
    114c:	ff 92       	push	r15
    114e:	0f 93       	push	r16
    1150:	1f 93       	push	r17
    1152:	2f 93       	push	r18
    1154:	3f 93       	push	r19
    1156:	4f 93       	push	r20
    1158:	5f 93       	push	r21
    115a:	6f 93       	push	r22
    115c:	7f 93       	push	r23
    115e:	8f 93       	push	r24
    1160:	9f 93       	push	r25
    1162:	af 93       	push	r26
    1164:	bf 93       	push	r27
    1166:	cf 93       	push	r28
    1168:	df 93       	push	r29
    116a:	ef 93       	push	r30
    116c:	ff 93       	push	r31
    116e:	a0 91 b0 06 	lds	r26, 0x06B0	; 0x8006b0 <pxCurrentTCB>
    1172:	b0 91 b1 06 	lds	r27, 0x06B1	; 0x8006b1 <pxCurrentTCB+0x1>
    1176:	0d b6       	in	r0, 0x3d	; 61
    1178:	0d 92       	st	X+, r0
    117a:	0e b6       	in	r0, 0x3e	; 62
    117c:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    117e:	0e 94 37 08 	call	0x106e	; 0x106e <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1182:	a0 91 b0 06 	lds	r26, 0x06B0	; 0x8006b0 <pxCurrentTCB>
    1186:	b0 91 b1 06 	lds	r27, 0x06B1	; 0x8006b1 <pxCurrentTCB+0x1>
    118a:	cd 91       	ld	r28, X+
    118c:	cd bf       	out	0x3d, r28	; 61
    118e:	dd 91       	ld	r29, X+
    1190:	de bf       	out	0x3e, r29	; 62
    1192:	ff 91       	pop	r31
    1194:	ef 91       	pop	r30
    1196:	df 91       	pop	r29
    1198:	cf 91       	pop	r28
    119a:	bf 91       	pop	r27
    119c:	af 91       	pop	r26
    119e:	9f 91       	pop	r25
    11a0:	8f 91       	pop	r24
    11a2:	7f 91       	pop	r23
    11a4:	6f 91       	pop	r22
    11a6:	5f 91       	pop	r21
    11a8:	4f 91       	pop	r20
    11aa:	3f 91       	pop	r19
    11ac:	2f 91       	pop	r18
    11ae:	1f 91       	pop	r17
    11b0:	0f 91       	pop	r16
    11b2:	ff 90       	pop	r15
    11b4:	ef 90       	pop	r14
    11b6:	df 90       	pop	r13
    11b8:	cf 90       	pop	r12
    11ba:	bf 90       	pop	r11
    11bc:	af 90       	pop	r10
    11be:	9f 90       	pop	r9
    11c0:	8f 90       	pop	r8
    11c2:	7f 90       	pop	r7
    11c4:	6f 90       	pop	r6
    11c6:	5f 90       	pop	r5
    11c8:	4f 90       	pop	r4
    11ca:	3f 90       	pop	r3
    11cc:	2f 90       	pop	r2
    11ce:	1f 90       	pop	r1
    11d0:	0f 90       	pop	r0
    11d2:	0f be       	out	0x3f, r0	; 63
    11d4:	0f 90       	pop	r0

	asm volatile ( "ret" );
    11d6:	08 95       	ret

Disassembly of section .text.vPortYieldFromTick:

00000fb6 <vPortYieldFromTick>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     fb6:	0f 92       	push	r0
     fb8:	0f b6       	in	r0, 0x3f	; 63
     fba:	f8 94       	cli
     fbc:	0f 92       	push	r0
     fbe:	1f 92       	push	r1
     fc0:	11 24       	eor	r1, r1
     fc2:	2f 92       	push	r2
     fc4:	3f 92       	push	r3
     fc6:	4f 92       	push	r4
     fc8:	5f 92       	push	r5
     fca:	6f 92       	push	r6
     fcc:	7f 92       	push	r7
     fce:	8f 92       	push	r8
     fd0:	9f 92       	push	r9
     fd2:	af 92       	push	r10
     fd4:	bf 92       	push	r11
     fd6:	cf 92       	push	r12
     fd8:	df 92       	push	r13
     fda:	ef 92       	push	r14
     fdc:	ff 92       	push	r15
     fde:	0f 93       	push	r16
     fe0:	1f 93       	push	r17
     fe2:	2f 93       	push	r18
     fe4:	3f 93       	push	r19
     fe6:	4f 93       	push	r20
     fe8:	5f 93       	push	r21
     fea:	6f 93       	push	r22
     fec:	7f 93       	push	r23
     fee:	8f 93       	push	r24
     ff0:	9f 93       	push	r25
     ff2:	af 93       	push	r26
     ff4:	bf 93       	push	r27
     ff6:	cf 93       	push	r28
     ff8:	df 93       	push	r29
     ffa:	ef 93       	push	r30
     ffc:	ff 93       	push	r31
     ffe:	a0 91 b0 06 	lds	r26, 0x06B0	; 0x8006b0 <pxCurrentTCB>
    1002:	b0 91 b1 06 	lds	r27, 0x06B1	; 0x8006b1 <pxCurrentTCB+0x1>
    1006:	0d b6       	in	r0, 0x3d	; 61
    1008:	0d 92       	st	X+, r0
    100a:	0e b6       	in	r0, 0x3e	; 62
    100c:	0d 92       	st	X+, r0
    100e:	0e 94 04 02 	call	0x408	; 0x408 <xTaskIncrementTick>
    1012:	81 11       	cpse	r24, r1
    1014:	0e 94 37 08 	call	0x106e	; 0x106e <vTaskSwitchContext>
    1018:	a0 91 b0 06 	lds	r26, 0x06B0	; 0x8006b0 <pxCurrentTCB>
    101c:	b0 91 b1 06 	lds	r27, 0x06B1	; 0x8006b1 <pxCurrentTCB+0x1>
    1020:	cd 91       	ld	r28, X+
    1022:	cd bf       	out	0x3d, r28	; 61
    1024:	dd 91       	ld	r29, X+
    1026:	de bf       	out	0x3e, r29	; 62
    1028:	ff 91       	pop	r31
    102a:	ef 91       	pop	r30
    102c:	df 91       	pop	r29
    102e:	cf 91       	pop	r28
    1030:	bf 91       	pop	r27
    1032:	af 91       	pop	r26
    1034:	9f 91       	pop	r25
    1036:	8f 91       	pop	r24
    1038:	7f 91       	pop	r23
    103a:	6f 91       	pop	r22
    103c:	5f 91       	pop	r21
    103e:	4f 91       	pop	r20
    1040:	3f 91       	pop	r19
    1042:	2f 91       	pop	r18
    1044:	1f 91       	pop	r17
    1046:	0f 91       	pop	r16
    1048:	ff 90       	pop	r15
    104a:	ef 90       	pop	r14
    104c:	df 90       	pop	r13
    104e:	cf 90       	pop	r12
    1050:	bf 90       	pop	r11
    1052:	af 90       	pop	r10
    1054:	9f 90       	pop	r9
    1056:	8f 90       	pop	r8
    1058:	7f 90       	pop	r7
    105a:	6f 90       	pop	r6
    105c:	5f 90       	pop	r5
    105e:	4f 90       	pop	r4
    1060:	3f 90       	pop	r3
    1062:	2f 90       	pop	r2
    1064:	1f 90       	pop	r1
    1066:	0f 90       	pop	r0
    1068:	0f be       	out	0x3f, r0	; 63
    106a:	0f 90       	pop	r0
    106c:	08 95       	ret

Disassembly of section .text.__vector_7:

000022e0 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    22e0:	0e 94 db 07 	call	0xfb6	; 0xfb6 <vPortYieldFromTick>
		asm volatile ( "reti" );
    22e4:	18 95       	reti

Disassembly of section .text.prvIsQueueEmpty:

00002046 <prvIsQueueEmpty>:

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2046:	0f b6       	in	r0, 0x3f	; 63
    2048:	f8 94       	cli
    204a:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    204c:	a8 2f       	mov	r26, r24
    204e:	cb 01       	movw	r24, r22
    2050:	4a 96       	adiw	r24, 0x1a	; 26
    2052:	a1 1d       	adc	r26, r1
    2054:	fc 01       	movw	r30, r24
    2056:	84 91       	lpm	r24, Z
    2058:	a7 fd       	sbrc	r26, 7
    205a:	80 81       	ld	r24, Z
    205c:	81 11       	cpse	r24, r1
    205e:	02 c0       	rjmp	.+4      	; 0x2064 <prvIsQueueEmpty+0x1e>
		{
			xReturn = pdTRUE;
    2060:	81 e0       	ldi	r24, 0x01	; 1
    2062:	01 c0       	rjmp	.+2      	; 0x2066 <prvIsQueueEmpty+0x20>
		}
		else
		{
			xReturn = pdFALSE;
    2064:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	taskEXIT_CRITICAL();
    2066:	0f 90       	pop	r0
    2068:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    206a:	08 95       	ret

Disassembly of section .text.prvIsQueueFull:

00001efc <prvIsQueueFull>:

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1efc:	0f b6       	in	r0, 0x3f	; 63
    1efe:	f8 94       	cli
    1f00:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1f02:	9b 01       	movw	r18, r22
    1f04:	48 2f       	mov	r20, r24
    1f06:	26 5e       	subi	r18, 0xE6	; 230
    1f08:	3f 4f       	sbci	r19, 0xFF	; 255
    1f0a:	4f 4f       	sbci	r20, 0xFF	; 255
    1f0c:	f9 01       	movw	r30, r18
    1f0e:	24 91       	lpm	r18, Z
    1f10:	47 fd       	sbrc	r20, 7
    1f12:	20 81       	ld	r18, Z
    1f14:	a8 2f       	mov	r26, r24
    1f16:	cb 01       	movw	r24, r22
    1f18:	4b 96       	adiw	r24, 0x1b	; 27
    1f1a:	a1 1d       	adc	r26, r1
    1f1c:	fc 01       	movw	r30, r24
    1f1e:	84 91       	lpm	r24, Z
    1f20:	a7 fd       	sbrc	r26, 7
    1f22:	80 81       	ld	r24, Z
    1f24:	28 13       	cpse	r18, r24
    1f26:	02 c0       	rjmp	.+4      	; 0x1f2c <prvIsQueueFull+0x30>
		{
			xReturn = pdTRUE;
    1f28:	81 e0       	ldi	r24, 0x01	; 1
    1f2a:	01 c0       	rjmp	.+2      	; 0x1f2e <prvIsQueueFull+0x32>
		}
		else
		{
			xReturn = pdFALSE;
    1f2c:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	taskEXIT_CRITICAL();
    1f2e:	0f 90       	pop	r0
    1f30:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    1f32:	08 95       	ret

Disassembly of section .text.prvCopyDataToQueue:

00000ef6 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
 ef6:	1f 93       	push	r17
 ef8:	cf 93       	push	r28
 efa:	df 93       	push	r29
 efc:	ec 01       	movw	r28, r24
 efe:	12 2f       	mov	r17, r18
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 f00:	2c 8d       	ldd	r18, Y+28	; 0x1c
 f02:	21 11       	cpse	r18, r1
 f04:	0c c0       	rjmp	.+24     	; 0xf1e <prvCopyDataToQueue+0x28>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 f06:	88 81       	ld	r24, Y
 f08:	99 81       	ldd	r25, Y+1	; 0x01
 f0a:	89 2b       	or	r24, r25
 f0c:	09 f0       	breq	.+2      	; 0xf10 <prvCopyDataToQueue+0x1a>
 f0e:	45 c0       	rjmp	.+138    	; 0xf9a <prvCopyDataToQueue+0xa4>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 f10:	8a 81       	ldd	r24, Y+2	; 0x02
 f12:	9b 81       	ldd	r25, Y+3	; 0x03
 f14:	0e 94 5d 0a 	call	0x14ba	; 0x14ba <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
 f18:	1b 82       	std	Y+3, r1	; 0x03
 f1a:	1a 82       	std	Y+2, r1	; 0x02
 f1c:	45 c0       	rjmp	.+138    	; 0xfa8 <prvCopyDataToQueue+0xb2>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
 f1e:	11 11       	cpse	r17, r1
 f20:	17 c0       	rjmp	.+46     	; 0xf50 <prvCopyDataToQueue+0x5a>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
 f22:	30 e0       	ldi	r19, 0x00	; 0
 f24:	8c 81       	ldd	r24, Y+4	; 0x04
 f26:	9d 81       	ldd	r25, Y+5	; 0x05
 f28:	0e 94 b5 0f 	call	0x1f6a	; 0x1f6a <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 f2c:	2c 8d       	ldd	r18, Y+28	; 0x1c
 f2e:	8c 81       	ldd	r24, Y+4	; 0x04
 f30:	9d 81       	ldd	r25, Y+5	; 0x05
 f32:	82 0f       	add	r24, r18
 f34:	91 1d       	adc	r25, r1
 f36:	9d 83       	std	Y+5, r25	; 0x05
 f38:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 f3a:	2a 81       	ldd	r18, Y+2	; 0x02
 f3c:	3b 81       	ldd	r19, Y+3	; 0x03
 f3e:	82 17       	cp	r24, r18
 f40:	93 07       	cpc	r25, r19
 f42:	68 f1       	brcs	.+90     	; 0xf9e <prvCopyDataToQueue+0xa8>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
 f44:	88 81       	ld	r24, Y
 f46:	99 81       	ldd	r25, Y+1	; 0x01
 f48:	9d 83       	std	Y+5, r25	; 0x05
 f4a:	8c 83       	std	Y+4, r24	; 0x04
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
 f4c:	80 e0       	ldi	r24, 0x00	; 0
 f4e:	2c c0       	rjmp	.+88     	; 0xfa8 <prvCopyDataToQueue+0xb2>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 f50:	30 e0       	ldi	r19, 0x00	; 0
 f52:	8e 81       	ldd	r24, Y+6	; 0x06
 f54:	9f 81       	ldd	r25, Y+7	; 0x07
 f56:	0e 94 b5 0f 	call	0x1f6a	; 0x1f6a <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 f5a:	8c 8d       	ldd	r24, Y+28	; 0x1c
 f5c:	90 e0       	ldi	r25, 0x00	; 0
 f5e:	91 95       	neg	r25
 f60:	81 95       	neg	r24
 f62:	91 09       	sbc	r25, r1
 f64:	2e 81       	ldd	r18, Y+6	; 0x06
 f66:	3f 81       	ldd	r19, Y+7	; 0x07
 f68:	28 0f       	add	r18, r24
 f6a:	39 1f       	adc	r19, r25
 f6c:	3f 83       	std	Y+7, r19	; 0x07
 f6e:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 f70:	48 81       	ld	r20, Y
 f72:	59 81       	ldd	r21, Y+1	; 0x01
 f74:	24 17       	cp	r18, r20
 f76:	35 07       	cpc	r19, r21
 f78:	30 f4       	brcc	.+12     	; 0xf86 <prvCopyDataToQueue+0x90>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 f7a:	2a 81       	ldd	r18, Y+2	; 0x02
 f7c:	3b 81       	ldd	r19, Y+3	; 0x03
 f7e:	82 0f       	add	r24, r18
 f80:	93 1f       	adc	r25, r19
 f82:	9f 83       	std	Y+7, r25	; 0x07
 f84:	8e 83       	std	Y+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
 f86:	12 30       	cpi	r17, 0x02	; 2
 f88:	61 f4       	brne	.+24     	; 0xfa2 <prvCopyDataToQueue+0xac>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 f8a:	8a 8d       	ldd	r24, Y+26	; 0x1a
 f8c:	88 23       	and	r24, r24
 f8e:	59 f0       	breq	.+22     	; 0xfa6 <prvCopyDataToQueue+0xb0>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
 f90:	8a 8d       	ldd	r24, Y+26	; 0x1a
 f92:	81 50       	subi	r24, 0x01	; 1
 f94:	8a 8f       	std	Y+26, r24	; 0x1a
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
 f96:	80 e0       	ldi	r24, 0x00	; 0
 f98:	07 c0       	rjmp	.+14     	; 0xfa8 <prvCopyDataToQueue+0xb2>
 f9a:	80 e0       	ldi	r24, 0x00	; 0
 f9c:	05 c0       	rjmp	.+10     	; 0xfa8 <prvCopyDataToQueue+0xb2>
 f9e:	80 e0       	ldi	r24, 0x00	; 0
 fa0:	03 c0       	rjmp	.+6      	; 0xfa8 <prvCopyDataToQueue+0xb2>
 fa2:	80 e0       	ldi	r24, 0x00	; 0
 fa4:	01 c0       	rjmp	.+2      	; 0xfa8 <prvCopyDataToQueue+0xb2>
 fa6:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
 fa8:	9a 8d       	ldd	r25, Y+26	; 0x1a
 faa:	9f 5f       	subi	r25, 0xFF	; 255
 fac:	9a 8f       	std	Y+26, r25	; 0x1a

	return xReturn;
}
 fae:	df 91       	pop	r29
 fb0:	cf 91       	pop	r28
 fb2:	1f 91       	pop	r17
 fb4:	08 95       	ret

Disassembly of section .text.prvCopyDataFromQueue:

00001f34 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    1f34:	fc 01       	movw	r30, r24
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    1f36:	24 8d       	ldd	r18, Z+28	; 0x1c
    1f38:	22 23       	and	r18, r18
    1f3a:	b1 f0       	breq	.+44     	; 0x1f68 <prvCopyDataFromQueue+0x34>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    1f3c:	30 e0       	ldi	r19, 0x00	; 0
    1f3e:	46 81       	ldd	r20, Z+6	; 0x06
    1f40:	57 81       	ldd	r21, Z+7	; 0x07
    1f42:	42 0f       	add	r20, r18
    1f44:	53 1f       	adc	r21, r19
    1f46:	57 83       	std	Z+7, r21	; 0x07
    1f48:	46 83       	std	Z+6, r20	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    1f4a:	82 81       	ldd	r24, Z+2	; 0x02
    1f4c:	93 81       	ldd	r25, Z+3	; 0x03
    1f4e:	48 17       	cp	r20, r24
    1f50:	59 07       	cpc	r21, r25
    1f52:	20 f0       	brcs	.+8      	; 0x1f5c <prvCopyDataFromQueue+0x28>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    1f54:	80 81       	ld	r24, Z
    1f56:	91 81       	ldd	r25, Z+1	; 0x01
    1f58:	97 83       	std	Z+7, r25	; 0x07
    1f5a:	86 83       	std	Z+6, r24	; 0x06
    1f5c:	cb 01       	movw	r24, r22
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    1f5e:	46 81       	ldd	r20, Z+6	; 0x06
    1f60:	57 81       	ldd	r21, Z+7	; 0x07
    1f62:	60 e8       	ldi	r22, 0x80	; 128
    1f64:	0e 94 b5 0f 	call	0x1f6a	; 0x1f6a <memcpy>
    1f68:	08 95       	ret

Disassembly of section .text.prvUnlockQueue:

000016a4 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    16a4:	cf 93       	push	r28
    16a6:	df 93       	push	r29
    16a8:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    16aa:	0f b6       	in	r0, 0x3f	; 63
    16ac:	f8 94       	cli
    16ae:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    16b0:	0f c0       	rjmp	.+30     	; 0x16d0 <prvUnlockQueue+0x2c>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    16b2:	89 89       	ldd	r24, Y+17	; 0x11
    16b4:	88 23       	and	r24, r24
    16b6:	79 f0       	breq	.+30     	; 0x16d6 <prvUnlockQueue+0x32>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    16b8:	be 01       	movw	r22, r28
    16ba:	6f 5e       	subi	r22, 0xEF	; 239
    16bc:	7f 4f       	sbci	r23, 0xFF	; 255
    16be:	80 e8       	ldi	r24, 0x80	; 128
    16c0:	0e 94 3c 09 	call	0x1278	; 0x1278 <xTaskRemoveFromEventList>
    16c4:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    16c6:	0e 94 68 11 	call	0x22d0	; 0x22d0 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    16ca:	8e 8d       	ldd	r24, Y+30	; 0x1e
    16cc:	81 50       	subi	r24, 0x01	; 1
    16ce:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    16d0:	8e 8d       	ldd	r24, Y+30	; 0x1e
    16d2:	18 16       	cp	r1, r24
    16d4:	74 f3       	brlt	.-36     	; 0x16b2 <prvUnlockQueue+0xe>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    16d6:	8f ef       	ldi	r24, 0xFF	; 255
    16d8:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    16da:	0f 90       	pop	r0
    16dc:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    16de:	0f b6       	in	r0, 0x3f	; 63
    16e0:	f8 94       	cli
    16e2:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    16e4:	0f c0       	rjmp	.+30     	; 0x1704 <prvUnlockQueue+0x60>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    16e6:	88 85       	ldd	r24, Y+8	; 0x08
    16e8:	88 23       	and	r24, r24
    16ea:	79 f0       	breq	.+30     	; 0x170a <prvUnlockQueue+0x66>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    16ec:	be 01       	movw	r22, r28
    16ee:	68 5f       	subi	r22, 0xF8	; 248
    16f0:	7f 4f       	sbci	r23, 0xFF	; 255
    16f2:	80 e8       	ldi	r24, 0x80	; 128
    16f4:	0e 94 3c 09 	call	0x1278	; 0x1278 <xTaskRemoveFromEventList>
    16f8:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    16fa:	0e 94 68 11 	call	0x22d0	; 0x22d0 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    16fe:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1700:	81 50       	subi	r24, 0x01	; 1
    1702:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1704:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1706:	18 16       	cp	r1, r24
    1708:	74 f3       	brlt	.-36     	; 0x16e6 <prvUnlockQueue+0x42>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    170a:	8f ef       	ldi	r24, 0xFF	; 255
    170c:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    170e:	0f 90       	pop	r0
    1710:	0f be       	out	0x3f, r0	; 63
}
    1712:	df 91       	pop	r29
    1714:	cf 91       	pop	r28
    1716:	08 95       	ret

Disassembly of section .text.xQueueGenericReset:

000013a0 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    13a0:	cf 93       	push	r28
    13a2:	df 93       	push	r29
    13a4:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    13a6:	0f b6       	in	r0, 0x3f	; 63
    13a8:	f8 94       	cli
    13aa:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    13ac:	e8 81       	ld	r30, Y
    13ae:	f9 81       	ldd	r31, Y+1	; 0x01
    13b0:	8b 8d       	ldd	r24, Y+27	; 0x1b
    13b2:	90 e0       	ldi	r25, 0x00	; 0
    13b4:	2c 8d       	ldd	r18, Y+28	; 0x1c
    13b6:	30 e0       	ldi	r19, 0x00	; 0
    13b8:	82 9f       	mul	r24, r18
    13ba:	a0 01       	movw	r20, r0
    13bc:	83 9f       	mul	r24, r19
    13be:	50 0d       	add	r21, r0
    13c0:	92 9f       	mul	r25, r18
    13c2:	50 0d       	add	r21, r0
    13c4:	11 24       	eor	r1, r1
    13c6:	4e 0f       	add	r20, r30
    13c8:	5f 1f       	adc	r21, r31
    13ca:	5b 83       	std	Y+3, r21	; 0x03
    13cc:	4a 83       	std	Y+2, r20	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    13ce:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    13d0:	fd 83       	std	Y+5, r31	; 0x05
    13d2:	ec 83       	std	Y+4, r30	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    13d4:	01 97       	sbiw	r24, 0x01	; 1
    13d6:	28 9f       	mul	r18, r24
    13d8:	a0 01       	movw	r20, r0
    13da:	29 9f       	mul	r18, r25
    13dc:	50 0d       	add	r21, r0
    13de:	38 9f       	mul	r19, r24
    13e0:	50 0d       	add	r21, r0
    13e2:	11 24       	eor	r1, r1
    13e4:	cf 01       	movw	r24, r30
    13e6:	84 0f       	add	r24, r20
    13e8:	95 1f       	adc	r25, r21
    13ea:	9f 83       	std	Y+7, r25	; 0x07
    13ec:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    13ee:	8f ef       	ldi	r24, 0xFF	; 255
    13f0:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    13f2:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    13f4:	61 11       	cpse	r22, r1
    13f6:	0d c0       	rjmp	.+26     	; 0x1412 <xQueueGenericReset+0x72>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    13f8:	88 85       	ldd	r24, Y+8	; 0x08
    13fa:	88 23       	and	r24, r24
    13fc:	91 f0       	breq	.+36     	; 0x1422 <xQueueGenericReset+0x82>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    13fe:	28 96       	adiw	r28, 0x08	; 8
    1400:	be 01       	movw	r22, r28
    1402:	80 e8       	ldi	r24, 0x80	; 128
    1404:	0e 94 3c 09 	call	0x1278	; 0x1278 <xTaskRemoveFromEventList>
    1408:	81 30       	cpi	r24, 0x01	; 1
    140a:	59 f4       	brne	.+22     	; 0x1422 <xQueueGenericReset+0x82>
				{
					queueYIELD_IF_USING_PREEMPTION();
    140c:	0e 94 93 08 	call	0x1126	; 0x1126 <vPortYield>
    1410:	08 c0       	rjmp	.+16     	; 0x1422 <xQueueGenericReset+0x82>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1412:	ce 01       	movw	r24, r28
    1414:	08 96       	adiw	r24, 0x08	; 8
    1416:	0e 94 96 10 	call	0x212c	; 0x212c <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    141a:	ce 01       	movw	r24, r28
    141c:	41 96       	adiw	r24, 0x11	; 17
    141e:	0e 94 96 10 	call	0x212c	; 0x212c <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1422:	0f 90       	pop	r0
    1424:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    1426:	81 e0       	ldi	r24, 0x01	; 1
    1428:	df 91       	pop	r29
    142a:	cf 91       	pop	r28
    142c:	08 95       	ret

Disassembly of section .text.xQueueGenericCreate:

00001a98 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    1a98:	0f 93       	push	r16
    1a9a:	1f 93       	push	r17
    1a9c:	cf 93       	push	r28
    1a9e:	df 93       	push	r29
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( UBaseType_t ) 0 )
    1aa0:	88 23       	and	r24, r24
    1aa2:	01 f1       	breq	.+64     	; 0x1ae4 <xQueueGenericCreate+0x4c>
    1aa4:	06 2f       	mov	r16, r22
    1aa6:	18 2f       	mov	r17, r24
	{
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    1aa8:	8f e1       	ldi	r24, 0x1F	; 31
    1aaa:	90 e0       	ldi	r25, 0x00	; 0
    1aac:	0e 94 c3 0b 	call	0x1786	; 0x1786 <pvPortMalloc>
    1ab0:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    1ab2:	89 2b       	or	r24, r25
    1ab4:	c9 f0       	breq	.+50     	; 0x1ae8 <xQueueGenericCreate+0x50>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1ab6:	10 9f       	mul	r17, r16
    1ab8:	c0 01       	movw	r24, r0
    1aba:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
    1abc:	01 96       	adiw	r24, 0x01	; 1
    1abe:	0e 94 c3 0b 	call	0x1786	; 0x1786 <pvPortMalloc>
    1ac2:	99 83       	std	Y+1, r25	; 0x01
    1ac4:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    1ac6:	89 2b       	or	r24, r25
    1ac8:	39 f0       	breq	.+14     	; 0x1ad8 <xQueueGenericCreate+0x40>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    1aca:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    1acc:	0c 8f       	std	Y+28, r16	; 0x1c
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    1ace:	61 e0       	ldi	r22, 0x01	; 1
    1ad0:	ce 01       	movw	r24, r28
    1ad2:	0e 94 d0 09 	call	0x13a0	; 0x13a0 <xQueueGenericReset>
    1ad6:	08 c0       	rjmp	.+16     	; 0x1ae8 <xQueueGenericCreate+0x50>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    1ad8:	ce 01       	movw	r24, r28
    1ada:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <vPortFree>

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
    1ade:	c0 e0       	ldi	r28, 0x00	; 0
    1ae0:	d0 e0       	ldi	r29, 0x00	; 0
    1ae2:	02 c0       	rjmp	.+4      	; 0x1ae8 <xQueueGenericCreate+0x50>
    1ae4:	c0 e0       	ldi	r28, 0x00	; 0
    1ae6:	d0 e0       	ldi	r29, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
    1ae8:	ce 01       	movw	r24, r28
    1aea:	df 91       	pop	r29
    1aec:	cf 91       	pop	r28
    1aee:	1f 91       	pop	r17
    1af0:	0f 91       	pop	r16
    1af2:	08 95       	ret

Disassembly of section .text.xQueueGenericSend:

00000580 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
 580:	6f 92       	push	r6
 582:	7f 92       	push	r7
 584:	8f 92       	push	r8
 586:	ef 92       	push	r14
 588:	ff 92       	push	r15
 58a:	0f 93       	push	r16
 58c:	1f 93       	push	r17
 58e:	cf 93       	push	r28
 590:	df 93       	push	r29
 592:	00 d0       	rcall	.+0      	; 0x594 <xQueueGenericSend+0x14>
 594:	00 d0       	rcall	.+0      	; 0x596 <xQueueGenericSend+0x16>
 596:	0f 92       	push	r0
 598:	cd b7       	in	r28, 0x3d	; 61
 59a:	de b7       	in	r29, 0x3e	; 62
 59c:	7c 01       	movw	r14, r24
 59e:	3a 01       	movw	r6, r20
 5a0:	86 2e       	mov	r8, r22
 5a2:	3d 83       	std	Y+5, r19	; 0x05
 5a4:	2c 83       	std	Y+4, r18	; 0x04
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 5a6:	10 e0       	ldi	r17, 0x00	; 0
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
 5a8:	0f b6       	in	r0, 0x3f	; 63
 5aa:	f8 94       	cli
 5ac:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 5ae:	f7 01       	movw	r30, r14
 5b0:	92 8d       	ldd	r25, Z+26	; 0x1a
 5b2:	83 8d       	ldd	r24, Z+27	; 0x1b
 5b4:	98 17       	cp	r25, r24
 5b6:	10 f0       	brcs	.+4      	; 0x5bc <xQueueGenericSend+0x3c>
 5b8:	02 30       	cpi	r16, 0x02	; 2
 5ba:	e9 f4       	brne	.+58     	; 0x5f6 <xQueueGenericSend+0x76>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 5bc:	20 2f       	mov	r18, r16
 5be:	68 2d       	mov	r22, r8
 5c0:	a3 01       	movw	r20, r6
 5c2:	c7 01       	movw	r24, r14
 5c4:	0e 94 7b 07 	call	0xef6	; 0xef6 <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 5c8:	f7 01       	movw	r30, r14
 5ca:	91 89       	ldd	r25, Z+17	; 0x11
 5cc:	99 23       	and	r25, r25
 5ce:	61 f0       	breq	.+24     	; 0x5e8 <xQueueGenericSend+0x68>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 5d0:	f1 e1       	ldi	r31, 0x11	; 17
 5d2:	ef 0e       	add	r14, r31
 5d4:	f1 1c       	adc	r15, r1
 5d6:	b7 01       	movw	r22, r14
 5d8:	80 e8       	ldi	r24, 0x80	; 128
 5da:	0e 94 3c 09 	call	0x1278	; 0x1278 <xTaskRemoveFromEventList>
 5de:	81 30       	cpi	r24, 0x01	; 1
 5e0:	31 f4       	brne	.+12     	; 0x5ee <xQueueGenericSend+0x6e>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
 5e2:	0e 94 93 08 	call	0x1126	; 0x1126 <vPortYield>
 5e6:	03 c0       	rjmp	.+6      	; 0x5ee <xQueueGenericSend+0x6e>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
 5e8:	81 11       	cpse	r24, r1
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
 5ea:	0e 94 93 08 	call	0x1126	; 0x1126 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
 5ee:	0f 90       	pop	r0
 5f0:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
 5f2:	81 e0       	ldi	r24, 0x01	; 1
 5f4:	4d c0       	rjmp	.+154    	; 0x690 <xQueueGenericSend+0x110>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
 5f6:	8c 81       	ldd	r24, Y+4	; 0x04
 5f8:	9d 81       	ldd	r25, Y+5	; 0x05
 5fa:	89 2b       	or	r24, r25
 5fc:	21 f4       	brne	.+8      	; 0x606 <xQueueGenericSend+0x86>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 5fe:	0f 90       	pop	r0
 600:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
 602:	80 e0       	ldi	r24, 0x00	; 0
 604:	45 c0       	rjmp	.+138    	; 0x690 <xQueueGenericSend+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
 606:	11 11       	cpse	r17, r1
 608:	05 c0       	rjmp	.+10     	; 0x614 <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
 60a:	ce 01       	movw	r24, r28
 60c:	01 96       	adiw	r24, 0x01	; 1
 60e:	0e 94 d4 10 	call	0x21a8	; 0x21a8 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 612:	11 e0       	ldi	r17, 0x01	; 1
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
 614:	0f 90       	pop	r0
 616:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 618:	0e 94 43 11 	call	0x2286	; 0x2286 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 61c:	0f b6       	in	r0, 0x3f	; 63
 61e:	f8 94       	cli
 620:	0f 92       	push	r0
 622:	f7 01       	movw	r30, r14
 624:	85 8d       	ldd	r24, Z+29	; 0x1d
 626:	8f 3f       	cpi	r24, 0xFF	; 255
 628:	09 f4       	brne	.+2      	; 0x62c <xQueueGenericSend+0xac>
 62a:	15 8e       	std	Z+29, r1	; 0x1d
 62c:	f7 01       	movw	r30, r14
 62e:	86 8d       	ldd	r24, Z+30	; 0x1e
 630:	8f 3f       	cpi	r24, 0xFF	; 255
 632:	09 f4       	brne	.+2      	; 0x636 <xQueueGenericSend+0xb6>
 634:	16 8e       	std	Z+30, r1	; 0x1e
 636:	0f 90       	pop	r0
 638:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 63a:	be 01       	movw	r22, r28
 63c:	6c 5f       	subi	r22, 0xFC	; 252
 63e:	7f 4f       	sbci	r23, 0xFF	; 255
 640:	ce 01       	movw	r24, r28
 642:	01 96       	adiw	r24, 0x01	; 1
 644:	0e 94 2b 0c 	call	0x1856	; 0x1856 <xTaskCheckForTimeOut>
 648:	81 11       	cpse	r24, r1
 64a:	1c c0       	rjmp	.+56     	; 0x684 <xQueueGenericSend+0x104>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 64c:	b7 01       	movw	r22, r14
 64e:	80 e8       	ldi	r24, 0x80	; 128
 650:	0e 94 7e 0f 	call	0x1efc	; 0x1efc <prvIsQueueFull>
 654:	88 23       	and	r24, r24
 656:	81 f0       	breq	.+32     	; 0x678 <xQueueGenericSend+0xf8>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 658:	6c 81       	ldd	r22, Y+4	; 0x04
 65a:	7d 81       	ldd	r23, Y+5	; 0x05
 65c:	c7 01       	movw	r24, r14
 65e:	08 96       	adiw	r24, 0x08	; 8
 660:	0e 94 61 0f 	call	0x1ec2	; 0x1ec2 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
 664:	c7 01       	movw	r24, r14
 666:	0e 94 52 0b 	call	0x16a4	; 0x16a4 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
 66a:	0e 94 d2 05 	call	0xba4	; 0xba4 <xTaskResumeAll>
 66e:	81 11       	cpse	r24, r1
 670:	9b cf       	rjmp	.-202    	; 0x5a8 <xQueueGenericSend+0x28>
				{
					portYIELD_WITHIN_API();
 672:	0e 94 93 08 	call	0x1126	; 0x1126 <vPortYield>
 676:	98 cf       	rjmp	.-208    	; 0x5a8 <xQueueGenericSend+0x28>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
 678:	c7 01       	movw	r24, r14
 67a:	0e 94 52 0b 	call	0x16a4	; 0x16a4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 67e:	0e 94 d2 05 	call	0xba4	; 0xba4 <xTaskResumeAll>
 682:	92 cf       	rjmp	.-220    	; 0x5a8 <xQueueGenericSend+0x28>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
 684:	c7 01       	movw	r24, r14
 686:	0e 94 52 0b 	call	0x16a4	; 0x16a4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 68a:	0e 94 d2 05 	call	0xba4	; 0xba4 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
 68e:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
 690:	0f 90       	pop	r0
 692:	0f 90       	pop	r0
 694:	0f 90       	pop	r0
 696:	0f 90       	pop	r0
 698:	0f 90       	pop	r0
 69a:	df 91       	pop	r29
 69c:	cf 91       	pop	r28
 69e:	1f 91       	pop	r17
 6a0:	0f 91       	pop	r16
 6a2:	ff 90       	pop	r15
 6a4:	ef 90       	pop	r14
 6a6:	8f 90       	pop	r8
 6a8:	7f 90       	pop	r7
 6aa:	6f 90       	pop	r6
 6ac:	08 95       	ret

Disassembly of section .text.xQueueGenericReceive:

00000112 <xQueueGenericReceive>:
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		configASSERT( xHandle );
		return xHandle;
	}
 112:	af 92       	push	r10
 114:	bf 92       	push	r11
 116:	cf 92       	push	r12
 118:	df 92       	push	r13
 11a:	ef 92       	push	r14
 11c:	ff 92       	push	r15
 11e:	0f 93       	push	r16
 120:	1f 93       	push	r17
 122:	cf 93       	push	r28
 124:	df 93       	push	r29
 126:	00 d0       	rcall	.+0      	; 0x128 <xQueueGenericReceive+0x16>
 128:	00 d0       	rcall	.+0      	; 0x12a <xQueueGenericReceive+0x18>
 12a:	0f 92       	push	r0
 12c:	cd b7       	in	r28, 0x3d	; 61
 12e:	de b7       	in	r29, 0x3e	; 62
 130:	8c 01       	movw	r16, r24
 132:	7b 01       	movw	r14, r22
 134:	5d 83       	std	Y+5, r21	; 0x05
 136:	4c 83       	std	Y+4, r20	; 0x04
 138:	c2 2e       	mov	r12, r18
 13a:	d1 2c       	mov	r13, r1
 13c:	0f b6       	in	r0, 0x3f	; 63
 13e:	f8 94       	cli
 140:	0f 92       	push	r0
 142:	f8 01       	movw	r30, r16
 144:	82 8d       	ldd	r24, Z+26	; 0x1a
 146:	88 23       	and	r24, r24
 148:	b9 f1       	breq	.+110    	; 0x1b8 <xQueueGenericReceive+0xa6>
 14a:	a6 80       	ldd	r10, Z+6	; 0x06
 14c:	b7 80       	ldd	r11, Z+7	; 0x07
 14e:	b7 01       	movw	r22, r14
 150:	c8 01       	movw	r24, r16
 152:	0e 94 9a 0f 	call	0x1f34	; 0x1f34 <prvCopyDataFromQueue>
 156:	c1 10       	cpse	r12, r1
 158:	1c c0       	rjmp	.+56     	; 0x192 <xQueueGenericReceive+0x80>
 15a:	f8 01       	movw	r30, r16
 15c:	82 8d       	ldd	r24, Z+26	; 0x1a
 15e:	81 50       	subi	r24, 0x01	; 1
 160:	82 8f       	std	Z+26, r24	; 0x1a
 162:	80 81       	ld	r24, Z
 164:	91 81       	ldd	r25, Z+1	; 0x01
 166:	89 2b       	or	r24, r25
 168:	29 f4       	brne	.+10     	; 0x174 <xQueueGenericReceive+0x62>
 16a:	0e 94 36 10 	call	0x206c	; 0x206c <pvTaskIncrementMutexHeldCount>
 16e:	f8 01       	movw	r30, r16
 170:	93 83       	std	Z+3, r25	; 0x03
 172:	82 83       	std	Z+2, r24	; 0x02
 174:	f8 01       	movw	r30, r16
 176:	80 85       	ldd	r24, Z+8	; 0x08
 178:	88 23       	and	r24, r24
 17a:	d1 f0       	breq	.+52     	; 0x1b0 <xQueueGenericReceive+0x9e>
 17c:	08 5f       	subi	r16, 0xF8	; 248
 17e:	1f 4f       	sbci	r17, 0xFF	; 255
 180:	b8 01       	movw	r22, r16
 182:	80 e8       	ldi	r24, 0x80	; 128
 184:	0e 94 3c 09 	call	0x1278	; 0x1278 <xTaskRemoveFromEventList>
 188:	81 30       	cpi	r24, 0x01	; 1
 18a:	91 f4       	brne	.+36     	; 0x1b0 <xQueueGenericReceive+0x9e>
 18c:	0e 94 93 08 	call	0x1126	; 0x1126 <vPortYield>
 190:	0f c0       	rjmp	.+30     	; 0x1b0 <xQueueGenericReceive+0x9e>
 192:	f8 01       	movw	r30, r16
 194:	b7 82       	std	Z+7, r11	; 0x07
 196:	a6 82       	std	Z+6, r10	; 0x06
 198:	81 89       	ldd	r24, Z+17	; 0x11
 19a:	88 23       	and	r24, r24
 19c:	49 f0       	breq	.+18     	; 0x1b0 <xQueueGenericReceive+0x9e>
 19e:	0f 5e       	subi	r16, 0xEF	; 239
 1a0:	1f 4f       	sbci	r17, 0xFF	; 255
 1a2:	b8 01       	movw	r22, r16
 1a4:	80 e8       	ldi	r24, 0x80	; 128
 1a6:	0e 94 3c 09 	call	0x1278	; 0x1278 <xTaskRemoveFromEventList>
 1aa:	81 11       	cpse	r24, r1
 1ac:	0e 94 93 08 	call	0x1126	; 0x1126 <vPortYield>
 1b0:	0f 90       	pop	r0
 1b2:	0f be       	out	0x3f, r0	; 63
 1b4:	81 e0       	ldi	r24, 0x01	; 1
 1b6:	5c c0       	rjmp	.+184    	; 0x270 <xQueueGenericReceive+0x15e>
 1b8:	8c 81       	ldd	r24, Y+4	; 0x04
 1ba:	9d 81       	ldd	r25, Y+5	; 0x05
 1bc:	89 2b       	or	r24, r25
 1be:	21 f4       	brne	.+8      	; 0x1c8 <xQueueGenericReceive+0xb6>
 1c0:	0f 90       	pop	r0
 1c2:	0f be       	out	0x3f, r0	; 63
 1c4:	80 e0       	ldi	r24, 0x00	; 0
 1c6:	54 c0       	rjmp	.+168    	; 0x270 <xQueueGenericReceive+0x15e>
 1c8:	d1 10       	cpse	r13, r1
 1ca:	06 c0       	rjmp	.+12     	; 0x1d8 <xQueueGenericReceive+0xc6>
 1cc:	ce 01       	movw	r24, r28
 1ce:	01 96       	adiw	r24, 0x01	; 1
 1d0:	0e 94 d4 10 	call	0x21a8	; 0x21a8 <vTaskSetTimeOutState>
 1d4:	dd 24       	eor	r13, r13
 1d6:	d3 94       	inc	r13
 1d8:	0f 90       	pop	r0
 1da:	0f be       	out	0x3f, r0	; 63
 1dc:	0e 94 43 11 	call	0x2286	; 0x2286 <vTaskSuspendAll>
 1e0:	0f b6       	in	r0, 0x3f	; 63
 1e2:	f8 94       	cli
 1e4:	0f 92       	push	r0
 1e6:	f8 01       	movw	r30, r16
 1e8:	85 8d       	ldd	r24, Z+29	; 0x1d
 1ea:	8f 3f       	cpi	r24, 0xFF	; 255
 1ec:	09 f4       	brne	.+2      	; 0x1f0 <xQueueGenericReceive+0xde>
 1ee:	15 8e       	std	Z+29, r1	; 0x1d
 1f0:	f8 01       	movw	r30, r16
 1f2:	86 8d       	ldd	r24, Z+30	; 0x1e
 1f4:	8f 3f       	cpi	r24, 0xFF	; 255
 1f6:	09 f4       	brne	.+2      	; 0x1fa <xQueueGenericReceive+0xe8>
 1f8:	16 8e       	std	Z+30, r1	; 0x1e
 1fa:	0f 90       	pop	r0
 1fc:	0f be       	out	0x3f, r0	; 63
 1fe:	be 01       	movw	r22, r28
 200:	6c 5f       	subi	r22, 0xFC	; 252
 202:	7f 4f       	sbci	r23, 0xFF	; 255
 204:	ce 01       	movw	r24, r28
 206:	01 96       	adiw	r24, 0x01	; 1
 208:	0e 94 2b 0c 	call	0x1856	; 0x1856 <xTaskCheckForTimeOut>
 20c:	81 11       	cpse	r24, r1
 20e:	2a c0       	rjmp	.+84     	; 0x264 <xQueueGenericReceive+0x152>
 210:	b8 01       	movw	r22, r16
 212:	80 e8       	ldi	r24, 0x80	; 128
 214:	0e 94 23 10 	call	0x2046	; 0x2046 <prvIsQueueEmpty>
 218:	88 23       	and	r24, r24
 21a:	f1 f0       	breq	.+60     	; 0x258 <xQueueGenericReceive+0x146>
 21c:	f8 01       	movw	r30, r16
 21e:	80 81       	ld	r24, Z
 220:	91 81       	ldd	r25, Z+1	; 0x01
 222:	89 2b       	or	r24, r25
 224:	49 f4       	brne	.+18     	; 0x238 <xQueueGenericReceive+0x126>
 226:	0f b6       	in	r0, 0x3f	; 63
 228:	f8 94       	cli
 22a:	0f 92       	push	r0
 22c:	82 81       	ldd	r24, Z+2	; 0x02
 22e:	93 81       	ldd	r25, Z+3	; 0x03
 230:	0e 94 19 07 	call	0xe32	; 0xe32 <vTaskPriorityInherit>
 234:	0f 90       	pop	r0
 236:	0f be       	out	0x3f, r0	; 63
 238:	6c 81       	ldd	r22, Y+4	; 0x04
 23a:	7d 81       	ldd	r23, Y+5	; 0x05
 23c:	c8 01       	movw	r24, r16
 23e:	41 96       	adiw	r24, 0x11	; 17
 240:	0e 94 61 0f 	call	0x1ec2	; 0x1ec2 <vTaskPlaceOnEventList>
 244:	c8 01       	movw	r24, r16
 246:	0e 94 52 0b 	call	0x16a4	; 0x16a4 <prvUnlockQueue>
 24a:	0e 94 d2 05 	call	0xba4	; 0xba4 <xTaskResumeAll>
 24e:	81 11       	cpse	r24, r1
 250:	75 cf       	rjmp	.-278    	; 0x13c <xQueueGenericReceive+0x2a>
 252:	0e 94 93 08 	call	0x1126	; 0x1126 <vPortYield>
 256:	72 cf       	rjmp	.-284    	; 0x13c <xQueueGenericReceive+0x2a>
 258:	c8 01       	movw	r24, r16
 25a:	0e 94 52 0b 	call	0x16a4	; 0x16a4 <prvUnlockQueue>
 25e:	0e 94 d2 05 	call	0xba4	; 0xba4 <xTaskResumeAll>
 262:	6c cf       	rjmp	.-296    	; 0x13c <xQueueGenericReceive+0x2a>
 264:	c8 01       	movw	r24, r16
 266:	0e 94 52 0b 	call	0x16a4	; 0x16a4 <prvUnlockQueue>
 26a:	0e 94 d2 05 	call	0xba4	; 0xba4 <xTaskResumeAll>
 26e:	80 e0       	ldi	r24, 0x00	; 0
 270:	0f 90       	pop	r0
 272:	0f 90       	pop	r0
 274:	0f 90       	pop	r0
 276:	0f 90       	pop	r0
 278:	0f 90       	pop	r0
 27a:	df 91       	pop	r29
 27c:	cf 91       	pop	r28
 27e:	1f 91       	pop	r17
 280:	0f 91       	pop	r16
 282:	ff 90       	pop	r15
 284:	ef 90       	pop	r14
 286:	df 90       	pop	r13
 288:	cf 90       	pop	r12
 28a:	bf 90       	pop	r11
 28c:	af 90       	pop	r10
 28e:	08 95       	ret

Disassembly of section .text.prvResetNextTaskUnblockTime:

00001e84 <prvResetNextTaskUnblockTime>:
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
	xSchedulerRunning = pdFALSE;
	vPortEndScheduler();
    1e84:	e0 91 ae 06 	lds	r30, 0x06AE	; 0x8006ae <pxDelayedTaskList>
    1e88:	f0 91 af 06 	lds	r31, 0x06AF	; 0x8006af <pxDelayedTaskList+0x1>
    1e8c:	80 81       	ld	r24, Z
    1e8e:	81 11       	cpse	r24, r1
    1e90:	07 c0       	rjmp	.+14     	; 0x1ea0 <prvResetNextTaskUnblockTime+0x1c>
    1e92:	8f ef       	ldi	r24, 0xFF	; 255
    1e94:	9f ef       	ldi	r25, 0xFF	; 255
    1e96:	90 93 a9 06 	sts	0x06A9, r25	; 0x8006a9 <xNextTaskUnblockTime+0x1>
    1e9a:	80 93 a8 06 	sts	0x06A8, r24	; 0x8006a8 <xNextTaskUnblockTime>
    1e9e:	08 95       	ret
    1ea0:	e0 91 ae 06 	lds	r30, 0x06AE	; 0x8006ae <pxDelayedTaskList>
    1ea4:	f0 91 af 06 	lds	r31, 0x06AF	; 0x8006af <pxDelayedTaskList+0x1>
    1ea8:	05 80       	ldd	r0, Z+5	; 0x05
    1eaa:	f6 81       	ldd	r31, Z+6	; 0x06
    1eac:	e0 2d       	mov	r30, r0
    1eae:	06 80       	ldd	r0, Z+6	; 0x06
    1eb0:	f7 81       	ldd	r31, Z+7	; 0x07
    1eb2:	e0 2d       	mov	r30, r0
    1eb4:	82 81       	ldd	r24, Z+2	; 0x02
    1eb6:	93 81       	ldd	r25, Z+3	; 0x03
    1eb8:	90 93 a9 06 	sts	0x06A9, r25	; 0x8006a9 <xNextTaskUnblockTime+0x1>
    1ebc:	80 93 a8 06 	sts	0x06A8, r24	; 0x8006a8 <xNextTaskUnblockTime>
    1ec0:	08 95       	ret

Disassembly of section .text.prvAllocateTCBAndStack:

00001bfa <prvAllocateTCBAndStack>:
    1bfa:	ef 92       	push	r14
    1bfc:	ff 92       	push	r15
    1bfe:	0f 93       	push	r16
    1c00:	1f 93       	push	r17
    1c02:	cf 93       	push	r28
    1c04:	df 93       	push	r29
    1c06:	7c 01       	movw	r14, r24
    1c08:	eb 01       	movw	r28, r22
    1c0a:	8f e2       	ldi	r24, 0x2F	; 47
    1c0c:	90 e0       	ldi	r25, 0x00	; 0
    1c0e:	0e 94 c3 0b 	call	0x1786	; 0x1786 <pvPortMalloc>
    1c12:	8c 01       	movw	r16, r24
    1c14:	89 2b       	or	r24, r25
    1c16:	89 f0       	breq	.+34     	; 0x1c3a <prvAllocateTCBAndStack+0x40>
    1c18:	20 97       	sbiw	r28, 0x00	; 0
    1c1a:	21 f4       	brne	.+8      	; 0x1c24 <prvAllocateTCBAndStack+0x2a>
    1c1c:	c7 01       	movw	r24, r14
    1c1e:	0e 94 c3 0b 	call	0x1786	; 0x1786 <pvPortMalloc>
    1c22:	01 c0       	rjmp	.+2      	; 0x1c26 <prvAllocateTCBAndStack+0x2c>
    1c24:	ce 01       	movw	r24, r28
    1c26:	f8 01       	movw	r30, r16
    1c28:	90 8f       	std	Z+24, r25	; 0x18
    1c2a:	87 8b       	std	Z+23, r24	; 0x17
    1c2c:	89 2b       	or	r24, r25
    1c2e:	29 f4       	brne	.+10     	; 0x1c3a <prvAllocateTCBAndStack+0x40>
    1c30:	c8 01       	movw	r24, r16
    1c32:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <vPortFree>
    1c36:	00 e0       	ldi	r16, 0x00	; 0
    1c38:	10 e0       	ldi	r17, 0x00	; 0
    1c3a:	c8 01       	movw	r24, r16
    1c3c:	df 91       	pop	r29
    1c3e:	cf 91       	pop	r28
    1c40:	1f 91       	pop	r17
    1c42:	0f 91       	pop	r16
    1c44:	ff 90       	pop	r15
    1c46:	ef 90       	pop	r14
    1c48:	08 95       	ret

Disassembly of section .text.prvDeleteTCB:

00002148 <prvDeleteTCB>:
    2148:	cf 93       	push	r28
    214a:	df 93       	push	r29
    214c:	ec 01       	movw	r28, r24
    214e:	8f 89       	ldd	r24, Y+23	; 0x17
    2150:	98 8d       	ldd	r25, Y+24	; 0x18
    2152:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <vPortFree>
    2156:	ce 01       	movw	r24, r28
    2158:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <vPortFree>
    215c:	df 91       	pop	r29
    215e:	cf 91       	pop	r28
    2160:	08 95       	ret

Disassembly of section .text.prvInitialiseTCBVariables:

0000142e <prvInitialiseTCBVariables>:
    142e:	cf 92       	push	r12
    1430:	df 92       	push	r13
    1432:	ef 92       	push	r14
    1434:	1f 93       	push	r17
    1436:	cf 93       	push	r28
    1438:	df 93       	push	r29
    143a:	ec 01       	movw	r28, r24
    143c:	6a 01       	movw	r12, r20
    143e:	e6 2e       	mov	r14, r22
    1440:	12 2f       	mov	r17, r18
    1442:	50 e0       	ldi	r21, 0x00	; 0
    1444:	18 c0       	rjmp	.+48     	; 0x1476 <prvInitialiseTCBVariables+0x48>
    1446:	25 2f       	mov	r18, r21
    1448:	30 e0       	ldi	r19, 0x00	; 0
    144a:	ae 2d       	mov	r26, r14
    144c:	c6 01       	movw	r24, r12
    144e:	82 0f       	add	r24, r18
    1450:	93 1f       	adc	r25, r19
    1452:	a1 1d       	adc	r26, r1
    1454:	37 fd       	sbrc	r19, 7
    1456:	aa 95       	dec	r26
    1458:	fc 01       	movw	r30, r24
    145a:	64 91       	lpm	r22, Z
    145c:	a7 fd       	sbrc	r26, 7
    145e:	60 81       	ld	r22, Z
    1460:	fe 01       	movw	r30, r28
    1462:	e2 0f       	add	r30, r18
    1464:	f3 1f       	adc	r31, r19
    1466:	61 8f       	std	Z+25, r22	; 0x19
    1468:	fc 01       	movw	r30, r24
    146a:	84 91       	lpm	r24, Z
    146c:	a7 fd       	sbrc	r26, 7
    146e:	80 81       	ld	r24, Z
    1470:	88 23       	and	r24, r24
    1472:	19 f0       	breq	.+6      	; 0x147a <prvInitialiseTCBVariables+0x4c>
    1474:	5f 5f       	subi	r21, 0xFF	; 255
    1476:	54 31       	cpi	r21, 0x14	; 20
    1478:	30 f3       	brcs	.-52     	; 0x1446 <prvInitialiseTCBVariables+0x18>
    147a:	1c a6       	std	Y+44, r1	; 0x2c
    147c:	14 30       	cpi	r17, 0x04	; 4
    147e:	08 f0       	brcs	.+2      	; 0x1482 <prvInitialiseTCBVariables+0x54>
    1480:	13 e0       	ldi	r17, 0x03	; 3
    1482:	1e 8b       	std	Y+22, r17	; 0x16
    1484:	1d a7       	std	Y+45, r17	; 0x2d
    1486:	1e a6       	std	Y+46, r1	; 0x2e
    1488:	ce 01       	movw	r24, r28
    148a:	02 96       	adiw	r24, 0x02	; 2
    148c:	0e 94 64 11 	call	0x22c8	; 0x22c8 <vListInitialiseItem>
    1490:	ce 01       	movw	r24, r28
    1492:	0c 96       	adiw	r24, 0x0c	; 12
    1494:	0e 94 64 11 	call	0x22c8	; 0x22c8 <vListInitialiseItem>
    1498:	d9 87       	std	Y+9, r29	; 0x09
    149a:	c8 87       	std	Y+8, r28	; 0x08
    149c:	84 e0       	ldi	r24, 0x04	; 4
    149e:	90 e0       	ldi	r25, 0x00	; 0
    14a0:	81 1b       	sub	r24, r17
    14a2:	91 09       	sbc	r25, r1
    14a4:	9d 87       	std	Y+13, r25	; 0x0d
    14a6:	8c 87       	std	Y+12, r24	; 0x0c
    14a8:	db 8b       	std	Y+19, r29	; 0x13
    14aa:	ca 8b       	std	Y+18, r28	; 0x12
    14ac:	df 91       	pop	r29
    14ae:	cf 91       	pop	r28
    14b0:	1f 91       	pop	r17
    14b2:	ef 90       	pop	r14
    14b4:	df 90       	pop	r13
    14b6:	cf 90       	pop	r12
    14b8:	08 95       	ret

Disassembly of section .text.prvInitialiseTaskLists:

000017f0 <prvInitialiseTaskLists>:
    17f0:	cf 93       	push	r28
    17f2:	c0 e0       	ldi	r28, 0x00	; 0
    17f4:	10 c0       	rjmp	.+32     	; 0x1816 <prvInitialiseTaskLists+0x26>
    17f6:	8c 2f       	mov	r24, r28
    17f8:	90 e0       	ldi	r25, 0x00	; 0
    17fa:	9c 01       	movw	r18, r24
    17fc:	22 0f       	add	r18, r18
    17fe:	33 1f       	adc	r19, r19
    1800:	22 0f       	add	r18, r18
    1802:	33 1f       	adc	r19, r19
    1804:	22 0f       	add	r18, r18
    1806:	33 1f       	adc	r19, r19
    1808:	82 0f       	add	r24, r18
    180a:	93 1f       	adc	r25, r19
    180c:	86 5a       	subi	r24, 0xA6	; 166
    180e:	99 4f       	sbci	r25, 0xF9	; 249
    1810:	0e 94 96 10 	call	0x212c	; 0x212c <vListInitialise>
    1814:	cf 5f       	subi	r28, 0xFF	; 255
    1816:	c4 30       	cpi	r28, 0x04	; 4
    1818:	70 f3       	brcs	.-36     	; 0x17f6 <prvInitialiseTaskLists+0x6>
    181a:	89 e9       	ldi	r24, 0x99	; 153
    181c:	96 e0       	ldi	r25, 0x06	; 6
    181e:	0e 94 96 10 	call	0x212c	; 0x212c <vListInitialise>
    1822:	80 e9       	ldi	r24, 0x90	; 144
    1824:	96 e0       	ldi	r25, 0x06	; 6
    1826:	0e 94 96 10 	call	0x212c	; 0x212c <vListInitialise>
    182a:	87 e8       	ldi	r24, 0x87	; 135
    182c:	96 e0       	ldi	r25, 0x06	; 6
    182e:	0e 94 96 10 	call	0x212c	; 0x212c <vListInitialise>
    1832:	8e e7       	ldi	r24, 0x7E	; 126
    1834:	96 e0       	ldi	r25, 0x06	; 6
    1836:	0e 94 96 10 	call	0x212c	; 0x212c <vListInitialise>
    183a:	89 e9       	ldi	r24, 0x99	; 153
    183c:	96 e0       	ldi	r25, 0x06	; 6
    183e:	90 93 af 06 	sts	0x06AF, r25	; 0x8006af <pxDelayedTaskList+0x1>
    1842:	80 93 ae 06 	sts	0x06AE, r24	; 0x8006ae <pxDelayedTaskList>
    1846:	80 e9       	ldi	r24, 0x90	; 144
    1848:	96 e0       	ldi	r25, 0x06	; 6
    184a:	90 93 ad 06 	sts	0x06AD, r25	; 0x8006ad <pxOverflowDelayedTaskList+0x1>
    184e:	80 93 ac 06 	sts	0x06AC, r24	; 0x8006ac <pxOverflowDelayedTaskList>
    1852:	cf 91       	pop	r28
    1854:	08 95       	ret

Disassembly of section .text.prvAddCurrentTaskToDelayedList:

00001718 <prvAddCurrentTaskToDelayedList>:
    1718:	cf 93       	push	r28
    171a:	df 93       	push	r29
    171c:	ec 01       	movw	r28, r24
    171e:	e0 91 b0 06 	lds	r30, 0x06B0	; 0x8006b0 <pxCurrentTCB>
    1722:	f0 91 b1 06 	lds	r31, 0x06B1	; 0x8006b1 <pxCurrentTCB+0x1>
    1726:	93 83       	std	Z+3, r25	; 0x03
    1728:	82 83       	std	Z+2, r24	; 0x02
    172a:	80 91 aa 06 	lds	r24, 0x06AA	; 0x8006aa <xTickCount>
    172e:	90 91 ab 06 	lds	r25, 0x06AB	; 0x8006ab <xTickCount+0x1>
    1732:	c8 17       	cp	r28, r24
    1734:	d9 07       	cpc	r29, r25
    1736:	68 f4       	brcc	.+26     	; 0x1752 <prvAddCurrentTaskToDelayedList+0x3a>
    1738:	60 91 b0 06 	lds	r22, 0x06B0	; 0x8006b0 <pxCurrentTCB>
    173c:	70 91 b1 06 	lds	r23, 0x06B1	; 0x8006b1 <pxCurrentTCB+0x1>
    1740:	80 91 ac 06 	lds	r24, 0x06AC	; 0x8006ac <pxOverflowDelayedTaskList>
    1744:	90 91 ad 06 	lds	r25, 0x06AD	; 0x8006ad <pxOverflowDelayedTaskList+0x1>
    1748:	6e 5f       	subi	r22, 0xFE	; 254
    174a:	7f 4f       	sbci	r23, 0xFF	; 255
    174c:	0e 94 5d 0c 	call	0x18ba	; 0x18ba <vListInsert>
    1750:	17 c0       	rjmp	.+46     	; 0x1780 <prvAddCurrentTaskToDelayedList+0x68>
    1752:	60 91 b0 06 	lds	r22, 0x06B0	; 0x8006b0 <pxCurrentTCB>
    1756:	70 91 b1 06 	lds	r23, 0x06B1	; 0x8006b1 <pxCurrentTCB+0x1>
    175a:	80 91 ae 06 	lds	r24, 0x06AE	; 0x8006ae <pxDelayedTaskList>
    175e:	90 91 af 06 	lds	r25, 0x06AF	; 0x8006af <pxDelayedTaskList+0x1>
    1762:	6e 5f       	subi	r22, 0xFE	; 254
    1764:	7f 4f       	sbci	r23, 0xFF	; 255
    1766:	0e 94 5d 0c 	call	0x18ba	; 0x18ba <vListInsert>
    176a:	80 91 a8 06 	lds	r24, 0x06A8	; 0x8006a8 <xNextTaskUnblockTime>
    176e:	90 91 a9 06 	lds	r25, 0x06A9	; 0x8006a9 <xNextTaskUnblockTime+0x1>
    1772:	c8 17       	cp	r28, r24
    1774:	d9 07       	cpc	r29, r25
    1776:	20 f4       	brcc	.+8      	; 0x1780 <prvAddCurrentTaskToDelayedList+0x68>
    1778:	d0 93 a9 06 	sts	0x06A9, r29	; 0x8006a9 <xNextTaskUnblockTime+0x1>
    177c:	c0 93 a8 06 	sts	0x06A8, r28	; 0x8006a8 <xNextTaskUnblockTime>
    1780:	df 91       	pop	r29
    1782:	cf 91       	pop	r28
    1784:	08 95       	ret

Disassembly of section .text.xTaskGenericCreate:

00000290 <xTaskGenericCreate>:
 290:	2f 92       	push	r2
 292:	3f 92       	push	r3
 294:	4f 92       	push	r4
 296:	5f 92       	push	r5
 298:	6f 92       	push	r6
 29a:	7f 92       	push	r7
 29c:	8f 92       	push	r8
 29e:	9f 92       	push	r9
 2a0:	af 92       	push	r10
 2a2:	bf 92       	push	r11
 2a4:	cf 92       	push	r12
 2a6:	df 92       	push	r13
 2a8:	ef 92       	push	r14
 2aa:	ff 92       	push	r15
 2ac:	0f 93       	push	r16
 2ae:	1f 93       	push	r17
 2b0:	cf 93       	push	r28
 2b2:	df 93       	push	r29
 2b4:	00 d0       	rcall	.+0      	; 0x2b6 <xTaskGenericCreate+0x26>
 2b6:	00 d0       	rcall	.+0      	; 0x2b8 <xTaskGenericCreate+0x28>
 2b8:	0f 92       	push	r0
 2ba:	cd b7       	in	r28, 0x3d	; 61
 2bc:	de b7       	in	r29, 0x3e	; 62
 2be:	9a 83       	std	Y+2, r25	; 0x02
 2c0:	89 83       	std	Y+1, r24	; 0x01
 2c2:	4b 83       	std	Y+3, r20	; 0x03
 2c4:	5c 83       	std	Y+4, r21	; 0x04
 2c6:	6d 83       	std	Y+5, r22	; 0x05
 2c8:	49 01       	movw	r8, r18
 2ca:	18 01       	movw	r2, r16
 2cc:	1e 2d       	mov	r17, r14
 2ce:	36 01       	movw	r6, r12
 2d0:	b5 01       	movw	r22, r10
 2d2:	c9 01       	movw	r24, r18
 2d4:	0e 94 fd 0d 	call	0x1bfa	; 0x1bfa <prvAllocateTCBAndStack>
 2d8:	5c 01       	movw	r10, r24
 2da:	00 97       	sbiw	r24, 0x00	; 0
 2dc:	09 f4       	brne	.+2      	; 0x2e0 <xTaskGenericCreate+0x50>
 2de:	6b c0       	rjmp	.+214    	; 0x3b6 <xTaskGenericCreate+0x126>
 2e0:	fc 01       	movw	r30, r24
 2e2:	47 88       	ldd	r4, Z+23	; 0x17
 2e4:	50 8c       	ldd	r5, Z+24	; 0x18
 2e6:	c4 01       	movw	r24, r8
 2e8:	01 97       	sbiw	r24, 0x01	; 1
 2ea:	48 0e       	add	r4, r24
 2ec:	59 1e       	adc	r5, r25
 2ee:	64 01       	movw	r12, r8
 2f0:	ea 8c       	ldd	r14, Y+26	; 0x1a
 2f2:	fb 8c       	ldd	r15, Y+27	; 0x1b
 2f4:	0c 8d       	ldd	r16, Y+28	; 0x1c
 2f6:	21 2f       	mov	r18, r17
 2f8:	4b 81       	ldd	r20, Y+3	; 0x03
 2fa:	5c 81       	ldd	r21, Y+4	; 0x04
 2fc:	6d 81       	ldd	r22, Y+5	; 0x05
 2fe:	c5 01       	movw	r24, r10
 300:	0e 94 17 0a 	call	0x142e	; 0x142e <prvInitialiseTCBVariables>
 304:	a1 01       	movw	r20, r2
 306:	69 81       	ldd	r22, Y+1	; 0x01
 308:	7a 81       	ldd	r23, Y+2	; 0x02
 30a:	c2 01       	movw	r24, r4
 30c:	0e 94 43 06 	call	0xc86	; 0xc86 <pxPortInitialiseStack>
 310:	f5 01       	movw	r30, r10
 312:	91 83       	std	Z+1, r25	; 0x01
 314:	80 83       	st	Z, r24
 316:	61 14       	cp	r6, r1
 318:	71 04       	cpc	r7, r1
 31a:	19 f0       	breq	.+6      	; 0x322 <xTaskGenericCreate+0x92>
 31c:	f3 01       	movw	r30, r6
 31e:	b1 82       	std	Z+1, r11	; 0x01
 320:	a0 82       	st	Z, r10
 322:	0f b6       	in	r0, 0x3f	; 63
 324:	f8 94       	cli
 326:	0f 92       	push	r0
 328:	80 91 c1 06 	lds	r24, 0x06C1	; 0x8006c1 <uxCurrentNumberOfTasks>
 32c:	8f 5f       	subi	r24, 0xFF	; 255
 32e:	80 93 c1 06 	sts	0x06C1, r24	; 0x8006c1 <uxCurrentNumberOfTasks>
 332:	80 91 b0 06 	lds	r24, 0x06B0	; 0x8006b0 <pxCurrentTCB>
 336:	90 91 b1 06 	lds	r25, 0x06B1	; 0x8006b1 <pxCurrentTCB+0x1>
 33a:	89 2b       	or	r24, r25
 33c:	59 f4       	brne	.+22     	; 0x354 <xTaskGenericCreate+0xc4>
 33e:	b0 92 b1 06 	sts	0x06B1, r11	; 0x8006b1 <pxCurrentTCB+0x1>
 342:	a0 92 b0 06 	sts	0x06B0, r10	; 0x8006b0 <pxCurrentTCB>
 346:	80 91 c1 06 	lds	r24, 0x06C1	; 0x8006c1 <uxCurrentNumberOfTasks>
 34a:	81 30       	cpi	r24, 0x01	; 1
 34c:	91 f4       	brne	.+36     	; 0x372 <xTaskGenericCreate+0xe2>
 34e:	0e 94 f8 0b 	call	0x17f0	; 0x17f0 <prvInitialiseTaskLists>
 352:	0f c0       	rjmp	.+30     	; 0x372 <xTaskGenericCreate+0xe2>
 354:	80 91 bf 06 	lds	r24, 0x06BF	; 0x8006bf <xSchedulerRunning>
 358:	81 11       	cpse	r24, r1
 35a:	0b c0       	rjmp	.+22     	; 0x372 <xTaskGenericCreate+0xe2>
 35c:	e0 91 b0 06 	lds	r30, 0x06B0	; 0x8006b0 <pxCurrentTCB>
 360:	f0 91 b1 06 	lds	r31, 0x06B1	; 0x8006b1 <pxCurrentTCB+0x1>
 364:	86 89       	ldd	r24, Z+22	; 0x16
 366:	18 17       	cp	r17, r24
 368:	20 f0       	brcs	.+8      	; 0x372 <xTaskGenericCreate+0xe2>
 36a:	b0 92 b1 06 	sts	0x06B1, r11	; 0x8006b1 <pxCurrentTCB+0x1>
 36e:	a0 92 b0 06 	sts	0x06B0, r10	; 0x8006b0 <pxCurrentTCB>
 372:	80 91 bb 06 	lds	r24, 0x06BB	; 0x8006bb <uxTaskNumber>
 376:	8f 5f       	subi	r24, 0xFF	; 255
 378:	80 93 bb 06 	sts	0x06BB, r24	; 0x8006bb <uxTaskNumber>
 37c:	f5 01       	movw	r30, r10
 37e:	86 89       	ldd	r24, Z+22	; 0x16
 380:	90 91 c0 06 	lds	r25, 0x06C0	; 0x8006c0 <uxTopReadyPriority>
 384:	98 17       	cp	r25, r24
 386:	10 f4       	brcc	.+4      	; 0x38c <xTaskGenericCreate+0xfc>
 388:	80 93 c0 06 	sts	0x06C0, r24	; 0x8006c0 <uxTopReadyPriority>
 38c:	90 e0       	ldi	r25, 0x00	; 0
 38e:	b5 01       	movw	r22, r10
 390:	6e 5f       	subi	r22, 0xFE	; 254
 392:	7f 4f       	sbci	r23, 0xFF	; 255
 394:	9c 01       	movw	r18, r24
 396:	22 0f       	add	r18, r18
 398:	33 1f       	adc	r19, r19
 39a:	22 0f       	add	r18, r18
 39c:	33 1f       	adc	r19, r19
 39e:	22 0f       	add	r18, r18
 3a0:	33 1f       	adc	r19, r19
 3a2:	82 0f       	add	r24, r18
 3a4:	93 1f       	adc	r25, r19
 3a6:	86 5a       	subi	r24, 0xA6	; 166
 3a8:	99 4f       	sbci	r25, 0xF9	; 249
 3aa:	0e 94 21 0f 	call	0x1e42	; 0x1e42 <vListInsertEnd>
 3ae:	0f 90       	pop	r0
 3b0:	0f be       	out	0x3f, r0	; 63
 3b2:	01 e0       	ldi	r16, 0x01	; 1
 3b4:	01 c0       	rjmp	.+2      	; 0x3b8 <xTaskGenericCreate+0x128>
 3b6:	0f ef       	ldi	r16, 0xFF	; 255
 3b8:	01 30       	cpi	r16, 0x01	; 1
 3ba:	69 f4       	brne	.+26     	; 0x3d6 <xTaskGenericCreate+0x146>
 3bc:	80 91 bf 06 	lds	r24, 0x06BF	; 0x8006bf <xSchedulerRunning>
 3c0:	88 23       	and	r24, r24
 3c2:	49 f0       	breq	.+18     	; 0x3d6 <xTaskGenericCreate+0x146>
 3c4:	e0 91 b0 06 	lds	r30, 0x06B0	; 0x8006b0 <pxCurrentTCB>
 3c8:	f0 91 b1 06 	lds	r31, 0x06B1	; 0x8006b1 <pxCurrentTCB+0x1>
 3cc:	86 89       	ldd	r24, Z+22	; 0x16
 3ce:	81 17       	cp	r24, r17
 3d0:	10 f4       	brcc	.+4      	; 0x3d6 <xTaskGenericCreate+0x146>
 3d2:	0e 94 93 08 	call	0x1126	; 0x1126 <vPortYield>
 3d6:	80 2f       	mov	r24, r16
 3d8:	0f 90       	pop	r0
 3da:	0f 90       	pop	r0
 3dc:	0f 90       	pop	r0
 3de:	0f 90       	pop	r0
 3e0:	0f 90       	pop	r0
 3e2:	df 91       	pop	r29
 3e4:	cf 91       	pop	r28
 3e6:	1f 91       	pop	r17
 3e8:	0f 91       	pop	r16
 3ea:	ff 90       	pop	r15
 3ec:	ef 90       	pop	r14
 3ee:	df 90       	pop	r13
 3f0:	cf 90       	pop	r12
 3f2:	bf 90       	pop	r11
 3f4:	af 90       	pop	r10
 3f6:	9f 90       	pop	r9
 3f8:	8f 90       	pop	r8
 3fa:	7f 90       	pop	r7
 3fc:	6f 90       	pop	r6
 3fe:	5f 90       	pop	r5
 400:	4f 90       	pop	r4
 402:	3f 90       	pop	r3
 404:	2f 90       	pop	r2
 406:	08 95       	ret

Disassembly of section .text.vTaskStartScheduler:

0000197c <vTaskStartScheduler>:
    197c:	af 92       	push	r10
    197e:	bf 92       	push	r11
    1980:	cf 92       	push	r12
    1982:	df 92       	push	r13
    1984:	ef 92       	push	r14
    1986:	0f 93       	push	r16
    1988:	1f 93       	push	r17
    198a:	1f 92       	push	r1
    198c:	1f 92       	push	r1
    198e:	1f 92       	push	r1
    1990:	a1 2c       	mov	r10, r1
    1992:	b1 2c       	mov	r11, r1
    1994:	c1 2c       	mov	r12, r1
    1996:	d1 2c       	mov	r13, r1
    1998:	e1 2c       	mov	r14, r1
    199a:	00 e0       	ldi	r16, 0x00	; 0
    199c:	10 e0       	ldi	r17, 0x00	; 0
    199e:	25 e5       	ldi	r18, 0x55	; 85
    19a0:	30 e0       	ldi	r19, 0x00	; 0
    19a2:	4c e0       	ldi	r20, 0x0C	; 12
    19a4:	51 e0       	ldi	r21, 0x01	; 1
    19a6:	60 e0       	ldi	r22, 0x00	; 0
    19a8:	83 ef       	ldi	r24, 0xF3	; 243
    19aa:	90 e1       	ldi	r25, 0x10	; 16
    19ac:	0e 94 48 01 	call	0x290	; 0x290 <xTaskGenericCreate>
    19b0:	0f 90       	pop	r0
    19b2:	0f 90       	pop	r0
    19b4:	0f 90       	pop	r0
    19b6:	81 30       	cpi	r24, 0x01	; 1
    19b8:	49 f4       	brne	.+18     	; 0x19cc <vTaskStartScheduler+0x50>
    19ba:	f8 94       	cli
    19bc:	80 93 bf 06 	sts	0x06BF, r24	; 0x8006bf <xSchedulerRunning>
    19c0:	10 92 ab 06 	sts	0x06AB, r1	; 0x8006ab <xTickCount+0x1>
    19c4:	10 92 aa 06 	sts	0x06AA, r1	; 0x8006aa <xTickCount>
    19c8:	0e 94 ee 0c 	call	0x19dc	; 0x19dc <xPortStartScheduler>
    19cc:	1f 91       	pop	r17
    19ce:	0f 91       	pop	r16
    19d0:	ef 90       	pop	r14
    19d2:	df 90       	pop	r13
    19d4:	cf 90       	pop	r12
    19d6:	bf 90       	pop	r11
    19d8:	af 90       	pop	r10
    19da:	08 95       	ret

Disassembly of section .text.vTaskSuspendAll:

00002286 <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    2286:	80 91 ba 06 	lds	r24, 0x06BA	; 0x8006ba <uxSchedulerSuspended>
    228a:	8f 5f       	subi	r24, 0xFF	; 255
    228c:	80 93 ba 06 	sts	0x06BA, r24	; 0x8006ba <uxSchedulerSuspended>
    2290:	08 95       	ret

Disassembly of section .text.xTaskIncrementTick:

00000408 <xTaskIncrementTick>:
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
	xSchedulerRunning = pdFALSE;
	vPortEndScheduler();
 408:	df 92       	push	r13
 40a:	ef 92       	push	r14
 40c:	ff 92       	push	r15
 40e:	0f 93       	push	r16
 410:	1f 93       	push	r17
 412:	cf 93       	push	r28
 414:	df 93       	push	r29
 416:	80 91 ba 06 	lds	r24, 0x06BA	; 0x8006ba <uxSchedulerSuspended>
 41a:	81 11       	cpse	r24, r1
 41c:	99 c0       	rjmp	.+306    	; 0x550 <xTaskIncrementTick+0x148>
 41e:	80 91 aa 06 	lds	r24, 0x06AA	; 0x8006aa <xTickCount>
 422:	90 91 ab 06 	lds	r25, 0x06AB	; 0x8006ab <xTickCount+0x1>
 426:	01 96       	adiw	r24, 0x01	; 1
 428:	90 93 ab 06 	sts	0x06AB, r25	; 0x8006ab <xTickCount+0x1>
 42c:	80 93 aa 06 	sts	0x06AA, r24	; 0x8006aa <xTickCount>
 430:	e0 90 aa 06 	lds	r14, 0x06AA	; 0x8006aa <xTickCount>
 434:	f0 90 ab 06 	lds	r15, 0x06AB	; 0x8006ab <xTickCount+0x1>
 438:	e1 14       	cp	r14, r1
 43a:	f1 04       	cpc	r15, r1
 43c:	b9 f4       	brne	.+46     	; 0x46c <xTaskIncrementTick+0x64>
 43e:	80 91 ae 06 	lds	r24, 0x06AE	; 0x8006ae <pxDelayedTaskList>
 442:	90 91 af 06 	lds	r25, 0x06AF	; 0x8006af <pxDelayedTaskList+0x1>
 446:	20 91 ac 06 	lds	r18, 0x06AC	; 0x8006ac <pxOverflowDelayedTaskList>
 44a:	30 91 ad 06 	lds	r19, 0x06AD	; 0x8006ad <pxOverflowDelayedTaskList+0x1>
 44e:	30 93 af 06 	sts	0x06AF, r19	; 0x8006af <pxDelayedTaskList+0x1>
 452:	20 93 ae 06 	sts	0x06AE, r18	; 0x8006ae <pxDelayedTaskList>
 456:	90 93 ad 06 	sts	0x06AD, r25	; 0x8006ad <pxOverflowDelayedTaskList+0x1>
 45a:	80 93 ac 06 	sts	0x06AC, r24	; 0x8006ac <pxOverflowDelayedTaskList>
 45e:	80 91 bc 06 	lds	r24, 0x06BC	; 0x8006bc <xNumOfOverflows>
 462:	8f 5f       	subi	r24, 0xFF	; 255
 464:	80 93 bc 06 	sts	0x06BC, r24	; 0x8006bc <xNumOfOverflows>
 468:	0e 94 42 0f 	call	0x1e84	; 0x1e84 <prvResetNextTaskUnblockTime>
 46c:	80 91 a8 06 	lds	r24, 0x06A8	; 0x8006a8 <xNextTaskUnblockTime>
 470:	90 91 a9 06 	lds	r25, 0x06A9	; 0x8006a9 <xNextTaskUnblockTime+0x1>
 474:	e8 16       	cp	r14, r24
 476:	f9 06       	cpc	r15, r25
 478:	28 f4       	brcc	.+10     	; 0x484 <xTaskIncrementTick+0x7c>
 47a:	d1 2c       	mov	r13, r1
 47c:	53 c0       	rjmp	.+166    	; 0x524 <xTaskIncrementTick+0x11c>
 47e:	dd 24       	eor	r13, r13
 480:	d3 94       	inc	r13
 482:	01 c0       	rjmp	.+2      	; 0x486 <xTaskIncrementTick+0x7e>
 484:	d1 2c       	mov	r13, r1
 486:	e0 91 ae 06 	lds	r30, 0x06AE	; 0x8006ae <pxDelayedTaskList>
 48a:	f0 91 af 06 	lds	r31, 0x06AF	; 0x8006af <pxDelayedTaskList+0x1>
 48e:	80 81       	ld	r24, Z
 490:	81 11       	cpse	r24, r1
 492:	07 c0       	rjmp	.+14     	; 0x4a2 <xTaskIncrementTick+0x9a>
 494:	8f ef       	ldi	r24, 0xFF	; 255
 496:	9f ef       	ldi	r25, 0xFF	; 255
 498:	90 93 a9 06 	sts	0x06A9, r25	; 0x8006a9 <xNextTaskUnblockTime+0x1>
 49c:	80 93 a8 06 	sts	0x06A8, r24	; 0x8006a8 <xNextTaskUnblockTime>
 4a0:	41 c0       	rjmp	.+130    	; 0x524 <xTaskIncrementTick+0x11c>
 4a2:	e0 91 ae 06 	lds	r30, 0x06AE	; 0x8006ae <pxDelayedTaskList>
 4a6:	f0 91 af 06 	lds	r31, 0x06AF	; 0x8006af <pxDelayedTaskList+0x1>
 4aa:	05 80       	ldd	r0, Z+5	; 0x05
 4ac:	f6 81       	ldd	r31, Z+6	; 0x06
 4ae:	e0 2d       	mov	r30, r0
 4b0:	c6 81       	ldd	r28, Z+6	; 0x06
 4b2:	d7 81       	ldd	r29, Z+7	; 0x07
 4b4:	8a 81       	ldd	r24, Y+2	; 0x02
 4b6:	9b 81       	ldd	r25, Y+3	; 0x03
 4b8:	e8 16       	cp	r14, r24
 4ba:	f9 06       	cpc	r15, r25
 4bc:	28 f4       	brcc	.+10     	; 0x4c8 <xTaskIncrementTick+0xc0>
 4be:	90 93 a9 06 	sts	0x06A9, r25	; 0x8006a9 <xNextTaskUnblockTime+0x1>
 4c2:	80 93 a8 06 	sts	0x06A8, r24	; 0x8006a8 <xNextTaskUnblockTime>
 4c6:	2e c0       	rjmp	.+92     	; 0x524 <xTaskIncrementTick+0x11c>
 4c8:	8e 01       	movw	r16, r28
 4ca:	0e 5f       	subi	r16, 0xFE	; 254
 4cc:	1f 4f       	sbci	r17, 0xFF	; 255
 4ce:	c8 01       	movw	r24, r16
 4d0:	0e 94 4c 0e 	call	0x1c98	; 0x1c98 <uxListRemove>
 4d4:	8c 89       	ldd	r24, Y+20	; 0x14
 4d6:	9d 89       	ldd	r25, Y+21	; 0x15
 4d8:	89 2b       	or	r24, r25
 4da:	21 f0       	breq	.+8      	; 0x4e4 <xTaskIncrementTick+0xdc>
 4dc:	ce 01       	movw	r24, r28
 4de:	0c 96       	adiw	r24, 0x0c	; 12
 4e0:	0e 94 4c 0e 	call	0x1c98	; 0x1c98 <uxListRemove>
 4e4:	8e 89       	ldd	r24, Y+22	; 0x16
 4e6:	90 91 c0 06 	lds	r25, 0x06C0	; 0x8006c0 <uxTopReadyPriority>
 4ea:	98 17       	cp	r25, r24
 4ec:	10 f4       	brcc	.+4      	; 0x4f2 <xTaskIncrementTick+0xea>
 4ee:	80 93 c0 06 	sts	0x06C0, r24	; 0x8006c0 <uxTopReadyPriority>
 4f2:	90 e0       	ldi	r25, 0x00	; 0
 4f4:	9c 01       	movw	r18, r24
 4f6:	22 0f       	add	r18, r18
 4f8:	33 1f       	adc	r19, r19
 4fa:	22 0f       	add	r18, r18
 4fc:	33 1f       	adc	r19, r19
 4fe:	22 0f       	add	r18, r18
 500:	33 1f       	adc	r19, r19
 502:	82 0f       	add	r24, r18
 504:	93 1f       	adc	r25, r19
 506:	b8 01       	movw	r22, r16
 508:	86 5a       	subi	r24, 0xA6	; 166
 50a:	99 4f       	sbci	r25, 0xF9	; 249
 50c:	0e 94 21 0f 	call	0x1e42	; 0x1e42 <vListInsertEnd>
 510:	9e 89       	ldd	r25, Y+22	; 0x16
 512:	e0 91 b0 06 	lds	r30, 0x06B0	; 0x8006b0 <pxCurrentTCB>
 516:	f0 91 b1 06 	lds	r31, 0x06B1	; 0x8006b1 <pxCurrentTCB+0x1>
 51a:	86 89       	ldd	r24, Z+22	; 0x16
 51c:	98 17       	cp	r25, r24
 51e:	08 f0       	brcs	.+2      	; 0x522 <xTaskIncrementTick+0x11a>
 520:	ae cf       	rjmp	.-164    	; 0x47e <xTaskIncrementTick+0x76>
 522:	b1 cf       	rjmp	.-158    	; 0x486 <xTaskIncrementTick+0x7e>
 524:	e0 91 b0 06 	lds	r30, 0x06B0	; 0x8006b0 <pxCurrentTCB>
 528:	f0 91 b1 06 	lds	r31, 0x06B1	; 0x8006b1 <pxCurrentTCB+0x1>
 52c:	86 89       	ldd	r24, Z+22	; 0x16
 52e:	90 e0       	ldi	r25, 0x00	; 0
 530:	fc 01       	movw	r30, r24
 532:	ee 0f       	add	r30, r30
 534:	ff 1f       	adc	r31, r31
 536:	ee 0f       	add	r30, r30
 538:	ff 1f       	adc	r31, r31
 53a:	ee 0f       	add	r30, r30
 53c:	ff 1f       	adc	r31, r31
 53e:	8e 0f       	add	r24, r30
 540:	9f 1f       	adc	r25, r31
 542:	fc 01       	movw	r30, r24
 544:	e6 5a       	subi	r30, 0xA6	; 166
 546:	f9 4f       	sbci	r31, 0xF9	; 249
 548:	80 81       	ld	r24, Z
 54a:	82 30       	cpi	r24, 0x02	; 2
 54c:	40 f4       	brcc	.+16     	; 0x55e <xTaskIncrementTick+0x156>
 54e:	09 c0       	rjmp	.+18     	; 0x562 <xTaskIncrementTick+0x15a>
 550:	80 91 be 06 	lds	r24, 0x06BE	; 0x8006be <uxPendedTicks>
 554:	8f 5f       	subi	r24, 0xFF	; 255
 556:	80 93 be 06 	sts	0x06BE, r24	; 0x8006be <uxPendedTicks>
 55a:	d1 2c       	mov	r13, r1
 55c:	02 c0       	rjmp	.+4      	; 0x562 <xTaskIncrementTick+0x15a>
 55e:	dd 24       	eor	r13, r13
 560:	d3 94       	inc	r13
 562:	80 91 bd 06 	lds	r24, 0x06BD	; 0x8006bd <xYieldPending>
 566:	88 23       	and	r24, r24
 568:	11 f0       	breq	.+4      	; 0x56e <xTaskIncrementTick+0x166>
 56a:	dd 24       	eor	r13, r13
 56c:	d3 94       	inc	r13
 56e:	8d 2d       	mov	r24, r13
 570:	df 91       	pop	r29
 572:	cf 91       	pop	r28
 574:	1f 91       	pop	r17
 576:	0f 91       	pop	r16
 578:	ff 90       	pop	r15
 57a:	ef 90       	pop	r14
 57c:	df 90       	pop	r13
 57e:	08 95       	ret

Disassembly of section .text.xTaskResumeAll:

00000ba4 <xTaskResumeAll>:
 ba4:	0f 93       	push	r16
 ba6:	1f 93       	push	r17
 ba8:	cf 93       	push	r28
 baa:	df 93       	push	r29
 bac:	0f b6       	in	r0, 0x3f	; 63
 bae:	f8 94       	cli
 bb0:	0f 92       	push	r0
 bb2:	80 91 ba 06 	lds	r24, 0x06BA	; 0x8006ba <uxSchedulerSuspended>
 bb6:	81 50       	subi	r24, 0x01	; 1
 bb8:	80 93 ba 06 	sts	0x06BA, r24	; 0x8006ba <uxSchedulerSuspended>
 bbc:	80 91 ba 06 	lds	r24, 0x06BA	; 0x8006ba <uxSchedulerSuspended>
 bc0:	81 11       	cpse	r24, r1
 bc2:	57 c0       	rjmp	.+174    	; 0xc72 <xTaskResumeAll+0xce>
 bc4:	80 91 c1 06 	lds	r24, 0x06C1	; 0x8006c1 <uxCurrentNumberOfTasks>
 bc8:	81 11       	cpse	r24, r1
 bca:	32 c0       	rjmp	.+100    	; 0xc30 <xTaskResumeAll+0x8c>
 bcc:	55 c0       	rjmp	.+170    	; 0xc78 <xTaskResumeAll+0xd4>
 bce:	e0 91 8c 06 	lds	r30, 0x068C	; 0x80068c <xPendingReadyList+0x5>
 bd2:	f0 91 8d 06 	lds	r31, 0x068D	; 0x80068d <xPendingReadyList+0x6>
 bd6:	c6 81       	ldd	r28, Z+6	; 0x06
 bd8:	d7 81       	ldd	r29, Z+7	; 0x07
 bda:	ce 01       	movw	r24, r28
 bdc:	0c 96       	adiw	r24, 0x0c	; 12
 bde:	0e 94 4c 0e 	call	0x1c98	; 0x1c98 <uxListRemove>
 be2:	8e 01       	movw	r16, r28
 be4:	0e 5f       	subi	r16, 0xFE	; 254
 be6:	1f 4f       	sbci	r17, 0xFF	; 255
 be8:	c8 01       	movw	r24, r16
 bea:	0e 94 4c 0e 	call	0x1c98	; 0x1c98 <uxListRemove>
 bee:	8e 89       	ldd	r24, Y+22	; 0x16
 bf0:	90 91 c0 06 	lds	r25, 0x06C0	; 0x8006c0 <uxTopReadyPriority>
 bf4:	98 17       	cp	r25, r24
 bf6:	10 f4       	brcc	.+4      	; 0xbfc <xTaskResumeAll+0x58>
 bf8:	80 93 c0 06 	sts	0x06C0, r24	; 0x8006c0 <uxTopReadyPriority>
 bfc:	90 e0       	ldi	r25, 0x00	; 0
 bfe:	9c 01       	movw	r18, r24
 c00:	22 0f       	add	r18, r18
 c02:	33 1f       	adc	r19, r19
 c04:	22 0f       	add	r18, r18
 c06:	33 1f       	adc	r19, r19
 c08:	22 0f       	add	r18, r18
 c0a:	33 1f       	adc	r19, r19
 c0c:	82 0f       	add	r24, r18
 c0e:	93 1f       	adc	r25, r19
 c10:	b8 01       	movw	r22, r16
 c12:	86 5a       	subi	r24, 0xA6	; 166
 c14:	99 4f       	sbci	r25, 0xF9	; 249
 c16:	0e 94 21 0f 	call	0x1e42	; 0x1e42 <vListInsertEnd>
 c1a:	9e 89       	ldd	r25, Y+22	; 0x16
 c1c:	e0 91 b0 06 	lds	r30, 0x06B0	; 0x8006b0 <pxCurrentTCB>
 c20:	f0 91 b1 06 	lds	r31, 0x06B1	; 0x8006b1 <pxCurrentTCB+0x1>
 c24:	86 89       	ldd	r24, Z+22	; 0x16
 c26:	98 17       	cp	r25, r24
 c28:	18 f0       	brcs	.+6      	; 0xc30 <xTaskResumeAll+0x8c>
 c2a:	81 e0       	ldi	r24, 0x01	; 1
 c2c:	80 93 bd 06 	sts	0x06BD, r24	; 0x8006bd <xYieldPending>
 c30:	80 91 87 06 	lds	r24, 0x0687	; 0x800687 <xPendingReadyList>
 c34:	81 11       	cpse	r24, r1
 c36:	cb cf       	rjmp	.-106    	; 0xbce <xTaskResumeAll+0x2a>
 c38:	80 91 be 06 	lds	r24, 0x06BE	; 0x8006be <uxPendedTicks>
 c3c:	81 11       	cpse	r24, r1
 c3e:	0d c0       	rjmp	.+26     	; 0xc5a <xTaskResumeAll+0xb6>
 c40:	10 c0       	rjmp	.+32     	; 0xc62 <xTaskResumeAll+0xbe>
 c42:	0e 94 04 02 	call	0x408	; 0x408 <xTaskIncrementTick>
 c46:	88 23       	and	r24, r24
 c48:	19 f0       	breq	.+6      	; 0xc50 <xTaskResumeAll+0xac>
 c4a:	81 e0       	ldi	r24, 0x01	; 1
 c4c:	80 93 bd 06 	sts	0x06BD, r24	; 0x8006bd <xYieldPending>
 c50:	80 91 be 06 	lds	r24, 0x06BE	; 0x8006be <uxPendedTicks>
 c54:	81 50       	subi	r24, 0x01	; 1
 c56:	80 93 be 06 	sts	0x06BE, r24	; 0x8006be <uxPendedTicks>
 c5a:	80 91 be 06 	lds	r24, 0x06BE	; 0x8006be <uxPendedTicks>
 c5e:	81 11       	cpse	r24, r1
 c60:	f0 cf       	rjmp	.-32     	; 0xc42 <xTaskResumeAll+0x9e>
 c62:	80 91 bd 06 	lds	r24, 0x06BD	; 0x8006bd <xYieldPending>
 c66:	81 30       	cpi	r24, 0x01	; 1
 c68:	31 f4       	brne	.+12     	; 0xc76 <xTaskResumeAll+0xd2>
 c6a:	0e 94 93 08 	call	0x1126	; 0x1126 <vPortYield>
 c6e:	81 e0       	ldi	r24, 0x01	; 1
 c70:	03 c0       	rjmp	.+6      	; 0xc78 <xTaskResumeAll+0xd4>
 c72:	80 e0       	ldi	r24, 0x00	; 0
 c74:	01 c0       	rjmp	.+2      	; 0xc78 <xTaskResumeAll+0xd4>
 c76:	80 e0       	ldi	r24, 0x00	; 0
 c78:	0f 90       	pop	r0
 c7a:	0f be       	out	0x3f, r0	; 63
 c7c:	df 91       	pop	r29
 c7e:	cf 91       	pop	r28
 c80:	1f 91       	pop	r17
 c82:	0f 91       	pop	r16
 c84:	08 95       	ret

Disassembly of section .text.vTaskDelay:

00001d76 <vTaskDelay>:
    1d76:	cf 93       	push	r28
    1d78:	df 93       	push	r29
    1d7a:	ec 01       	movw	r28, r24
    1d7c:	89 2b       	or	r24, r25
    1d7e:	a9 f0       	breq	.+42     	; 0x1daa <vTaskDelay+0x34>
    1d80:	0e 94 43 11 	call	0x2286	; 0x2286 <vTaskSuspendAll>
    1d84:	80 91 aa 06 	lds	r24, 0x06AA	; 0x8006aa <xTickCount>
    1d88:	90 91 ab 06 	lds	r25, 0x06AB	; 0x8006ab <xTickCount+0x1>
    1d8c:	c8 0f       	add	r28, r24
    1d8e:	d9 1f       	adc	r29, r25
    1d90:	80 91 b0 06 	lds	r24, 0x06B0	; 0x8006b0 <pxCurrentTCB>
    1d94:	90 91 b1 06 	lds	r25, 0x06B1	; 0x8006b1 <pxCurrentTCB+0x1>
    1d98:	02 96       	adiw	r24, 0x02	; 2
    1d9a:	0e 94 4c 0e 	call	0x1c98	; 0x1c98 <uxListRemove>
    1d9e:	ce 01       	movw	r24, r28
    1da0:	0e 94 8c 0b 	call	0x1718	; 0x1718 <prvAddCurrentTaskToDelayedList>
    1da4:	0e 94 d2 05 	call	0xba4	; 0xba4 <xTaskResumeAll>
    1da8:	01 c0       	rjmp	.+2      	; 0x1dac <vTaskDelay+0x36>
    1daa:	80 e0       	ldi	r24, 0x00	; 0
    1dac:	81 11       	cpse	r24, r1
    1dae:	02 c0       	rjmp	.+4      	; 0x1db4 <vTaskDelay+0x3e>
    1db0:	0e 94 93 08 	call	0x1126	; 0x1126 <vPortYield>
    1db4:	df 91       	pop	r29
    1db6:	cf 91       	pop	r28
    1db8:	08 95       	ret

Disassembly of section .text.prvCheckTasksWaitingTermination:

00001af4 <prvCheckTasksWaitingTermination>:
    1af4:	cf 93       	push	r28
    1af6:	df 93       	push	r29
    1af8:	24 c0       	rjmp	.+72     	; 0x1b42 <prvCheckTasksWaitingTermination+0x4e>
    1afa:	0e 94 43 11 	call	0x2286	; 0x2286 <vTaskSuspendAll>
    1afe:	c0 91 7e 06 	lds	r28, 0x067E	; 0x80067e <xTasksWaitingTermination>
    1b02:	0e 94 d2 05 	call	0xba4	; 0xba4 <xTaskResumeAll>
    1b06:	cc 23       	and	r28, r28
    1b08:	e1 f0       	breq	.+56     	; 0x1b42 <prvCheckTasksWaitingTermination+0x4e>
    1b0a:	0f b6       	in	r0, 0x3f	; 63
    1b0c:	f8 94       	cli
    1b0e:	0f 92       	push	r0
    1b10:	e0 91 83 06 	lds	r30, 0x0683	; 0x800683 <xTasksWaitingTermination+0x5>
    1b14:	f0 91 84 06 	lds	r31, 0x0684	; 0x800684 <xTasksWaitingTermination+0x6>
    1b18:	c6 81       	ldd	r28, Z+6	; 0x06
    1b1a:	d7 81       	ldd	r29, Z+7	; 0x07
    1b1c:	ce 01       	movw	r24, r28
    1b1e:	02 96       	adiw	r24, 0x02	; 2
    1b20:	0e 94 4c 0e 	call	0x1c98	; 0x1c98 <uxListRemove>
    1b24:	80 91 c1 06 	lds	r24, 0x06C1	; 0x8006c1 <uxCurrentNumberOfTasks>
    1b28:	81 50       	subi	r24, 0x01	; 1
    1b2a:	80 93 c1 06 	sts	0x06C1, r24	; 0x8006c1 <uxCurrentNumberOfTasks>
    1b2e:	80 91 c2 06 	lds	r24, 0x06C2	; 0x8006c2 <uxTasksDeleted>
    1b32:	81 50       	subi	r24, 0x01	; 1
    1b34:	80 93 c2 06 	sts	0x06C2, r24	; 0x8006c2 <uxTasksDeleted>
    1b38:	0f 90       	pop	r0
    1b3a:	0f be       	out	0x3f, r0	; 63
    1b3c:	ce 01       	movw	r24, r28
    1b3e:	0e 94 a4 10 	call	0x2148	; 0x2148 <prvDeleteTCB>
    1b42:	80 91 c2 06 	lds	r24, 0x06C2	; 0x8006c2 <uxTasksDeleted>
    1b46:	81 11       	cpse	r24, r1
    1b48:	d8 cf       	rjmp	.-80     	; 0x1afa <prvCheckTasksWaitingTermination+0x6>
    1b4a:	df 91       	pop	r29
    1b4c:	cf 91       	pop	r28
    1b4e:	08 95       	ret

Disassembly of section .text.prvIdleTask:

000021e6 <prvIdleTask>:
    21e6:	0e 94 7a 0d 	call	0x1af4	; 0x1af4 <prvCheckTasksWaitingTermination>
    21ea:	80 91 5a 06 	lds	r24, 0x065A	; 0x80065a <pxReadyTasksLists>
    21ee:	82 30       	cpi	r24, 0x02	; 2
    21f0:	d0 f3       	brcs	.-12     	; 0x21e6 <prvIdleTask>
    21f2:	0e 94 93 08 	call	0x1126	; 0x1126 <vPortYield>
    21f6:	f7 cf       	rjmp	.-18     	; 0x21e6 <prvIdleTask>

Disassembly of section .text.vTaskSwitchContext:

0000106e <vTaskSwitchContext>:
    106e:	80 91 ba 06 	lds	r24, 0x06BA	; 0x8006ba <uxSchedulerSuspended>
    1072:	88 23       	and	r24, r24
    1074:	21 f0       	breq	.+8      	; 0x107e <vTaskSwitchContext+0x10>
    1076:	81 e0       	ldi	r24, 0x01	; 1
    1078:	80 93 bd 06 	sts	0x06BD, r24	; 0x8006bd <xYieldPending>
    107c:	08 95       	ret
    107e:	10 92 bd 06 	sts	0x06BD, r1	; 0x8006bd <xYieldPending>
    1082:	05 c0       	rjmp	.+10     	; 0x108e <vTaskSwitchContext+0x20>
    1084:	80 91 c0 06 	lds	r24, 0x06C0	; 0x8006c0 <uxTopReadyPriority>
    1088:	81 50       	subi	r24, 0x01	; 1
    108a:	80 93 c0 06 	sts	0x06C0, r24	; 0x8006c0 <uxTopReadyPriority>
    108e:	80 91 c0 06 	lds	r24, 0x06C0	; 0x8006c0 <uxTopReadyPriority>
    1092:	90 e0       	ldi	r25, 0x00	; 0
    1094:	fc 01       	movw	r30, r24
    1096:	ee 0f       	add	r30, r30
    1098:	ff 1f       	adc	r31, r31
    109a:	ee 0f       	add	r30, r30
    109c:	ff 1f       	adc	r31, r31
    109e:	ee 0f       	add	r30, r30
    10a0:	ff 1f       	adc	r31, r31
    10a2:	8e 0f       	add	r24, r30
    10a4:	9f 1f       	adc	r25, r31
    10a6:	fc 01       	movw	r30, r24
    10a8:	e6 5a       	subi	r30, 0xA6	; 166
    10aa:	f9 4f       	sbci	r31, 0xF9	; 249
    10ac:	80 81       	ld	r24, Z
    10ae:	88 23       	and	r24, r24
    10b0:	49 f3       	breq	.-46     	; 0x1084 <vTaskSwitchContext+0x16>
    10b2:	80 91 c0 06 	lds	r24, 0x06C0	; 0x8006c0 <uxTopReadyPriority>
    10b6:	90 e0       	ldi	r25, 0x00	; 0
    10b8:	9c 01       	movw	r18, r24
    10ba:	22 0f       	add	r18, r18
    10bc:	33 1f       	adc	r19, r19
    10be:	22 0f       	add	r18, r18
    10c0:	33 1f       	adc	r19, r19
    10c2:	22 0f       	add	r18, r18
    10c4:	33 1f       	adc	r19, r19
    10c6:	28 0f       	add	r18, r24
    10c8:	39 1f       	adc	r19, r25
    10ca:	d9 01       	movw	r26, r18
    10cc:	a6 5a       	subi	r26, 0xA6	; 166
    10ce:	b9 4f       	sbci	r27, 0xF9	; 249
    10d0:	11 96       	adiw	r26, 0x01	; 1
    10d2:	ed 91       	ld	r30, X+
    10d4:	fc 91       	ld	r31, X
    10d6:	12 97       	sbiw	r26, 0x02	; 2
    10d8:	02 80       	ldd	r0, Z+2	; 0x02
    10da:	f3 81       	ldd	r31, Z+3	; 0x03
    10dc:	e0 2d       	mov	r30, r0
    10de:	12 96       	adiw	r26, 0x02	; 2
    10e0:	fc 93       	st	X, r31
    10e2:	ee 93       	st	-X, r30
    10e4:	11 97       	sbiw	r26, 0x01	; 1
    10e6:	23 5a       	subi	r18, 0xA3	; 163
    10e8:	39 4f       	sbci	r19, 0xF9	; 249
    10ea:	e2 17       	cp	r30, r18
    10ec:	f3 07       	cpc	r31, r19
    10ee:	29 f4       	brne	.+10     	; 0x10fa <vTaskSwitchContext+0x8c>
    10f0:	22 81       	ldd	r18, Z+2	; 0x02
    10f2:	33 81       	ldd	r19, Z+3	; 0x03
    10f4:	fd 01       	movw	r30, r26
    10f6:	32 83       	std	Z+2, r19	; 0x02
    10f8:	21 83       	std	Z+1, r18	; 0x01
    10fa:	fc 01       	movw	r30, r24
    10fc:	ee 0f       	add	r30, r30
    10fe:	ff 1f       	adc	r31, r31
    1100:	ee 0f       	add	r30, r30
    1102:	ff 1f       	adc	r31, r31
    1104:	ee 0f       	add	r30, r30
    1106:	ff 1f       	adc	r31, r31
    1108:	8e 0f       	add	r24, r30
    110a:	9f 1f       	adc	r25, r31
    110c:	fc 01       	movw	r30, r24
    110e:	e6 5a       	subi	r30, 0xA6	; 166
    1110:	f9 4f       	sbci	r31, 0xF9	; 249
    1112:	01 80       	ldd	r0, Z+1	; 0x01
    1114:	f2 81       	ldd	r31, Z+2	; 0x02
    1116:	e0 2d       	mov	r30, r0
    1118:	86 81       	ldd	r24, Z+6	; 0x06
    111a:	97 81       	ldd	r25, Z+7	; 0x07
    111c:	90 93 b1 06 	sts	0x06B1, r25	; 0x8006b1 <pxCurrentTCB+0x1>
    1120:	80 93 b0 06 	sts	0x06B0, r24	; 0x8006b0 <pxCurrentTCB>
    1124:	08 95       	ret

Disassembly of section .text.vTaskPlaceOnEventList:

00001ec2 <vTaskPlaceOnEventList>:
    1ec2:	cf 93       	push	r28
    1ec4:	df 93       	push	r29
    1ec6:	eb 01       	movw	r28, r22
    1ec8:	60 91 b0 06 	lds	r22, 0x06B0	; 0x8006b0 <pxCurrentTCB>
    1ecc:	70 91 b1 06 	lds	r23, 0x06B1	; 0x8006b1 <pxCurrentTCB+0x1>
    1ed0:	64 5f       	subi	r22, 0xF4	; 244
    1ed2:	7f 4f       	sbci	r23, 0xFF	; 255
    1ed4:	0e 94 5d 0c 	call	0x18ba	; 0x18ba <vListInsert>
    1ed8:	80 91 b0 06 	lds	r24, 0x06B0	; 0x8006b0 <pxCurrentTCB>
    1edc:	90 91 b1 06 	lds	r25, 0x06B1	; 0x8006b1 <pxCurrentTCB+0x1>
    1ee0:	02 96       	adiw	r24, 0x02	; 2
    1ee2:	0e 94 4c 0e 	call	0x1c98	; 0x1c98 <uxListRemove>
    1ee6:	80 91 aa 06 	lds	r24, 0x06AA	; 0x8006aa <xTickCount>
    1eea:	90 91 ab 06 	lds	r25, 0x06AB	; 0x8006ab <xTickCount+0x1>
    1eee:	8c 0f       	add	r24, r28
    1ef0:	9d 1f       	adc	r25, r29
    1ef2:	0e 94 8c 0b 	call	0x1718	; 0x1718 <prvAddCurrentTaskToDelayedList>
    1ef6:	df 91       	pop	r29
    1ef8:	cf 91       	pop	r28
    1efa:	08 95       	ret

Disassembly of section .text.xTaskRemoveFromEventList:

00001278 <xTaskRemoveFromEventList>:
    1278:	0f 93       	push	r16
    127a:	1f 93       	push	r17
    127c:	cf 93       	push	r28
    127e:	df 93       	push	r29
    1280:	a8 2f       	mov	r26, r24
    1282:	cb 01       	movw	r24, r22
    1284:	05 96       	adiw	r24, 0x05	; 5
    1286:	a1 1d       	adc	r26, r1
    1288:	fc 01       	movw	r30, r24
    128a:	5a 2f       	mov	r21, r26
    128c:	0e 94 0d 11 	call	0x221a	; 0x221a <__xload_2>
    1290:	fb 01       	movw	r30, r22
    1292:	c6 81       	ldd	r28, Z+6	; 0x06
    1294:	d7 81       	ldd	r29, Z+7	; 0x07
    1296:	8e 01       	movw	r16, r28
    1298:	04 5f       	subi	r16, 0xF4	; 244
    129a:	1f 4f       	sbci	r17, 0xFF	; 255
    129c:	c8 01       	movw	r24, r16
    129e:	0e 94 4c 0e 	call	0x1c98	; 0x1c98 <uxListRemove>
    12a2:	80 91 ba 06 	lds	r24, 0x06BA	; 0x8006ba <uxSchedulerSuspended>
    12a6:	81 11       	cpse	r24, r1
    12a8:	1c c0       	rjmp	.+56     	; 0x12e2 <xTaskRemoveFromEventList+0x6a>
    12aa:	0a 50       	subi	r16, 0x0A	; 10
    12ac:	11 09       	sbc	r17, r1
    12ae:	c8 01       	movw	r24, r16
    12b0:	0e 94 4c 0e 	call	0x1c98	; 0x1c98 <uxListRemove>
    12b4:	8e 89       	ldd	r24, Y+22	; 0x16
    12b6:	90 91 c0 06 	lds	r25, 0x06C0	; 0x8006c0 <uxTopReadyPriority>
    12ba:	98 17       	cp	r25, r24
    12bc:	10 f4       	brcc	.+4      	; 0x12c2 <xTaskRemoveFromEventList+0x4a>
    12be:	80 93 c0 06 	sts	0x06C0, r24	; 0x8006c0 <uxTopReadyPriority>
    12c2:	90 e0       	ldi	r25, 0x00	; 0
    12c4:	9c 01       	movw	r18, r24
    12c6:	22 0f       	add	r18, r18
    12c8:	33 1f       	adc	r19, r19
    12ca:	22 0f       	add	r18, r18
    12cc:	33 1f       	adc	r19, r19
    12ce:	22 0f       	add	r18, r18
    12d0:	33 1f       	adc	r19, r19
    12d2:	82 0f       	add	r24, r18
    12d4:	93 1f       	adc	r25, r19
    12d6:	b8 01       	movw	r22, r16
    12d8:	86 5a       	subi	r24, 0xA6	; 166
    12da:	99 4f       	sbci	r25, 0xF9	; 249
    12dc:	0e 94 21 0f 	call	0x1e42	; 0x1e42 <vListInsertEnd>
    12e0:	05 c0       	rjmp	.+10     	; 0x12ec <xTaskRemoveFromEventList+0x74>
    12e2:	b8 01       	movw	r22, r16
    12e4:	87 e8       	ldi	r24, 0x87	; 135
    12e6:	96 e0       	ldi	r25, 0x06	; 6
    12e8:	0e 94 21 0f 	call	0x1e42	; 0x1e42 <vListInsertEnd>
    12ec:	9e 89       	ldd	r25, Y+22	; 0x16
    12ee:	e0 91 b0 06 	lds	r30, 0x06B0	; 0x8006b0 <pxCurrentTCB>
    12f2:	f0 91 b1 06 	lds	r31, 0x06B1	; 0x8006b1 <pxCurrentTCB+0x1>
    12f6:	86 89       	ldd	r24, Z+22	; 0x16
    12f8:	89 17       	cp	r24, r25
    12fa:	20 f4       	brcc	.+8      	; 0x1304 <xTaskRemoveFromEventList+0x8c>
    12fc:	81 e0       	ldi	r24, 0x01	; 1
    12fe:	80 93 bd 06 	sts	0x06BD, r24	; 0x8006bd <xYieldPending>
    1302:	01 c0       	rjmp	.+2      	; 0x1306 <xTaskRemoveFromEventList+0x8e>
    1304:	80 e0       	ldi	r24, 0x00	; 0
    1306:	df 91       	pop	r29
    1308:	cf 91       	pop	r28
    130a:	1f 91       	pop	r17
    130c:	0f 91       	pop	r16
    130e:	08 95       	ret

Disassembly of section .text.vTaskSetTimeOutState:

000021a8 <vTaskSetTimeOutState>:
    21a8:	20 91 bc 06 	lds	r18, 0x06BC	; 0x8006bc <xNumOfOverflows>
    21ac:	fc 01       	movw	r30, r24
    21ae:	20 83       	st	Z, r18
    21b0:	20 91 aa 06 	lds	r18, 0x06AA	; 0x8006aa <xTickCount>
    21b4:	30 91 ab 06 	lds	r19, 0x06AB	; 0x8006ab <xTickCount+0x1>
    21b8:	32 83       	std	Z+2, r19	; 0x02
    21ba:	21 83       	std	Z+1, r18	; 0x01
    21bc:	08 95       	ret

Disassembly of section .text.xTaskCheckForTimeOut:

00001856 <xTaskCheckForTimeOut>:
    1856:	cf 93       	push	r28
    1858:	df 93       	push	r29
    185a:	fc 01       	movw	r30, r24
    185c:	0f b6       	in	r0, 0x3f	; 63
    185e:	f8 94       	cli
    1860:	0f 92       	push	r0
    1862:	40 91 aa 06 	lds	r20, 0x06AA	; 0x8006aa <xTickCount>
    1866:	50 91 ab 06 	lds	r21, 0x06AB	; 0x8006ab <xTickCount+0x1>
    186a:	90 81       	ld	r25, Z
    186c:	80 91 bc 06 	lds	r24, 0x06BC	; 0x8006bc <xNumOfOverflows>
    1870:	98 17       	cp	r25, r24
    1872:	29 f0       	breq	.+10     	; 0x187e <xTaskCheckForTimeOut+0x28>
    1874:	81 81       	ldd	r24, Z+1	; 0x01
    1876:	92 81       	ldd	r25, Z+2	; 0x02
    1878:	48 17       	cp	r20, r24
    187a:	59 07       	cpc	r21, r25
    187c:	b0 f4       	brcc	.+44     	; 0x18aa <xTaskCheckForTimeOut+0x54>
    187e:	21 81       	ldd	r18, Z+1	; 0x01
    1880:	32 81       	ldd	r19, Z+2	; 0x02
    1882:	ca 01       	movw	r24, r20
    1884:	82 1b       	sub	r24, r18
    1886:	93 0b       	sbc	r25, r19
    1888:	eb 01       	movw	r28, r22
    188a:	a8 81       	ld	r26, Y
    188c:	b9 81       	ldd	r27, Y+1	; 0x01
    188e:	8a 17       	cp	r24, r26
    1890:	9b 07       	cpc	r25, r27
    1892:	68 f4       	brcc	.+26     	; 0x18ae <xTaskCheckForTimeOut+0x58>
    1894:	cf 01       	movw	r24, r30
    1896:	24 1b       	sub	r18, r20
    1898:	35 0b       	sbc	r19, r21
    189a:	2a 0f       	add	r18, r26
    189c:	3b 1f       	adc	r19, r27
    189e:	39 83       	std	Y+1, r19	; 0x01
    18a0:	28 83       	st	Y, r18
    18a2:	0e 94 d4 10 	call	0x21a8	; 0x21a8 <vTaskSetTimeOutState>
    18a6:	80 e0       	ldi	r24, 0x00	; 0
    18a8:	03 c0       	rjmp	.+6      	; 0x18b0 <xTaskCheckForTimeOut+0x5a>
    18aa:	81 e0       	ldi	r24, 0x01	; 1
    18ac:	01 c0       	rjmp	.+2      	; 0x18b0 <xTaskCheckForTimeOut+0x5a>
    18ae:	81 e0       	ldi	r24, 0x01	; 1
    18b0:	0f 90       	pop	r0
    18b2:	0f be       	out	0x3f, r0	; 63
    18b4:	df 91       	pop	r29
    18b6:	cf 91       	pop	r28
    18b8:	08 95       	ret

Disassembly of section .text.vTaskMissedYield:

000022d0 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    22d0:	81 e0       	ldi	r24, 0x01	; 1
    22d2:	80 93 bd 06 	sts	0x06BD, r24	; 0x8006bd <xYieldPending>
    22d6:	08 95       	ret

Disassembly of section .text.vTaskPriorityInherit:

00000e32 <vTaskPriorityInherit>:
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
	xSchedulerRunning = pdFALSE;
	vPortEndScheduler();
 e32:	0f 93       	push	r16
 e34:	1f 93       	push	r17
 e36:	cf 93       	push	r28
 e38:	df 93       	push	r29
 e3a:	fc 01       	movw	r30, r24
 e3c:	89 2b       	or	r24, r25
 e3e:	09 f4       	brne	.+2      	; 0xe42 <vTaskPriorityInherit+0x10>
 e40:	55 c0       	rjmp	.+170    	; 0xeec <vTaskPriorityInherit+0xba>
 e42:	26 89       	ldd	r18, Z+22	; 0x16
 e44:	a0 91 b0 06 	lds	r26, 0x06B0	; 0x8006b0 <pxCurrentTCB>
 e48:	b0 91 b1 06 	lds	r27, 0x06B1	; 0x8006b1 <pxCurrentTCB+0x1>
 e4c:	56 96       	adiw	r26, 0x16	; 22
 e4e:	8c 91       	ld	r24, X
 e50:	28 17       	cp	r18, r24
 e52:	08 f0       	brcs	.+2      	; 0xe56 <vTaskPriorityInherit+0x24>
 e54:	4b c0       	rjmp	.+150    	; 0xeec <vTaskPriorityInherit+0xba>
 e56:	84 85       	ldd	r24, Z+12	; 0x0c
 e58:	95 85       	ldd	r25, Z+13	; 0x0d
 e5a:	99 23       	and	r25, r25
 e5c:	64 f0       	brlt	.+24     	; 0xe76 <vTaskPriorityInherit+0x44>
 e5e:	a0 91 b0 06 	lds	r26, 0x06B0	; 0x8006b0 <pxCurrentTCB>
 e62:	b0 91 b1 06 	lds	r27, 0x06B1	; 0x8006b1 <pxCurrentTCB+0x1>
 e66:	56 96       	adiw	r26, 0x16	; 22
 e68:	3c 91       	ld	r19, X
 e6a:	84 e0       	ldi	r24, 0x04	; 4
 e6c:	90 e0       	ldi	r25, 0x00	; 0
 e6e:	83 1b       	sub	r24, r19
 e70:	91 09       	sbc	r25, r1
 e72:	95 87       	std	Z+13, r25	; 0x0d
 e74:	84 87       	std	Z+12, r24	; 0x0c
 e76:	82 85       	ldd	r24, Z+10	; 0x0a
 e78:	93 85       	ldd	r25, Z+11	; 0x0b
 e7a:	30 e0       	ldi	r19, 0x00	; 0
 e7c:	a9 01       	movw	r20, r18
 e7e:	44 0f       	add	r20, r20
 e80:	55 1f       	adc	r21, r21
 e82:	44 0f       	add	r20, r20
 e84:	55 1f       	adc	r21, r21
 e86:	44 0f       	add	r20, r20
 e88:	55 1f       	adc	r21, r21
 e8a:	24 0f       	add	r18, r20
 e8c:	35 1f       	adc	r19, r21
 e8e:	26 5a       	subi	r18, 0xA6	; 166
 e90:	39 4f       	sbci	r19, 0xF9	; 249
 e92:	82 17       	cp	r24, r18
 e94:	93 07       	cpc	r25, r19
 e96:	19 f5       	brne	.+70     	; 0xede <vTaskPriorityInherit+0xac>
 e98:	8f 01       	movw	r16, r30
 e9a:	ef 01       	movw	r28, r30
 e9c:	22 96       	adiw	r28, 0x02	; 2
 e9e:	ce 01       	movw	r24, r28
 ea0:	0e 94 4c 0e 	call	0x1c98	; 0x1c98 <uxListRemove>
 ea4:	e0 91 b0 06 	lds	r30, 0x06B0	; 0x8006b0 <pxCurrentTCB>
 ea8:	f0 91 b1 06 	lds	r31, 0x06B1	; 0x8006b1 <pxCurrentTCB+0x1>
 eac:	86 89       	ldd	r24, Z+22	; 0x16
 eae:	f8 01       	movw	r30, r16
 eb0:	86 8b       	std	Z+22, r24	; 0x16
 eb2:	90 91 c0 06 	lds	r25, 0x06C0	; 0x8006c0 <uxTopReadyPriority>
 eb6:	98 17       	cp	r25, r24
 eb8:	10 f4       	brcc	.+4      	; 0xebe <vTaskPriorityInherit+0x8c>
 eba:	80 93 c0 06 	sts	0x06C0, r24	; 0x8006c0 <uxTopReadyPriority>
 ebe:	90 e0       	ldi	r25, 0x00	; 0
 ec0:	9c 01       	movw	r18, r24
 ec2:	22 0f       	add	r18, r18
 ec4:	33 1f       	adc	r19, r19
 ec6:	22 0f       	add	r18, r18
 ec8:	33 1f       	adc	r19, r19
 eca:	22 0f       	add	r18, r18
 ecc:	33 1f       	adc	r19, r19
 ece:	82 0f       	add	r24, r18
 ed0:	93 1f       	adc	r25, r19
 ed2:	be 01       	movw	r22, r28
 ed4:	86 5a       	subi	r24, 0xA6	; 166
 ed6:	99 4f       	sbci	r25, 0xF9	; 249
 ed8:	0e 94 21 0f 	call	0x1e42	; 0x1e42 <vListInsertEnd>
 edc:	07 c0       	rjmp	.+14     	; 0xeec <vTaskPriorityInherit+0xba>
 ede:	a0 91 b0 06 	lds	r26, 0x06B0	; 0x8006b0 <pxCurrentTCB>
 ee2:	b0 91 b1 06 	lds	r27, 0x06B1	; 0x8006b1 <pxCurrentTCB+0x1>
 ee6:	56 96       	adiw	r26, 0x16	; 22
 ee8:	8c 91       	ld	r24, X
 eea:	86 8b       	std	Z+22, r24	; 0x16
 eec:	df 91       	pop	r29
 eee:	cf 91       	pop	r28
 ef0:	1f 91       	pop	r17
 ef2:	0f 91       	pop	r16
 ef4:	08 95       	ret

Disassembly of section .text.xTaskPriorityDisinherit:

000014ba <xTaskPriorityDisinherit>:
    14ba:	0f 93       	push	r16
    14bc:	1f 93       	push	r17
    14be:	cf 93       	push	r28
    14c0:	df 93       	push	r29
    14c2:	fc 01       	movw	r30, r24
    14c4:	89 2b       	or	r24, r25
    14c6:	79 f1       	breq	.+94     	; 0x1526 <xTaskPriorityDisinherit+0x6c>
    14c8:	86 a5       	ldd	r24, Z+46	; 0x2e
    14ca:	81 50       	subi	r24, 0x01	; 1
    14cc:	86 a7       	std	Z+46, r24	; 0x2e
    14ce:	26 89       	ldd	r18, Z+22	; 0x16
    14d0:	95 a5       	ldd	r25, Z+45	; 0x2d
    14d2:	29 17       	cp	r18, r25
    14d4:	51 f1       	breq	.+84     	; 0x152a <xTaskPriorityDisinherit+0x70>
    14d6:	81 11       	cpse	r24, r1
    14d8:	2a c0       	rjmp	.+84     	; 0x152e <xTaskPriorityDisinherit+0x74>
    14da:	ef 01       	movw	r28, r30
    14dc:	8f 01       	movw	r16, r30
    14de:	0e 5f       	subi	r16, 0xFE	; 254
    14e0:	1f 4f       	sbci	r17, 0xFF	; 255
    14e2:	c8 01       	movw	r24, r16
    14e4:	0e 94 4c 0e 	call	0x1c98	; 0x1c98 <uxListRemove>
    14e8:	8d a5       	ldd	r24, Y+45	; 0x2d
    14ea:	8e 8b       	std	Y+22, r24	; 0x16
    14ec:	24 e0       	ldi	r18, 0x04	; 4
    14ee:	30 e0       	ldi	r19, 0x00	; 0
    14f0:	28 1b       	sub	r18, r24
    14f2:	31 09       	sbc	r19, r1
    14f4:	3d 87       	std	Y+13, r19	; 0x0d
    14f6:	2c 87       	std	Y+12, r18	; 0x0c
    14f8:	90 91 c0 06 	lds	r25, 0x06C0	; 0x8006c0 <uxTopReadyPriority>
    14fc:	98 17       	cp	r25, r24
    14fe:	10 f4       	brcc	.+4      	; 0x1504 <xTaskPriorityDisinherit+0x4a>
    1500:	80 93 c0 06 	sts	0x06C0, r24	; 0x8006c0 <uxTopReadyPriority>
    1504:	90 e0       	ldi	r25, 0x00	; 0
    1506:	9c 01       	movw	r18, r24
    1508:	22 0f       	add	r18, r18
    150a:	33 1f       	adc	r19, r19
    150c:	22 0f       	add	r18, r18
    150e:	33 1f       	adc	r19, r19
    1510:	22 0f       	add	r18, r18
    1512:	33 1f       	adc	r19, r19
    1514:	82 0f       	add	r24, r18
    1516:	93 1f       	adc	r25, r19
    1518:	b8 01       	movw	r22, r16
    151a:	86 5a       	subi	r24, 0xA6	; 166
    151c:	99 4f       	sbci	r25, 0xF9	; 249
    151e:	0e 94 21 0f 	call	0x1e42	; 0x1e42 <vListInsertEnd>
    1522:	81 e0       	ldi	r24, 0x01	; 1
    1524:	05 c0       	rjmp	.+10     	; 0x1530 <xTaskPriorityDisinherit+0x76>
    1526:	80 e0       	ldi	r24, 0x00	; 0
    1528:	03 c0       	rjmp	.+6      	; 0x1530 <xTaskPriorityDisinherit+0x76>
    152a:	80 e0       	ldi	r24, 0x00	; 0
    152c:	01 c0       	rjmp	.+2      	; 0x1530 <xTaskPriorityDisinherit+0x76>
    152e:	80 e0       	ldi	r24, 0x00	; 0
    1530:	df 91       	pop	r29
    1532:	cf 91       	pop	r28
    1534:	1f 91       	pop	r17
    1536:	0f 91       	pop	r16
    1538:	08 95       	ret

Disassembly of section .text.pvTaskIncrementMutexHeldCount:

0000206c <pvTaskIncrementMutexHeldCount>:
    206c:	80 91 b0 06 	lds	r24, 0x06B0	; 0x8006b0 <pxCurrentTCB>
    2070:	90 91 b1 06 	lds	r25, 0x06B1	; 0x8006b1 <pxCurrentTCB+0x1>
    2074:	89 2b       	or	r24, r25
    2076:	39 f0       	breq	.+14     	; 0x2086 <pvTaskIncrementMutexHeldCount+0x1a>
    2078:	e0 91 b0 06 	lds	r30, 0x06B0	; 0x8006b0 <pxCurrentTCB>
    207c:	f0 91 b1 06 	lds	r31, 0x06B1	; 0x8006b1 <pxCurrentTCB+0x1>
    2080:	86 a5       	ldd	r24, Z+46	; 0x2e
    2082:	8f 5f       	subi	r24, 0xFF	; 255
    2084:	86 a7       	std	Z+46, r24	; 0x2e
    2086:	80 91 b0 06 	lds	r24, 0x06B0	; 0x8006b0 <pxCurrentTCB>
    208a:	90 91 b1 06 	lds	r25, 0x06B1	; 0x8006b1 <pxCurrentTCB+0x1>
    208e:	08 95       	ret

Disassembly of section .text:

000022b4 <__cmpsf2>:
    22b4:	0e 94 97 0e 	call	0x1d2e	; 0x1d2e <__fp_cmp>
    22b8:	08 f4       	brcc	.+2      	; 0x22bc <__cmpsf2+0x8>
    22ba:	81 e0       	ldi	r24, 0x01	; 1
    22bc:	08 95       	ret

Disassembly of section .text:

00001a3a <__fixunssfsi>:
    1a3a:	0e 94 e5 0e 	call	0x1dca	; 0x1dca <__fp_splitA>
    1a3e:	88 f0       	brcs	.+34     	; 0x1a62 <__fixunssfsi+0x28>
    1a40:	9f 57       	subi	r25, 0x7F	; 127
    1a42:	98 f0       	brcs	.+38     	; 0x1a6a <__fixunssfsi+0x30>
    1a44:	b9 2f       	mov	r27, r25
    1a46:	99 27       	eor	r25, r25
    1a48:	b7 51       	subi	r27, 0x17	; 23
    1a4a:	b0 f0       	brcs	.+44     	; 0x1a78 <__fixunssfsi+0x3e>
    1a4c:	e1 f0       	breq	.+56     	; 0x1a86 <__fixunssfsi+0x4c>
    1a4e:	66 0f       	add	r22, r22
    1a50:	77 1f       	adc	r23, r23
    1a52:	88 1f       	adc	r24, r24
    1a54:	99 1f       	adc	r25, r25
    1a56:	1a f0       	brmi	.+6      	; 0x1a5e <__fixunssfsi+0x24>
    1a58:	ba 95       	dec	r27
    1a5a:	c9 f7       	brne	.-14     	; 0x1a4e <__fixunssfsi+0x14>
    1a5c:	14 c0       	rjmp	.+40     	; 0x1a86 <__fixunssfsi+0x4c>
    1a5e:	b1 30       	cpi	r27, 0x01	; 1
    1a60:	91 f0       	breq	.+36     	; 0x1a86 <__fixunssfsi+0x4c>
    1a62:	0e 94 1c 11 	call	0x2238	; 0x2238 <__fp_zero>
    1a66:	b1 e0       	ldi	r27, 0x01	; 1
    1a68:	08 95       	ret
    1a6a:	0c 94 1c 11 	jmp	0x2238	; 0x2238 <__fp_zero>
    1a6e:	67 2f       	mov	r22, r23
    1a70:	78 2f       	mov	r23, r24
    1a72:	88 27       	eor	r24, r24
    1a74:	b8 5f       	subi	r27, 0xF8	; 248
    1a76:	39 f0       	breq	.+14     	; 0x1a86 <__fixunssfsi+0x4c>
    1a78:	b9 3f       	cpi	r27, 0xF9	; 249
    1a7a:	cc f3       	brlt	.-14     	; 0x1a6e <__fixunssfsi+0x34>
    1a7c:	86 95       	lsr	r24
    1a7e:	77 95       	ror	r23
    1a80:	67 95       	ror	r22
    1a82:	b3 95       	inc	r27
    1a84:	d9 f7       	brne	.-10     	; 0x1a7c <__fixunssfsi+0x42>
    1a86:	3e f4       	brtc	.+14     	; 0x1a96 <__fixunssfsi+0x5c>
    1a88:	90 95       	com	r25
    1a8a:	80 95       	com	r24
    1a8c:	70 95       	com	r23
    1a8e:	61 95       	neg	r22
    1a90:	7f 4f       	sbci	r23, 0xFF	; 255
    1a92:	8f 4f       	sbci	r24, 0xFF	; 255
    1a94:	9f 4f       	sbci	r25, 0xFF	; 255
    1a96:	08 95       	ret

Disassembly of section .text:

000015b6 <__floatunsisf>:
    15b6:	e8 94       	clt
    15b8:	09 c0       	rjmp	.+18     	; 0x15cc <__floatsisf+0x12>

000015ba <__floatsisf>:
    15ba:	97 fb       	bst	r25, 7
    15bc:	3e f4       	brtc	.+14     	; 0x15cc <__floatsisf+0x12>
    15be:	90 95       	com	r25
    15c0:	80 95       	com	r24
    15c2:	70 95       	com	r23
    15c4:	61 95       	neg	r22
    15c6:	7f 4f       	sbci	r23, 0xFF	; 255
    15c8:	8f 4f       	sbci	r24, 0xFF	; 255
    15ca:	9f 4f       	sbci	r25, 0xFF	; 255
    15cc:	99 23       	and	r25, r25
    15ce:	a9 f0       	breq	.+42     	; 0x15fa <__floatsisf+0x40>
    15d0:	f9 2f       	mov	r31, r25
    15d2:	96 e9       	ldi	r25, 0x96	; 150
    15d4:	bb 27       	eor	r27, r27
    15d6:	93 95       	inc	r25
    15d8:	f6 95       	lsr	r31
    15da:	87 95       	ror	r24
    15dc:	77 95       	ror	r23
    15de:	67 95       	ror	r22
    15e0:	b7 95       	ror	r27
    15e2:	f1 11       	cpse	r31, r1
    15e4:	f8 cf       	rjmp	.-16     	; 0x15d6 <__floatsisf+0x1c>
    15e6:	fa f4       	brpl	.+62     	; 0x1626 <__floatsisf+0x6c>
    15e8:	bb 0f       	add	r27, r27
    15ea:	11 f4       	brne	.+4      	; 0x15f0 <__floatsisf+0x36>
    15ec:	60 ff       	sbrs	r22, 0
    15ee:	1b c0       	rjmp	.+54     	; 0x1626 <__floatsisf+0x6c>
    15f0:	6f 5f       	subi	r22, 0xFF	; 255
    15f2:	7f 4f       	sbci	r23, 0xFF	; 255
    15f4:	8f 4f       	sbci	r24, 0xFF	; 255
    15f6:	9f 4f       	sbci	r25, 0xFF	; 255
    15f8:	16 c0       	rjmp	.+44     	; 0x1626 <__floatsisf+0x6c>
    15fa:	88 23       	and	r24, r24
    15fc:	11 f0       	breq	.+4      	; 0x1602 <__floatsisf+0x48>
    15fe:	96 e9       	ldi	r25, 0x96	; 150
    1600:	11 c0       	rjmp	.+34     	; 0x1624 <__floatsisf+0x6a>
    1602:	77 23       	and	r23, r23
    1604:	21 f0       	breq	.+8      	; 0x160e <__floatsisf+0x54>
    1606:	9e e8       	ldi	r25, 0x8E	; 142
    1608:	87 2f       	mov	r24, r23
    160a:	76 2f       	mov	r23, r22
    160c:	05 c0       	rjmp	.+10     	; 0x1618 <__floatsisf+0x5e>
    160e:	66 23       	and	r22, r22
    1610:	71 f0       	breq	.+28     	; 0x162e <__floatsisf+0x74>
    1612:	96 e8       	ldi	r25, 0x86	; 134
    1614:	86 2f       	mov	r24, r22
    1616:	70 e0       	ldi	r23, 0x00	; 0
    1618:	60 e0       	ldi	r22, 0x00	; 0
    161a:	2a f0       	brmi	.+10     	; 0x1626 <__floatsisf+0x6c>
    161c:	9a 95       	dec	r25
    161e:	66 0f       	add	r22, r22
    1620:	77 1f       	adc	r23, r23
    1622:	88 1f       	adc	r24, r24
    1624:	da f7       	brpl	.-10     	; 0x161c <__floatsisf+0x62>
    1626:	88 0f       	add	r24, r24
    1628:	96 95       	lsr	r25
    162a:	87 95       	ror	r24
    162c:	97 f9       	bld	r25, 7
    162e:	08 95       	ret

Disassembly of section .text:

00001d2e <__fp_cmp>:
    1d2e:	99 0f       	add	r25, r25
    1d30:	00 08       	sbc	r0, r0
    1d32:	55 0f       	add	r21, r21
    1d34:	aa 0b       	sbc	r26, r26
    1d36:	e0 e8       	ldi	r30, 0x80	; 128
    1d38:	fe ef       	ldi	r31, 0xFE	; 254
    1d3a:	16 16       	cp	r1, r22
    1d3c:	17 06       	cpc	r1, r23
    1d3e:	e8 07       	cpc	r30, r24
    1d40:	f9 07       	cpc	r31, r25
    1d42:	c0 f0       	brcs	.+48     	; 0x1d74 <__fp_cmp+0x46>
    1d44:	12 16       	cp	r1, r18
    1d46:	13 06       	cpc	r1, r19
    1d48:	e4 07       	cpc	r30, r20
    1d4a:	f5 07       	cpc	r31, r21
    1d4c:	98 f0       	brcs	.+38     	; 0x1d74 <__fp_cmp+0x46>
    1d4e:	62 1b       	sub	r22, r18
    1d50:	73 0b       	sbc	r23, r19
    1d52:	84 0b       	sbc	r24, r20
    1d54:	95 0b       	sbc	r25, r21
    1d56:	39 f4       	brne	.+14     	; 0x1d66 <__fp_cmp+0x38>
    1d58:	0a 26       	eor	r0, r26
    1d5a:	61 f0       	breq	.+24     	; 0x1d74 <__fp_cmp+0x46>
    1d5c:	23 2b       	or	r18, r19
    1d5e:	24 2b       	or	r18, r20
    1d60:	25 2b       	or	r18, r21
    1d62:	21 f4       	brne	.+8      	; 0x1d6c <__fp_cmp+0x3e>
    1d64:	08 95       	ret
    1d66:	0a 26       	eor	r0, r26
    1d68:	09 f4       	brne	.+2      	; 0x1d6c <__fp_cmp+0x3e>
    1d6a:	a1 40       	sbci	r26, 0x01	; 1
    1d6c:	a6 95       	lsr	r26
    1d6e:	8f ef       	ldi	r24, 0xFF	; 255
    1d70:	81 1d       	adc	r24, r1
    1d72:	81 1d       	adc	r24, r1
    1d74:	08 95       	ret

Disassembly of section .text:

00001dba <__fp_split3>:
    1dba:	57 fd       	sbrc	r21, 7
    1dbc:	90 58       	subi	r25, 0x80	; 128
    1dbe:	44 0f       	add	r20, r20
    1dc0:	55 1f       	adc	r21, r21
    1dc2:	59 f0       	breq	.+22     	; 0x1dda <__fp_splitA+0x10>
    1dc4:	5f 3f       	cpi	r21, 0xFF	; 255
    1dc6:	71 f0       	breq	.+28     	; 0x1de4 <__fp_splitA+0x1a>
    1dc8:	47 95       	ror	r20

00001dca <__fp_splitA>:
    1dca:	88 0f       	add	r24, r24
    1dcc:	97 fb       	bst	r25, 7
    1dce:	99 1f       	adc	r25, r25
    1dd0:	61 f0       	breq	.+24     	; 0x1dea <__fp_splitA+0x20>
    1dd2:	9f 3f       	cpi	r25, 0xFF	; 255
    1dd4:	79 f0       	breq	.+30     	; 0x1df4 <__fp_splitA+0x2a>
    1dd6:	87 95       	ror	r24
    1dd8:	08 95       	ret
    1dda:	12 16       	cp	r1, r18
    1ddc:	13 06       	cpc	r1, r19
    1dde:	14 06       	cpc	r1, r20
    1de0:	55 1f       	adc	r21, r21
    1de2:	f2 cf       	rjmp	.-28     	; 0x1dc8 <__fp_split3+0xe>
    1de4:	46 95       	lsr	r20
    1de6:	f1 df       	rcall	.-30     	; 0x1dca <__fp_splitA>
    1de8:	08 c0       	rjmp	.+16     	; 0x1dfa <__fp_splitA+0x30>
    1dea:	16 16       	cp	r1, r22
    1dec:	17 06       	cpc	r1, r23
    1dee:	18 06       	cpc	r1, r24
    1df0:	99 1f       	adc	r25, r25
    1df2:	f1 cf       	rjmp	.-30     	; 0x1dd6 <__fp_splitA+0xc>
    1df4:	86 95       	lsr	r24
    1df6:	71 05       	cpc	r23, r1
    1df8:	61 05       	cpc	r22, r1
    1dfa:	08 94       	sec
    1dfc:	08 95       	ret

Disassembly of section .text:

00002238 <__fp_zero>:
    2238:	e8 94       	clt

0000223a <__fp_szero>:
    223a:	bb 27       	eor	r27, r27
    223c:	66 27       	eor	r22, r22
    223e:	77 27       	eor	r23, r23
    2240:	cb 01       	movw	r24, r22
    2242:	97 f9       	bld	r25, 7
    2244:	08 95       	ret

Disassembly of section .text:

000022be <__gesf2>:
    22be:	0e 94 97 0e 	call	0x1d2e	; 0x1d2e <__fp_cmp>
    22c2:	08 f4       	brcc	.+2      	; 0x22c6 <__gesf2+0x8>
    22c4:	8f ef       	ldi	r24, 0xFF	; 255
    22c6:	08 95       	ret

Disassembly of section .text:

000022d8 <__mulsf3>:
    22d8:	0e 94 af 06 	call	0xd5e	; 0xd5e <__mulsf3x>
    22dc:	0c 94 48 10 	jmp	0x2090	; 0x2090 <__fp_round>

Disassembly of section .text:

00000d5e <__mulsf3x>:
 d5e:	0f c0       	rjmp	.+30     	; 0xd7e <__mulsf3x+0x20>
 d60:	0e 94 23 11 	call	0x2246	; 0x2246 <__fp_pscA>
 d64:	38 f0       	brcs	.+14     	; 0xd74 <__mulsf3x+0x16>
 d66:	0e 94 2a 11 	call	0x2254	; 0x2254 <__fp_pscB>
 d6a:	20 f0       	brcs	.+8      	; 0xd74 <__mulsf3x+0x16>
 d6c:	95 23       	and	r25, r21
 d6e:	11 f0       	breq	.+4      	; 0xd74 <__mulsf3x+0x16>
 d70:	0c 94 49 11 	jmp	0x2292	; 0x2292 <__fp_inf>
 d74:	0c 94 73 11 	jmp	0x22e6	; 0x22e6 <__fp_nan>
 d78:	11 24       	eor	r1, r1
 d7a:	0c 94 1d 11 	jmp	0x223a	; 0x223a <__fp_szero>
 d7e:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <__fp_split3>
 d82:	70 f3       	brcs	.-36     	; 0xd60 <__mulsf3x+0x2>

00000d84 <__mulsf3_pse>:
 d84:	95 9f       	mul	r25, r21
 d86:	c1 f3       	breq	.-16     	; 0xd78 <__mulsf3x+0x1a>
 d88:	95 0f       	add	r25, r21
 d8a:	50 e0       	ldi	r21, 0x00	; 0
 d8c:	55 1f       	adc	r21, r21
 d8e:	62 9f       	mul	r22, r18
 d90:	f0 01       	movw	r30, r0
 d92:	72 9f       	mul	r23, r18
 d94:	bb 27       	eor	r27, r27
 d96:	f0 0d       	add	r31, r0
 d98:	b1 1d       	adc	r27, r1
 d9a:	63 9f       	mul	r22, r19
 d9c:	aa 27       	eor	r26, r26
 d9e:	f0 0d       	add	r31, r0
 da0:	b1 1d       	adc	r27, r1
 da2:	aa 1f       	adc	r26, r26
 da4:	64 9f       	mul	r22, r20
 da6:	66 27       	eor	r22, r22
 da8:	b0 0d       	add	r27, r0
 daa:	a1 1d       	adc	r26, r1
 dac:	66 1f       	adc	r22, r22
 dae:	82 9f       	mul	r24, r18
 db0:	22 27       	eor	r18, r18
 db2:	b0 0d       	add	r27, r0
 db4:	a1 1d       	adc	r26, r1
 db6:	62 1f       	adc	r22, r18
 db8:	73 9f       	mul	r23, r19
 dba:	b0 0d       	add	r27, r0
 dbc:	a1 1d       	adc	r26, r1
 dbe:	62 1f       	adc	r22, r18
 dc0:	83 9f       	mul	r24, r19
 dc2:	a0 0d       	add	r26, r0
 dc4:	61 1d       	adc	r22, r1
 dc6:	22 1f       	adc	r18, r18
 dc8:	74 9f       	mul	r23, r20
 dca:	33 27       	eor	r19, r19
 dcc:	a0 0d       	add	r26, r0
 dce:	61 1d       	adc	r22, r1
 dd0:	23 1f       	adc	r18, r19
 dd2:	84 9f       	mul	r24, r20
 dd4:	60 0d       	add	r22, r0
 dd6:	21 1d       	adc	r18, r1
 dd8:	82 2f       	mov	r24, r18
 dda:	76 2f       	mov	r23, r22
 ddc:	6a 2f       	mov	r22, r26
 dde:	11 24       	eor	r1, r1
 de0:	9f 57       	subi	r25, 0x7F	; 127
 de2:	50 40       	sbci	r21, 0x00	; 0
 de4:	9a f0       	brmi	.+38     	; 0xe0c <__mulsf3_pse+0x88>
 de6:	f1 f0       	breq	.+60     	; 0xe24 <__mulsf3_pse+0xa0>
 de8:	88 23       	and	r24, r24
 dea:	4a f0       	brmi	.+18     	; 0xdfe <__mulsf3_pse+0x7a>
 dec:	ee 0f       	add	r30, r30
 dee:	ff 1f       	adc	r31, r31
 df0:	bb 1f       	adc	r27, r27
 df2:	66 1f       	adc	r22, r22
 df4:	77 1f       	adc	r23, r23
 df6:	88 1f       	adc	r24, r24
 df8:	91 50       	subi	r25, 0x01	; 1
 dfa:	50 40       	sbci	r21, 0x00	; 0
 dfc:	a9 f7       	brne	.-22     	; 0xde8 <__mulsf3_pse+0x64>
 dfe:	9e 3f       	cpi	r25, 0xFE	; 254
 e00:	51 05       	cpc	r21, r1
 e02:	80 f0       	brcs	.+32     	; 0xe24 <__mulsf3_pse+0xa0>
 e04:	0c 94 49 11 	jmp	0x2292	; 0x2292 <__fp_inf>
 e08:	0c 94 1d 11 	jmp	0x223a	; 0x223a <__fp_szero>
 e0c:	5f 3f       	cpi	r21, 0xFF	; 255
 e0e:	e4 f3       	brlt	.-8      	; 0xe08 <__mulsf3_pse+0x84>
 e10:	98 3e       	cpi	r25, 0xE8	; 232
 e12:	d4 f3       	brlt	.-12     	; 0xe08 <__mulsf3_pse+0x84>
 e14:	86 95       	lsr	r24
 e16:	77 95       	ror	r23
 e18:	67 95       	ror	r22
 e1a:	b7 95       	ror	r27
 e1c:	f7 95       	ror	r31
 e1e:	e7 95       	ror	r30
 e20:	9f 5f       	subi	r25, 0xFF	; 255
 e22:	c1 f7       	brne	.-16     	; 0xe14 <__mulsf3_pse+0x90>
 e24:	fe 2b       	or	r31, r30
 e26:	88 0f       	add	r24, r24
 e28:	91 1d       	adc	r25, r1
 e2a:	96 95       	lsr	r25
 e2c:	87 95       	ror	r24
 e2e:	97 f9       	bld	r25, 7
 e30:	08 95       	ret

Disassembly of section .text:

00002292 <__fp_inf>:
    2292:	97 f9       	bld	r25, 7
    2294:	9f 67       	ori	r25, 0x7F	; 127
    2296:	80 e8       	ldi	r24, 0x80	; 128
    2298:	70 e0       	ldi	r23, 0x00	; 0
    229a:	60 e0       	ldi	r22, 0x00	; 0
    229c:	08 95       	ret

Disassembly of section .text:

000022e6 <__fp_nan>:
    22e6:	9f ef       	ldi	r25, 0xFF	; 255
    22e8:	80 ec       	ldi	r24, 0xC0	; 192
    22ea:	08 95       	ret

Disassembly of section .text:

00002246 <__fp_pscA>:
    2246:	00 24       	eor	r0, r0
    2248:	0a 94       	dec	r0
    224a:	16 16       	cp	r1, r22
    224c:	17 06       	cpc	r1, r23
    224e:	18 06       	cpc	r1, r24
    2250:	09 06       	cpc	r0, r25
    2252:	08 95       	ret

Disassembly of section .text:

00002254 <__fp_pscB>:
    2254:	00 24       	eor	r0, r0
    2256:	0a 94       	dec	r0
    2258:	12 16       	cp	r1, r18
    225a:	13 06       	cpc	r1, r19
    225c:	14 06       	cpc	r1, r20
    225e:	05 06       	cpc	r0, r21
    2260:	08 95       	ret

Disassembly of section .text:

00002090 <__fp_round>:
    2090:	09 2e       	mov	r0, r25
    2092:	03 94       	inc	r0
    2094:	00 0c       	add	r0, r0
    2096:	11 f4       	brne	.+4      	; 0x209c <__fp_round+0xc>
    2098:	88 23       	and	r24, r24
    209a:	52 f0       	brmi	.+20     	; 0x20b0 <__fp_round+0x20>
    209c:	bb 0f       	add	r27, r27
    209e:	40 f4       	brcc	.+16     	; 0x20b0 <__fp_round+0x20>
    20a0:	bf 2b       	or	r27, r31
    20a2:	11 f4       	brne	.+4      	; 0x20a8 <__fp_round+0x18>
    20a4:	60 ff       	sbrs	r22, 0
    20a6:	04 c0       	rjmp	.+8      	; 0x20b0 <__fp_round+0x20>
    20a8:	6f 5f       	subi	r22, 0xFF	; 255
    20aa:	7f 4f       	sbci	r23, 0xFF	; 255
    20ac:	8f 4f       	sbci	r24, 0xFF	; 255
    20ae:	9f 4f       	sbci	r25, 0xFF	; 255
    20b0:	08 95       	ret

Disassembly of section .text.libgcc.div:

00001dfe <__udivmodsi4>:
    1dfe:	a1 e2       	ldi	r26, 0x21	; 33
    1e00:	1a 2e       	mov	r1, r26
    1e02:	aa 1b       	sub	r26, r26
    1e04:	bb 1b       	sub	r27, r27
    1e06:	fd 01       	movw	r30, r26
    1e08:	0d c0       	rjmp	.+26     	; 0x1e24 <__udivmodsi4_ep>

00001e0a <__udivmodsi4_loop>:
    1e0a:	aa 1f       	adc	r26, r26
    1e0c:	bb 1f       	adc	r27, r27
    1e0e:	ee 1f       	adc	r30, r30
    1e10:	ff 1f       	adc	r31, r31
    1e12:	a2 17       	cp	r26, r18
    1e14:	b3 07       	cpc	r27, r19
    1e16:	e4 07       	cpc	r30, r20
    1e18:	f5 07       	cpc	r31, r21
    1e1a:	20 f0       	brcs	.+8      	; 0x1e24 <__udivmodsi4_ep>
    1e1c:	a2 1b       	sub	r26, r18
    1e1e:	b3 0b       	sbc	r27, r19
    1e20:	e4 0b       	sbc	r30, r20
    1e22:	f5 0b       	sbc	r31, r21

00001e24 <__udivmodsi4_ep>:
    1e24:	66 1f       	adc	r22, r22
    1e26:	77 1f       	adc	r23, r23
    1e28:	88 1f       	adc	r24, r24
    1e2a:	99 1f       	adc	r25, r25
    1e2c:	1a 94       	dec	r1
    1e2e:	69 f7       	brne	.-38     	; 0x1e0a <__udivmodsi4_loop>
    1e30:	60 95       	com	r22
    1e32:	70 95       	com	r23
    1e34:	80 95       	com	r24
    1e36:	90 95       	com	r25
    1e38:	9b 01       	movw	r18, r22
    1e3a:	ac 01       	movw	r20, r24
    1e3c:	bd 01       	movw	r22, r26
    1e3e:	cf 01       	movw	r24, r30
    1e40:	08 95       	ret

Disassembly of section .text.libgcc.div:

00001fcc <__divmodsi4>:
    1fcc:	05 2e       	mov	r0, r21
    1fce:	97 fb       	bst	r25, 7
    1fd0:	1e f4       	brtc	.+6      	; 0x1fd8 <__divmodsi4+0xc>
    1fd2:	00 94       	com	r0
    1fd4:	0e 94 05 11 	call	0x220a	; 0x220a <__negsi2>
    1fd8:	57 fd       	sbrc	r21, 7
    1fda:	07 d0       	rcall	.+14     	; 0x1fea <__divmodsi4_neg2>
    1fdc:	0e 94 ff 0e 	call	0x1dfe	; 0x1dfe <__udivmodsi4>
    1fe0:	07 fc       	sbrc	r0, 7
    1fe2:	03 d0       	rcall	.+6      	; 0x1fea <__divmodsi4_neg2>
    1fe4:	4e f4       	brtc	.+18     	; 0x1ff8 <__divmodsi4_exit>
    1fe6:	0c 94 05 11 	jmp	0x220a	; 0x220a <__negsi2>

00001fea <__divmodsi4_neg2>:
    1fea:	50 95       	com	r21
    1fec:	40 95       	com	r20
    1fee:	30 95       	com	r19
    1ff0:	21 95       	neg	r18
    1ff2:	3f 4f       	sbci	r19, 0xFF	; 255
    1ff4:	4f 4f       	sbci	r20, 0xFF	; 255
    1ff6:	5f 4f       	sbci	r21, 0xFF	; 255

00001ff8 <__divmodsi4_exit>:
    1ff8:	08 95       	ret

Disassembly of section .text.libgcc.div:

0000220a <__negsi2>:
    220a:	90 95       	com	r25
    220c:	80 95       	com	r24
    220e:	70 95       	com	r23
    2210:	61 95       	neg	r22
    2212:	7f 4f       	sbci	r23, 0xFF	; 255
    2214:	8f 4f       	sbci	r24, 0xFF	; 255
    2216:	9f 4f       	sbci	r25, 0xFF	; 255
    2218:	08 95       	ret

Disassembly of section .text.libgcc:

0000229e <__tablejump2__>:
    229e:	ee 0f       	add	r30, r30
    22a0:	ff 1f       	adc	r31, r31
    22a2:	05 90       	lpm	r0, Z+
    22a4:	f4 91       	lpm	r31, Z
    22a6:	e0 2d       	mov	r30, r0
    22a8:	09 94       	ijmp

Disassembly of section .text.libgcc:

0000221a <__xload_2>:
    221a:	57 fd       	sbrc	r21, 7
    221c:	03 c0       	rjmp	.+6      	; 0x2224 <__xload_2+0xa>
    221e:	65 91       	lpm	r22, Z+
    2220:	75 91       	lpm	r23, Z+
    2222:	08 95       	ret
    2224:	61 91       	ld	r22, Z+
    2226:	71 91       	ld	r23, Z+
    2228:	08 95       	ret

Disassembly of section .text.__dummy_fini:

000022f6 <_fini>:
    22f6:	08 95       	ret

Disassembly of section .text.__dummy_funcs_on_exit:

000022f8 <__funcs_on_exit>:
    22f8:	08 95       	ret

Disassembly of section .text.__dummy_simulator_exit:

000022fa <__simulator_exit>:
    22fa:	08 95       	ret

Disassembly of section .text.exit:

000021be <exit>:
    21be:	ec 01       	movw	r28, r24
    21c0:	0e 94 7c 11 	call	0x22f8	; 0x22f8 <__funcs_on_exit>
    21c4:	0e 94 7b 11 	call	0x22f6	; 0x22f6 <_fini>
    21c8:	ce 01       	movw	r24, r28
    21ca:	0e 94 7d 11 	call	0x22fa	; 0x22fa <__simulator_exit>
    21ce:	ce 01       	movw	r24, r28
    21d0:	0e 94 78 11 	call	0x22f0	; 0x22f0 <_Exit>

Disassembly of section .text.memcpy:

00001f6a <memcpy>:
    1f6a:	cf 92       	push	r12
    1f6c:	df 92       	push	r13
    1f6e:	ef 92       	push	r14
    1f70:	6a 01       	movw	r12, r20
    1f72:	e6 2e       	mov	r14, r22
    1f74:	dc 01       	movw	r26, r24
    1f76:	28 0f       	add	r18, r24
    1f78:	39 1f       	adc	r19, r25
    1f7a:	a2 17       	cp	r26, r18
    1f7c:	b3 07       	cpc	r27, r19
    1f7e:	51 f0       	breq	.+20     	; 0x1f94 <memcpy+0x2a>
    1f80:	f6 01       	movw	r30, r12
    1f82:	44 91       	lpm	r20, Z
    1f84:	e7 fc       	sbrc	r14, 7
    1f86:	40 81       	ld	r20, Z
    1f88:	4d 93       	st	X+, r20
    1f8a:	4f ef       	ldi	r20, 0xFF	; 255
    1f8c:	c4 1a       	sub	r12, r20
    1f8e:	d4 0a       	sbc	r13, r20
    1f90:	e4 0a       	sbc	r14, r20
    1f92:	f3 cf       	rjmp	.-26     	; 0x1f7a <memcpy+0x10>
    1f94:	ef 90       	pop	r14
    1f96:	df 90       	pop	r13
    1f98:	cf 90       	pop	r12
    1f9a:	08 95       	ret

Disassembly of section .text._Exit:

000022f0 <_Exit>:
    22f0:	0e 94 6f 00 	call	0xde	; 0xde <_exit>

Disassembly of section .text.avrlibc:

000021f8 <eeprom_read_byte>:
    21f8:	cb 01       	movw	r24, r22
    21fa:	e1 99       	sbic	0x1c, 1	; 28
    21fc:	fe cf       	rjmp	.-4      	; 0x21fa <eeprom_read_byte+0x2>
    21fe:	9f bb       	out	0x1f, r25	; 31
    2200:	8e bb       	out	0x1e, r24	; 30
    2202:	e0 9a       	sbi	0x1c, 0	; 28
    2204:	99 27       	eor	r25, r25
    2206:	8d b3       	in	r24, 0x1d	; 29
    2208:	08 95       	ret

Disassembly of section .text.avrlibc:

000020b2 <eeprom_update_byte>:
    20b2:	26 2f       	mov	r18, r22

000020b4 <eeprom_update_r18>:
    20b4:	e1 99       	sbic	0x1c, 1	; 28
    20b6:	fe cf       	rjmp	.-4      	; 0x20b4 <eeprom_update_r18>
    20b8:	9f bb       	out	0x1f, r25	; 31
    20ba:	8e bb       	out	0x1e, r24	; 30
    20bc:	e0 9a       	sbi	0x1c, 0	; 28
    20be:	01 97       	sbiw	r24, 0x01	; 1
    20c0:	0d b2       	in	r0, 0x1d	; 29
    20c2:	02 16       	cp	r0, r18
    20c4:	31 f0       	breq	.+12     	; 0x20d2 <eeprom_update_r18+0x1e>
    20c6:	2d bb       	out	0x1d, r18	; 29
    20c8:	0f b6       	in	r0, 0x3f	; 63
    20ca:	f8 94       	cli
    20cc:	e2 9a       	sbi	0x1c, 2	; 28
    20ce:	e1 9a       	sbi	0x1c, 1	; 28
    20d0:	0f be       	out	0x3f, r0	; 63
    20d2:	08 95       	ret

Disassembly of section .text.avrlibc:

00002162 <eeprom_write_byte>:
    2162:	26 2f       	mov	r18, r22

00002164 <eeprom_write_r18>:
    2164:	e1 99       	sbic	0x1c, 1	; 28
    2166:	fe cf       	rjmp	.-4      	; 0x2164 <eeprom_write_r18>
    2168:	9f bb       	out	0x1f, r25	; 31
    216a:	8e bb       	out	0x1e, r24	; 30
    216c:	2d bb       	out	0x1d, r18	; 29
    216e:	0f b6       	in	r0, 0x3f	; 63
    2170:	f8 94       	cli
    2172:	e2 9a       	sbi	0x1c, 2	; 28
    2174:	e1 9a       	sbi	0x1c, 1	; 28
    2176:	0f be       	out	0x3f, r0	; 63
    2178:	01 96       	adiw	r24, 0x01	; 1
    217a:	08 95       	ret
