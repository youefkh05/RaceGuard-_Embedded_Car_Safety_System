
MCU2_CODE.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000000ca  00000000  00000000  000000d4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00800060  00800060  00000ece  2**0
                  ALLOC, LOAD, DATA
  2 .comment      0000002f  00000000  00000000  00000ece  2**0
                  CONTENTS, READONLY
  3 .stack.descriptors.hdr 0000007e  00000000  00000000  00000efd  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000448  00000000  00000000  00000f7b  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00006a8b  00000000  00000000  000013c3  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00001247  00000000  00000000  00007e4e  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000025bc  00000000  00000000  00009095  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000009b4  00000000  00000000  0000b654  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000060e  00000000  00000000  0000c008  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000272c  00000000  00000000  0000c616  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000003a0  00000000  00000000  0000ed42  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .text         00000004  00000dea  00000dea  00000ebe  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 13 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  0000f0e4  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .text.App_Init 00000056  000009c4  000009c4  00000a98  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 15 .text.handle_Mes 00000134  00000242  00000242  00000316  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 16 .bss.speed    00000002  00800084  00800084  00000ece  2**0
                  ALLOC
 17 .bss.currentState 00000001  00800092  00800092  00000ece  2**0
                  ALLOC
 18 .bss.UART_Rdata 00000002  00800086  00800086  00000ece  2**0
                  ALLOC
 19 .bss.DC_mach1 00000001  00800093  00800093  00000ece  2**0
                  ALLOC
 20 .text.BUZZER_Initialize 0000000c  00000d2a  00000d2a  00000dfe  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 21 .text.BUZZER_ON 0000000c  00000d36  00000d36  00000e0a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 22 .text.BUZZER_OFF 0000000c  00000d42  00000d42  00000e16  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 23 .text.LED1_Initialize 0000000c  00000d4e  00000d4e  00000e22  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 24 .text.LED1_ON 0000000c  00000d5a  00000d5a  00000e2e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 25 .text.LED1_OFF 0000000c  00000d66  00000d66  00000e3a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 26 .text.LED2_Initialize 0000000c  00000d72  00000d72  00000e46  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 27 .text.LED2_ON 0000000c  00000d7e  00000d7e  00000e52  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 28 .text.LED2_OFF 0000000c  00000d8a  00000d8a  00000e5e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 29 .text.LED3_Initialize 0000000c  00000d96  00000d96  00000e6a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 30 .text.LED3_ON 0000000c  00000da2  00000da2  00000e76  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 31 .text.LED3_OFF 0000000c  00000dae  00000dae  00000e82  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 32 .text.DC_Initialize 00000050  00000a1a  00000a1a  00000aee  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 33 .text.DC_Start 000000ae  000007ca  000007ca  0000089e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 34 .text.DC_Stop 0000004c  00000a6a  00000a6a  00000b3e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 35 .text.DC_Change_Speed 0000002e  00000c58  00000c58  00000d2c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 36 .text.ServoMotor_Initialize 00000022  00000cb4  00000cb4  00000d88  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 37 .text.ServoMotor_Rotate 00000012  00000cec  00000cec  00000dc0  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 38 .text.main    0000005e  00000966  00000966  00000a3a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 39 .text.ADC_Initialize 0000000e  00000d0e  00000d0e  00000de2  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 40 .text.ADC_Read 00000074  000008f2  000008f2  000009c6  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 41 .text.DIO_SetPinDirection 000000e2  00000496  00000496  0000056a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 42 .text.DIO_SetPinValue 000000e2  00000578  00000578  0000064c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 43 .text.UART_Initialize_WithoutInterrupt 00000120  00000376  00000376  0000044a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 44 .text.UART_Receive_Character 0000000e  00000d1c  00000d1c  00000df0  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 45 .text.Reassemble_uint16 0000000a  00000dc6  00000dc6  00000e9a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 46 .text.UART_Receive_Word 0000004a  00000b02  00000b02  00000bd6  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 47 .text.vListInsertEnd 00000042  00000bd8  00000bd8  00000cac  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 48 .text.uxListRemove 0000004c  00000ab6  00000ab6  00000b8a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 49 .text.vPortYieldFromTick 000000b8  0000065a  0000065a  0000072e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 50 .text.__vector_7 00000006  00000de4  00000de4  00000eb8  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 51 .text.prvResetNextTaskUnblockTime 0000003e  00000c1a  00000c1a  00000cee  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 52 .text.xTaskIncrementTick 00000178  000000ca  000000ca  0000019e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 53 .text.vTaskSwitchContext 000000b8  00000712  00000712  000007e6  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 54 .bss.uxSchedulerSuspended 00000001  00800094  00800094  00000ece  2**0
                  ALLOC
 55 .data.xNextTaskUnblockTime 00000002  00800088  00000df8  00000ecc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 56 .bss.xNumOfOverflows 00000001  00800095  00800095  00000ece  2**0
                  ALLOC
 57 .bss.xYieldPending 00000001  00800096  00800096  00000ece  2**0
                  ALLOC
 58 .bss.uxPendedTicks 00000001  00800097  00800097  00000ece  2**0
                  ALLOC
 59 .bss.uxTopReadyPriority 00000001  00800098  00800098  00000ece  2**0
                  ALLOC
 60 .bss.xTickCount 00000002  0080008a  0080008a  00000ece  2**0
                  ALLOC
 61 .bss.pxOverflowDelayedTaskList 00000002  0080008c  0080008c  00000ece  2**0
                  ALLOC
 62 .bss.pxDelayedTaskList 00000002  0080008e  0080008e  00000ece  2**0
                  ALLOC
 63 .bss.pxReadyTasksLists 00000024  00800060  00800060  00000ece  2**0
                  ALLOC
 64 .bss.pxCurrentTCB 00000002  00800090  00800090  00000ece  2**0
                  ALLOC
 65 .text         0000000a  00000dd0  00000dd0  00000ea4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 66 .text         0000007a  00000878  00000878  0000094c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 67 .text         00000048  00000b4c  00000b4c  00000c20  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 68 .text         0000000a  00000dda  00000dda  00000eae  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 69 .text.libgcc.div 00000044  00000b94  00000b94  00000c68  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 70 .text.libgcc.div 0000002e  00000c86  00000c86  00000d5a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 71 .text.libgcc.div 00000010  00000cfe  00000cfe  00000dd2  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 72 .text.libgcc  0000000c  00000dba  00000dba  00000e8e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 73 .text.__dummy_fini 00000002  00000df2  00000df2  00000ec6  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 74 .text.__dummy_funcs_on_exit 00000002  00000df4  00000df4  00000ec8  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 75 .text.__dummy_simulator_exit 00000002  00000df6  00000df6  00000eca  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 76 .text.exit    00000016  00000cd6  00000cd6  00000daa  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 77 .text._Exit   00000004  00000dee  00000dee  00000ec2  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 3b 00 	jmp	0x76	; 0x76 <__ctors_end>
   4:	0c 94 f5 06 	jmp	0xdea	; 0xdea <__bad_interrupt>
   8:	0c 94 f5 06 	jmp	0xdea	; 0xdea <__bad_interrupt>
   c:	0c 94 f5 06 	jmp	0xdea	; 0xdea <__bad_interrupt>
  10:	0c 94 f5 06 	jmp	0xdea	; 0xdea <__bad_interrupt>
  14:	0c 94 f5 06 	jmp	0xdea	; 0xdea <__bad_interrupt>
  18:	0c 94 f5 06 	jmp	0xdea	; 0xdea <__bad_interrupt>
  1c:	0c 94 f2 06 	jmp	0xde4	; 0xde4 <__vector_7>
  20:	0c 94 f5 06 	jmp	0xdea	; 0xdea <__bad_interrupt>
  24:	0c 94 f5 06 	jmp	0xdea	; 0xdea <__bad_interrupt>
  28:	0c 94 f5 06 	jmp	0xdea	; 0xdea <__bad_interrupt>
  2c:	0c 94 f5 06 	jmp	0xdea	; 0xdea <__bad_interrupt>
  30:	0c 94 f5 06 	jmp	0xdea	; 0xdea <__bad_interrupt>
  34:	0c 94 f5 06 	jmp	0xdea	; 0xdea <__bad_interrupt>
  38:	0c 94 f5 06 	jmp	0xdea	; 0xdea <__bad_interrupt>
  3c:	0c 94 f5 06 	jmp	0xdea	; 0xdea <__bad_interrupt>
  40:	0c 94 f5 06 	jmp	0xdea	; 0xdea <__bad_interrupt>
  44:	0c 94 f5 06 	jmp	0xdea	; 0xdea <__bad_interrupt>
  48:	0c 94 f5 06 	jmp	0xdea	; 0xdea <__bad_interrupt>
  4c:	0c 94 f5 06 	jmp	0xdea	; 0xdea <__bad_interrupt>
  50:	0c 94 f5 06 	jmp	0xdea	; 0xdea <__bad_interrupt>
  54:	86 04       	cpc	r8, r6
  56:	8a 04       	cpc	r8, r10
  58:	8f 04       	cpc	r8, r15
  5a:	94 04       	cpc	r9, r4
  5c:	99 04       	cpc	r9, r9
  5e:	9e 04       	cpc	r9, r14
  60:	a3 04       	cpc	r10, r3
  62:	a8 04       	cpc	r10, r8

00000064 <.dinit>:
  64:	00 60       	ori	r16, 0x00	; 0
  66:	00 88       	ldd	r0, Z+16	; 0x10
  68:	80 00       	.word	0x0080	; ????
  6a:	88 00       	.word	0x0088	; ????
  6c:	8a 00       	.word	0x008a	; ????
  6e:	0d f8       	.word	0xf80d	; ????
  70:	00 8a       	std	Z+16, r0	; 0x10
  72:	00 99       	sbic	0x00, 0	; 0
  74:	80 00       	.word	0x0080	; ????

00000076 <__ctors_end>:
  76:	11 24       	eor	r1, r1
  78:	1f be       	out	0x3f, r1	; 63
  7a:	cf e5       	ldi	r28, 0x5F	; 95
  7c:	d8 e0       	ldi	r29, 0x08	; 8
  7e:	de bf       	out	0x3e, r29	; 62
  80:	cd bf       	out	0x3d, r28	; 61

00000082 <__do_copy_data>:
  82:	e4 e6       	ldi	r30, 0x64	; 100
  84:	f0 e0       	ldi	r31, 0x00	; 0
  86:	40 e0       	ldi	r20, 0x00	; 0
  88:	17 c0       	rjmp	.+46     	; 0xb8 <__do_clear_bss+0x8>
  8a:	b5 91       	lpm	r27, Z+
  8c:	a5 91       	lpm	r26, Z+
  8e:	35 91       	lpm	r19, Z+
  90:	25 91       	lpm	r18, Z+
  92:	05 91       	lpm	r16, Z+
  94:	07 fd       	sbrc	r16, 7
  96:	0c c0       	rjmp	.+24     	; 0xb0 <__do_clear_bss>
  98:	95 91       	lpm	r25, Z+
  9a:	85 91       	lpm	r24, Z+
  9c:	ef 01       	movw	r28, r30
  9e:	f9 2f       	mov	r31, r25
  a0:	e8 2f       	mov	r30, r24
  a2:	05 90       	lpm	r0, Z+
  a4:	0d 92       	st	X+, r0
  a6:	a2 17       	cp	r26, r18
  a8:	b3 07       	cpc	r27, r19
  aa:	d9 f7       	brne	.-10     	; 0xa2 <__do_copy_data+0x20>
  ac:	fe 01       	movw	r30, r28
  ae:	04 c0       	rjmp	.+8      	; 0xb8 <__do_clear_bss+0x8>

000000b0 <__do_clear_bss>:
  b0:	1d 92       	st	X+, r1
  b2:	a2 17       	cp	r26, r18
  b4:	b3 07       	cpc	r27, r19
  b6:	e1 f7       	brne	.-8      	; 0xb0 <__do_clear_bss>
  b8:	e5 37       	cpi	r30, 0x75	; 117
  ba:	f4 07       	cpc	r31, r20
  bc:	31 f7       	brne	.-52     	; 0x8a <__do_copy_data+0x8>
  be:	0e 94 b3 04 	call	0x966	; 0x966 <main>
  c2:	0c 94 6b 06 	jmp	0xcd6	; 0xcd6 <exit>

000000c6 <_exit>:
  c6:	f8 94       	cli

000000c8 <__stop_program>:
  c8:	ff cf       	rjmp	.-2      	; 0xc8 <__stop_program>

Disassembly of section .text:

00000dea <__bad_interrupt>:
 dea:	0c 94 00 00 	jmp	0	; 0x0 <__TEXT_REGION_ORIGIN__>

Disassembly of section .text.App_Init:

000009c4 <App_Init>:
//variables (LOCAL But golbal to debugg)
uint16_t UART_Rdata=0;
volatile E2PROM_State currentState =Normal_state;
uint16_t speed=0;

void App_Init(void){
 9c4:	0f 93       	push	r16
	/*		Initializations		*/
	DC_Initialize(DC_mach1);
 9c6:	80 91 93 00 	lds	r24, 0x0093	; 0x800093 <DC_mach1>
 9ca:	0e 94 0d 05 	call	0xa1a	; 0xa1a <DC_Initialize>
	ServoMotor_Initialize();
 9ce:	0e 94 5a 06 	call	0xcb4	; 0xcb4 <ServoMotor_Initialize>
	LED1_Initialize();
 9d2:	0e 94 a7 06 	call	0xd4e	; 0xd4e <LED1_Initialize>
	LED2_Initialize();
 9d6:	0e 94 b9 06 	call	0xd72	; 0xd72 <LED2_Initialize>
	LED3_Initialize();
 9da:	0e 94 cb 06 	call	0xd96	; 0xd96 <LED3_Initialize>
	//LED4_Initialize();
	BUZZER_Initialize();
 9de:	0e 94 95 06 	call	0xd2a	; 0xd2a <BUZZER_Initialize>
	ADC_Initialize(AVCC,ADC_PRE0);
 9e2:	60 e0       	ldi	r22, 0x00	; 0
 9e4:	81 e0       	ldi	r24, 0x01	; 1
 9e6:	0e 94 87 06 	call	0xd0e	; 0xd0e <ADC_Initialize>
	uart_status UART_State= UART_Initialize_WithoutInterrupt(UART_9600,Synchronous, Disable , Bits_8, Bit_1);
 9ea:	00 e0       	ldi	r16, 0x00	; 0
 9ec:	23 e0       	ldi	r18, 0x03	; 3
 9ee:	40 e0       	ldi	r20, 0x00	; 0
 9f0:	61 e0       	ldi	r22, 0x01	; 1
 9f2:	80 e6       	ldi	r24, 0x60	; 96
 9f4:	90 e0       	ldi	r25, 0x00	; 0
 9f6:	0e 94 bb 01 	call	0x376	; 0x376 <UART_Initialize_WithoutInterrupt>
	if(UART_State==UART_NOK){
 9fa:	88 23       	and	r24, r24
 9fc:	61 f0       	breq	.+24     	; 0xa16 <App_Init+0x52>
		return ;
	}
	
	//Start the machine
	ServoMotor_Rotate(90);
 9fe:	8a e5       	ldi	r24, 0x5A	; 90
 a00:	0e 94 76 06 	call	0xcec	; 0xcec <ServoMotor_Rotate>
	DC_Start(DC_mach1,DC_CW,speed);
 a04:	40 91 84 00 	lds	r20, 0x0084	; 0x800084 <speed>
 a08:	50 91 85 00 	lds	r21, 0x0085	; 0x800085 <speed+0x1>
 a0c:	60 e0       	ldi	r22, 0x00	; 0
 a0e:	80 91 93 00 	lds	r24, 0x0093	; 0x800093 <DC_mach1>
 a12:	0e 94 e5 03 	call	0x7ca	; 0x7ca <DC_Start>
}
 a16:	0f 91       	pop	r16
 a18:	08 95       	ret

Disassembly of section .text.handle_Mes:

00000242 <handle_Mes>:

void handle_Mes(temp T,dc_motor DC_MOT,uint16_t speed, E2PROM_State* S){
 242:	af 92       	push	r10
 244:	bf 92       	push	r11
 246:	cf 92       	push	r12
 248:	df 92       	push	r13
 24a:	ef 92       	push	r14
 24c:	ff 92       	push	r15
 24e:	1f 93       	push	r17
 250:	cf 93       	push	r28
 252:	df 93       	push	r29
 254:	ec 01       	movw	r28, r24
 256:	16 2f       	mov	r17, r22
 258:	7a 01       	movw	r14, r20
 25a:	59 01       	movw	r10, r18
	
	// off all LED and Buzzer
	LED1_OFF();
 25c:	0e 94 b3 06 	call	0xd66	; 0xd66 <LED1_OFF>
	LED2_OFF();
 260:	0e 94 c5 06 	call	0xd8a	; 0xd8a <LED2_OFF>
	LED3_OFF();
 264:	0e 94 d7 06 	call	0xdae	; 0xdae <LED3_OFF>
	BUZZER_OFF();
 268:	0e 94 a1 06 	call	0xd42	; 0xd42 <BUZZER_OFF>
	DC_Start(DC_MOT,DC_CW,speed);
 26c:	a7 01       	movw	r20, r14
 26e:	60 e0       	ldi	r22, 0x00	; 0
 270:	81 2f       	mov	r24, r17
 272:	0e 94 e5 03 	call	0x7ca	; 0x7ca <DC_Start>
	
	if(T<=20.0){
 276:	be 01       	movw	r22, r28
 278:	80 e0       	ldi	r24, 0x00	; 0
 27a:	90 e0       	ldi	r25, 0x00	; 0
 27c:	0e 94 3c 04 	call	0x878	; 0x878 <__floatunsisf>
 280:	6b 01       	movw	r12, r22
 282:	7c 01       	movw	r14, r24
 284:	20 e0       	ldi	r18, 0x00	; 0
 286:	30 e0       	ldi	r19, 0x00	; 0
 288:	40 ea       	ldi	r20, 0xA0	; 160
 28a:	51 e4       	ldi	r21, 0x41	; 65
 28c:	0e 94 e8 06 	call	0xdd0	; 0xdd0 <__cmpsf2>
 290:	18 16       	cp	r1, r24
 292:	2c f0       	brlt	.+10     	; 0x29e <handle_Mes+0x5c>
		LED3_ON();
 294:	0e 94 d1 06 	call	0xda2	; 0xda2 <LED3_ON>
		*S=Normal_state;	
 298:	f5 01       	movw	r30, r10
 29a:	10 82       	st	Z, r1
 29c:	62 c0       	rjmp	.+196    	; 0x362 <handle_Mes+0x120>
	}
	else if (T>20.0 && T<=40.0){
 29e:	20 e0       	ldi	r18, 0x00	; 0
 2a0:	30 e0       	ldi	r19, 0x00	; 0
 2a2:	40 ea       	ldi	r20, 0xA0	; 160
 2a4:	51 e4       	ldi	r21, 0x41	; 65
 2a6:	c7 01       	movw	r24, r14
 2a8:	b6 01       	movw	r22, r12
 2aa:	0e 94 ed 06 	call	0xdda	; 0xdda <__gesf2>
 2ae:	18 16       	cp	r1, r24
 2b0:	7c f4       	brge	.+30     	; 0x2d0 <handle_Mes+0x8e>
 2b2:	20 e0       	ldi	r18, 0x00	; 0
 2b4:	30 e0       	ldi	r19, 0x00	; 0
 2b6:	40 e2       	ldi	r20, 0x20	; 32
 2b8:	52 e4       	ldi	r21, 0x42	; 66
 2ba:	c7 01       	movw	r24, r14
 2bc:	b6 01       	movw	r22, r12
 2be:	0e 94 e8 06 	call	0xdd0	; 0xdd0 <__cmpsf2>
 2c2:	18 16       	cp	r1, r24
 2c4:	2c f0       	brlt	.+10     	; 0x2d0 <handle_Mes+0x8e>
		LED2_ON();
 2c6:	0e 94 bf 06 	call	0xd7e	; 0xd7e <LED2_ON>
		*S=Normal_state;
 2ca:	f5 01       	movw	r30, r10
 2cc:	10 82       	st	Z, r1
 2ce:	49 c0       	rjmp	.+146    	; 0x362 <handle_Mes+0x120>
	}
	else if (T>40.0 && T<=50.0){
 2d0:	20 e0       	ldi	r18, 0x00	; 0
 2d2:	30 e0       	ldi	r19, 0x00	; 0
 2d4:	40 e2       	ldi	r20, 0x20	; 32
 2d6:	52 e4       	ldi	r21, 0x42	; 66
 2d8:	c7 01       	movw	r24, r14
 2da:	b6 01       	movw	r22, r12
 2dc:	0e 94 ed 06 	call	0xdda	; 0xdda <__gesf2>
 2e0:	18 16       	cp	r1, r24
 2e2:	6c f4       	brge	.+26     	; 0x2fe <handle_Mes+0xbc>
 2e4:	20 e0       	ldi	r18, 0x00	; 0
 2e6:	30 e0       	ldi	r19, 0x00	; 0
 2e8:	48 e4       	ldi	r20, 0x48	; 72
 2ea:	52 e4       	ldi	r21, 0x42	; 66
 2ec:	c7 01       	movw	r24, r14
 2ee:	b6 01       	movw	r22, r12
 2f0:	0e 94 e8 06 	call	0xdd0	; 0xdd0 <__cmpsf2>
 2f4:	18 16       	cp	r1, r24
 2f6:	1c f0       	brlt	.+6      	; 0x2fe <handle_Mes+0xbc>
		LED1_ON();
 2f8:	0e 94 ad 06 	call	0xd5a	; 0xd5a <LED1_ON>
 2fc:	32 c0       	rjmp	.+100    	; 0x362 <handle_Mes+0x120>
	}
	else if (T==Off_Mes)
 2fe:	cf 3f       	cpi	r28, 0xFF	; 255
 300:	d1 05       	cpc	r29, r1
 302:	49 f4       	brne	.+18     	; 0x316 <handle_Mes+0xd4>
	{
		*S=Off_state;
 304:	83 e0       	ldi	r24, 0x03	; 3
 306:	f5 01       	movw	r30, r10
 308:	80 83       	st	Z, r24
		LED1_ON();
 30a:	0e 94 ad 06 	call	0xd5a	; 0xd5a <LED1_ON>
		DC_Stop(DC_MOT);
 30e:	81 2f       	mov	r24, r17
 310:	0e 94 35 05 	call	0xa6a	; 0xa6a <DC_Stop>
 314:	26 c0       	rjmp	.+76     	; 0x362 <handle_Mes+0x120>
	}
	else if (T==Emergency_Mes)
 316:	cc 32       	cpi	r28, 0x2C	; 44
 318:	f1 e0       	ldi	r31, 0x01	; 1
 31a:	df 07       	cpc	r29, r31
 31c:	41 f4       	brne	.+16     	; 0x32e <handle_Mes+0xec>
	{
		*S=Emergency_state;
 31e:	81 e0       	ldi	r24, 0x01	; 1
 320:	f5 01       	movw	r30, r10
 322:	80 83       	st	Z, r24
		LED1_ON();
 324:	0e 94 ad 06 	call	0xd5a	; 0xd5a <LED1_ON>
		BUZZER_ON();
 328:	0e 94 9b 06 	call	0xd36	; 0xd36 <BUZZER_ON>
 32c:	1a c0       	rjmp	.+52     	; 0x362 <handle_Mes+0x120>
	}
	else if (T==Abnormal_Mes)
 32e:	ce 35       	cpi	r28, 0x5E	; 94
 330:	d1 40       	sbci	r29, 0x01	; 1
 332:	71 f4       	brne	.+28     	; 0x350 <handle_Mes+0x10e>
	{
		*S=Abnormal_Mes;
 334:	8e e5       	ldi	r24, 0x5E	; 94
 336:	f5 01       	movw	r30, r10
 338:	80 83       	st	Z, r24
		LED1_ON();
 33a:	0e 94 ad 06 	call	0xd5a	; 0xd5a <LED1_ON>
		BUZZER_ON();
 33e:	0e 94 9b 06 	call	0xd36	; 0xd36 <BUZZER_ON>
		DC_Stop(DC_MOT);
 342:	81 2f       	mov	r24, r17
 344:	0e 94 35 05 	call	0xa6a	; 0xa6a <DC_Stop>
		ServoMotor_Rotate(90);
 348:	8a e5       	ldi	r24, 0x5A	; 90
 34a:	0e 94 76 06 	call	0xcec	; 0xcec <ServoMotor_Rotate>
 34e:	09 c0       	rjmp	.+18     	; 0x362 <handle_Mes+0x120>
		
	}
	else {
		//for debugg
		LED1_ON();
 350:	0e 94 ad 06 	call	0xd5a	; 0xd5a <LED1_ON>
		LED2_ON();
 354:	0e 94 bf 06 	call	0xd7e	; 0xd7e <LED2_ON>
		LED3_ON();
 358:	0e 94 d1 06 	call	0xda2	; 0xda2 <LED3_ON>
		*S=Emergency_state;
 35c:	81 e0       	ldi	r24, 0x01	; 1
 35e:	f5 01       	movw	r30, r10
 360:	80 83       	st	Z, r24
	}
}
 362:	df 91       	pop	r29
 364:	cf 91       	pop	r28
 366:	1f 91       	pop	r17
 368:	ff 90       	pop	r15
 36a:	ef 90       	pop	r14
 36c:	df 90       	pop	r13
 36e:	cf 90       	pop	r12
 370:	bf 90       	pop	r11
 372:	af 90       	pop	r10
 374:	08 95       	ret

Disassembly of section .text.BUZZER_Initialize:

00000d2a <BUZZER_Initialize>:



void BUZZER_Initialize(void)
{
	DIO_SetPinDirection(BUZZER_PORT, BUZZER_PIN, BUZZER_OUTPUT);
 d2a:	41 e0       	ldi	r20, 0x01	; 1
 d2c:	64 e0       	ldi	r22, 0x04	; 4
 d2e:	81 e0       	ldi	r24, 0x01	; 1
 d30:	0e 94 4b 02 	call	0x496	; 0x496 <DIO_SetPinDirection>
 d34:	08 95       	ret

Disassembly of section .text.BUZZER_ON:

00000d36 <BUZZER_ON>:
}
void BUZZER_ON(void)
{
	DIO_SetPinValue(BUZZER_PORT, BUZZER_PIN, BUZZER_HIGH);
 d36:	41 e0       	ldi	r20, 0x01	; 1
 d38:	64 e0       	ldi	r22, 0x04	; 4
 d3a:	81 e0       	ldi	r24, 0x01	; 1
 d3c:	0e 94 bc 02 	call	0x578	; 0x578 <DIO_SetPinValue>
 d40:	08 95       	ret

Disassembly of section .text.BUZZER_OFF:

00000d42 <BUZZER_OFF>:
}
void BUZZER_OFF(void)
{
	DIO_SetPinValue(BUZZER_PORT, BUZZER_PIN, BUZZER_LOW);
 d42:	40 e0       	ldi	r20, 0x00	; 0
 d44:	64 e0       	ldi	r22, 0x04	; 4
 d46:	81 e0       	ldi	r24, 0x01	; 1
 d48:	0e 94 bc 02 	call	0x578	; 0x578 <DIO_SetPinValue>
 d4c:	08 95       	ret

Disassembly of section .text.LED1_Initialize:

00000d4e <LED1_Initialize>:

static char num_arr[]={0xC0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90};

void LED1_Initialize(void)
{
	DIO_SetPinDirection(LED1_PORT, LED1_PIN, LED1_OUTPUT);
 d4e:	41 e0       	ldi	r20, 0x01	; 1
 d50:	60 e0       	ldi	r22, 0x00	; 0
 d52:	81 e0       	ldi	r24, 0x01	; 1
 d54:	0e 94 4b 02 	call	0x496	; 0x496 <DIO_SetPinDirection>
 d58:	08 95       	ret

Disassembly of section .text.LED1_ON:

00000d5a <LED1_ON>:
}
void LED1_ON(void)
{
	DIO_SetPinValue(LED1_PORT, LED1_PIN, LED1_HIGH);
 d5a:	41 e0       	ldi	r20, 0x01	; 1
 d5c:	60 e0       	ldi	r22, 0x00	; 0
 d5e:	81 e0       	ldi	r24, 0x01	; 1
 d60:	0e 94 bc 02 	call	0x578	; 0x578 <DIO_SetPinValue>
 d64:	08 95       	ret

Disassembly of section .text.LED1_OFF:

00000d66 <LED1_OFF>:
}
void LED1_OFF(void)
{
	DIO_SetPinValue(LED1_PORT, LED1_PIN, LED1_LOW);
 d66:	40 e0       	ldi	r20, 0x00	; 0
 d68:	60 e0       	ldi	r22, 0x00	; 0
 d6a:	81 e0       	ldi	r24, 0x01	; 1
 d6c:	0e 94 bc 02 	call	0x578	; 0x578 <DIO_SetPinValue>
 d70:	08 95       	ret

Disassembly of section .text.LED2_Initialize:

00000d72 <LED2_Initialize>:

#include "LED2_Private.h"

void LED2_Initialize(void)
{
	DIO_SetPinDirection(LED2_PORT, LED2_PIN, LED2_OUTPUT);
 d72:	41 e0       	ldi	r20, 0x01	; 1
 d74:	61 e0       	ldi	r22, 0x01	; 1
 d76:	81 e0       	ldi	r24, 0x01	; 1
 d78:	0e 94 4b 02 	call	0x496	; 0x496 <DIO_SetPinDirection>
 d7c:	08 95       	ret

Disassembly of section .text.LED2_ON:

00000d7e <LED2_ON>:
}
void LED2_ON(void)
{
	DIO_SetPinValue(LED2_PORT, LED2_PIN, LED2_HIGH);
 d7e:	41 e0       	ldi	r20, 0x01	; 1
 d80:	61 e0       	ldi	r22, 0x01	; 1
 d82:	81 e0       	ldi	r24, 0x01	; 1
 d84:	0e 94 bc 02 	call	0x578	; 0x578 <DIO_SetPinValue>
 d88:	08 95       	ret

Disassembly of section .text.LED2_OFF:

00000d8a <LED2_OFF>:
}
void LED2_OFF(void)
{
	DIO_SetPinValue(LED2_PORT, LED2_PIN, LED2_LOW);
 d8a:	40 e0       	ldi	r20, 0x00	; 0
 d8c:	61 e0       	ldi	r22, 0x01	; 1
 d8e:	81 e0       	ldi	r24, 0x01	; 1
 d90:	0e 94 bc 02 	call	0x578	; 0x578 <DIO_SetPinValue>
 d94:	08 95       	ret

Disassembly of section .text.LED3_Initialize:

00000d96 <LED3_Initialize>:

#include "LED3_Private.h"

void LED3_Initialize(void)
{
	DIO_SetPinDirection(LED3_PORT, LED3_PIN, LED3_OUTPUT);
 d96:	41 e0       	ldi	r20, 0x01	; 1
 d98:	62 e0       	ldi	r22, 0x02	; 2
 d9a:	81 e0       	ldi	r24, 0x01	; 1
 d9c:	0e 94 4b 02 	call	0x496	; 0x496 <DIO_SetPinDirection>
 da0:	08 95       	ret

Disassembly of section .text.LED3_ON:

00000da2 <LED3_ON>:
}
void LED3_ON(void)
{
	DIO_SetPinValue(LED3_PORT, LED3_PIN, LED3_HIGH);
 da2:	41 e0       	ldi	r20, 0x01	; 1
 da4:	62 e0       	ldi	r22, 0x02	; 2
 da6:	81 e0       	ldi	r24, 0x01	; 1
 da8:	0e 94 bc 02 	call	0x578	; 0x578 <DIO_SetPinValue>
 dac:	08 95       	ret

Disassembly of section .text.LED3_OFF:

00000dae <LED3_OFF>:
}
void LED3_OFF(void)
{
	DIO_SetPinValue(LED3_PORT, LED3_PIN, LED3_LOW);
 dae:	40 e0       	ldi	r20, 0x00	; 0
 db0:	62 e0       	ldi	r22, 0x02	; 2
 db2:	81 e0       	ldi	r24, 0x01	; 1
 db4:	0e 94 bc 02 	call	0x578	; 0x578 <DIO_SetPinValue>
 db8:	08 95       	ret

Disassembly of section .text.DC_Initialize:

00000a1a <DC_Initialize>:

#include "DC_Private.h"

void DC_Initialize(dc_motor motor)
{	
	switch(motor)
 a1a:	88 23       	and	r24, r24
 a1c:	19 f0       	breq	.+6      	; 0xa24 <DC_Initialize+0xa>
 a1e:	81 30       	cpi	r24, 0x01	; 1
 a20:	a1 f0       	breq	.+40     	; 0xa4a <DC_Initialize+0x30>
 a22:	08 95       	ret
	{
		case DC_Motor1:
		DIO_SetPinDirection(DC_Enable_Port, DC_Enable1_Pin, DC_OUTPUT);
 a24:	41 e0       	ldi	r20, 0x01	; 1
 a26:	63 e0       	ldi	r22, 0x03	; 3
 a28:	81 e0       	ldi	r24, 0x01	; 1
 a2a:	0e 94 4b 02 	call	0x496	; 0x496 <DIO_SetPinDirection>
		DIO_SetPinDirection(DC_Motor_Port, DC_Motor1_A1, DC_OUTPUT);
 a2e:	41 e0       	ldi	r20, 0x01	; 1
 a30:	61 e0       	ldi	r22, 0x01	; 1
 a32:	82 e0       	ldi	r24, 0x02	; 2
 a34:	0e 94 4b 02 	call	0x496	; 0x496 <DIO_SetPinDirection>
		DIO_SetPinDirection(DC_Motor_Port, DC_Motor1_A2, DC_OUTPUT);
 a38:	41 e0       	ldi	r20, 0x01	; 1
 a3a:	62 e0       	ldi	r22, 0x02	; 2
 a3c:	82 e0       	ldi	r24, 0x02	; 2
 a3e:	0e 94 4b 02 	call	0x496	; 0x496 <DIO_SetPinDirection>
		TCNT0 = 0;			/* Set timer0 count zero */
 a42:	12 be       	out	0x32, r1	; 50
		TCCR0 = (1<<WGM00)|(1<<WGM01)|(1<<COM01)|(1<<CS00)|(1<<CS01);/* Set Fast PWM with Fosc/64 Timer0 clock */
 a44:	8b e6       	ldi	r24, 0x6B	; 107
 a46:	83 bf       	out	0x33, r24	; 51
		break;
 a48:	08 95       	ret
		case DC_Motor2:
		DIO_SetPinDirection(DC_Enable_Port, DC_Enable2_Pin, DC_OUTPUT);
 a4a:	41 e0       	ldi	r20, 0x01	; 1
 a4c:	62 e0       	ldi	r22, 0x02	; 2
 a4e:	81 e0       	ldi	r24, 0x01	; 1
 a50:	0e 94 4b 02 	call	0x496	; 0x496 <DIO_SetPinDirection>
		DIO_SetPinDirection(DC_Motor_Port, DC_Motor2_A3, DC_OUTPUT);
 a54:	41 e0       	ldi	r20, 0x01	; 1
 a56:	62 e0       	ldi	r22, 0x02	; 2
 a58:	82 e0       	ldi	r24, 0x02	; 2
 a5a:	0e 94 4b 02 	call	0x496	; 0x496 <DIO_SetPinDirection>
		DIO_SetPinDirection(DC_Motor_Port, DC_Motor2_A4, DC_OUTPUT);
 a5e:	41 e0       	ldi	r20, 0x01	; 1
 a60:	62 e0       	ldi	r22, 0x02	; 2
 a62:	82 e0       	ldi	r24, 0x02	; 2
 a64:	0e 94 4b 02 	call	0x496	; 0x496 <DIO_SetPinDirection>
 a68:	08 95       	ret

Disassembly of section .text.DC_Start:

000007ca <DC_Start>:
	}
	
}

void DC_Start(dc_motor motor, dc_motor_direction direction, uint16_t speed)
{	
 7ca:	0f 93       	push	r16
 7cc:	1f 93       	push	r17
 7ce:	cf 93       	push	r28
 7d0:	c6 2f       	mov	r28, r22
 7d2:	8a 01       	movw	r16, r20
	switch(motor)
 7d4:	88 23       	and	r24, r24
 7d6:	19 f0       	breq	.+6      	; 0x7de <DC_Start+0x14>
 7d8:	81 30       	cpi	r24, 0x01	; 1
 7da:	59 f1       	breq	.+86     	; 0x832 <__DATA_REGION_LENGTH__+0x32>
 7dc:	49 c0       	rjmp	.+146    	; 0x870 <__stack+0x11>
	{
		case DC_Motor1:
		DIO_SetPinValue(DC_Enable_Port, DC_Enable1_Pin, DC_HIGH);
 7de:	41 e0       	ldi	r20, 0x01	; 1
 7e0:	63 e0       	ldi	r22, 0x03	; 3
 7e2:	81 e0       	ldi	r24, 0x01	; 1
 7e4:	0e 94 bc 02 	call	0x578	; 0x578 <DIO_SetPinValue>
		OCR0 =(speed *250)/ 1024;
 7e8:	2a ef       	ldi	r18, 0xFA	; 250
 7ea:	20 9f       	mul	r18, r16
 7ec:	c0 01       	movw	r24, r0
 7ee:	21 9f       	mul	r18, r17
 7f0:	90 0d       	add	r25, r0
 7f2:	11 24       	eor	r1, r1
 7f4:	89 2f       	mov	r24, r25
 7f6:	86 95       	lsr	r24
 7f8:	86 95       	lsr	r24
 7fa:	8c bf       	out	0x3c, r24	; 60
		switch(direction)
 7fc:	cc 23       	and	r28, r28
 7fe:	19 f0       	breq	.+6      	; 0x806 <__DATA_REGION_LENGTH__+0x6>
 800:	c1 30       	cpi	r28, 0x01	; 1
 802:	61 f0       	breq	.+24     	; 0x81c <__DATA_REGION_LENGTH__+0x1c>
 804:	35 c0       	rjmp	.+106    	; 0x870 <__stack+0x11>
		{
			case DC_CW:
			DIO_SetPinValue(DC_Motor_Port, DC_Motor1_A1, DC_HIGH);
 806:	41 e0       	ldi	r20, 0x01	; 1
 808:	61 e0       	ldi	r22, 0x01	; 1
 80a:	82 e0       	ldi	r24, 0x02	; 2
 80c:	0e 94 bc 02 	call	0x578	; 0x578 <DIO_SetPinValue>
			DIO_SetPinValue(DC_Motor_Port, DC_Motor1_A2, DC_LOW);
 810:	40 e0       	ldi	r20, 0x00	; 0
 812:	62 e0       	ldi	r22, 0x02	; 2
 814:	82 e0       	ldi	r24, 0x02	; 2
 816:	0e 94 bc 02 	call	0x578	; 0x578 <DIO_SetPinValue>
			break;
 81a:	2a c0       	rjmp	.+84     	; 0x870 <__stack+0x11>
			case DC_CCW:
			DIO_SetPinValue(DC_Motor_Port, DC_Motor1_A1, DC_LOW);
 81c:	40 e0       	ldi	r20, 0x00	; 0
 81e:	61 e0       	ldi	r22, 0x01	; 1
 820:	82 e0       	ldi	r24, 0x02	; 2
 822:	0e 94 bc 02 	call	0x578	; 0x578 <DIO_SetPinValue>
			DIO_SetPinValue(DC_Motor_Port, DC_Motor1_A2, DC_HIGH);
 826:	41 e0       	ldi	r20, 0x01	; 1
 828:	62 e0       	ldi	r22, 0x02	; 2
 82a:	82 e0       	ldi	r24, 0x02	; 2
 82c:	0e 94 bc 02 	call	0x578	; 0x578 <DIO_SetPinValue>
			break;
 830:	1f c0       	rjmp	.+62     	; 0x870 <__stack+0x11>
		}
		break;
		case DC_Motor2:
		DIO_SetPinValue(DC_Enable_Port, DC_Enable2_Pin, DC_HIGH);
 832:	41 e0       	ldi	r20, 0x01	; 1
 834:	62 e0       	ldi	r22, 0x02	; 2
 836:	81 e0       	ldi	r24, 0x01	; 1
 838:	0e 94 bc 02 	call	0x578	; 0x578 <DIO_SetPinValue>
		switch(direction)
 83c:	cc 23       	and	r28, r28
 83e:	19 f0       	breq	.+6      	; 0x846 <__DATA_REGION_LENGTH__+0x46>
 840:	c1 30       	cpi	r28, 0x01	; 1
 842:	61 f0       	breq	.+24     	; 0x85c <__DATA_REGION_LENGTH__+0x5c>
 844:	15 c0       	rjmp	.+42     	; 0x870 <__stack+0x11>
		{
			case DC_CW:
			DIO_SetPinValue(DC_Motor_Port, DC_Motor2_A3, DC_HIGH);
 846:	41 e0       	ldi	r20, 0x01	; 1
 848:	62 e0       	ldi	r22, 0x02	; 2
 84a:	82 e0       	ldi	r24, 0x02	; 2
 84c:	0e 94 bc 02 	call	0x578	; 0x578 <DIO_SetPinValue>
			DIO_SetPinValue(DC_Motor_Port, DC_Motor2_A4, DC_LOW);
 850:	40 e0       	ldi	r20, 0x00	; 0
 852:	62 e0       	ldi	r22, 0x02	; 2
 854:	82 e0       	ldi	r24, 0x02	; 2
 856:	0e 94 bc 02 	call	0x578	; 0x578 <DIO_SetPinValue>
			break;
 85a:	0a c0       	rjmp	.+20     	; 0x870 <__stack+0x11>
			case DC_CCW:
			DIO_SetPinValue(DC_Motor_Port, DC_Motor2_A3, DC_LOW);
 85c:	40 e0       	ldi	r20, 0x00	; 0
 85e:	62 e0       	ldi	r22, 0x02	; 2
 860:	82 e0       	ldi	r24, 0x02	; 2
 862:	0e 94 bc 02 	call	0x578	; 0x578 <DIO_SetPinValue>
			DIO_SetPinValue(DC_Motor_Port, DC_Motor2_A4, DC_HIGH);
 866:	41 e0       	ldi	r20, 0x01	; 1
 868:	62 e0       	ldi	r22, 0x02	; 2
 86a:	82 e0       	ldi	r24, 0x02	; 2
 86c:	0e 94 bc 02 	call	0x578	; 0x578 <DIO_SetPinValue>
			break;
		}
		break;
	}
}
 870:	cf 91       	pop	r28
 872:	1f 91       	pop	r17
 874:	0f 91       	pop	r16
 876:	08 95       	ret

Disassembly of section .text.DC_Stop:

00000a6a <DC_Stop>:

void DC_Stop(dc_motor motor)
{
	switch(motor)
 a6a:	88 23       	and	r24, r24
 a6c:	19 f0       	breq	.+6      	; 0xa74 <DC_Stop+0xa>
 a6e:	81 30       	cpi	r24, 0x01	; 1
 a70:	91 f0       	breq	.+36     	; 0xa96 <DC_Stop+0x2c>
 a72:	08 95       	ret
	{
		case DC_Motor1:
		OCR0 = 0;
 a74:	1c be       	out	0x3c, r1	; 60
		DIO_SetPinValue(DC_Enable_Port, DC_Enable1_Pin, DC_LOW);
 a76:	40 e0       	ldi	r20, 0x00	; 0
 a78:	63 e0       	ldi	r22, 0x03	; 3
 a7a:	81 e0       	ldi	r24, 0x01	; 1
 a7c:	0e 94 bc 02 	call	0x578	; 0x578 <DIO_SetPinValue>
		DIO_SetPinValue(DC_Motor_Port, DC_Motor1_A1, DC_LOW);
 a80:	40 e0       	ldi	r20, 0x00	; 0
 a82:	61 e0       	ldi	r22, 0x01	; 1
 a84:	82 e0       	ldi	r24, 0x02	; 2
 a86:	0e 94 bc 02 	call	0x578	; 0x578 <DIO_SetPinValue>
		DIO_SetPinValue(DC_Motor_Port, DC_Motor1_A2, DC_LOW);
 a8a:	40 e0       	ldi	r20, 0x00	; 0
 a8c:	62 e0       	ldi	r22, 0x02	; 2
 a8e:	82 e0       	ldi	r24, 0x02	; 2
 a90:	0e 94 bc 02 	call	0x578	; 0x578 <DIO_SetPinValue>
		break;
 a94:	08 95       	ret
		case DC_Motor2:
		DIO_SetPinValue(DC_Enable_Port, DC_Enable2_Pin, DC_LOW);
 a96:	40 e0       	ldi	r20, 0x00	; 0
 a98:	62 e0       	ldi	r22, 0x02	; 2
 a9a:	81 e0       	ldi	r24, 0x01	; 1
 a9c:	0e 94 bc 02 	call	0x578	; 0x578 <DIO_SetPinValue>
		DIO_SetPinValue(DC_Motor_Port, DC_Motor2_A3, DC_LOW);
 aa0:	40 e0       	ldi	r20, 0x00	; 0
 aa2:	62 e0       	ldi	r22, 0x02	; 2
 aa4:	82 e0       	ldi	r24, 0x02	; 2
 aa6:	0e 94 bc 02 	call	0x578	; 0x578 <DIO_SetPinValue>
		DIO_SetPinValue(DC_Motor_Port, DC_Motor2_A4, DC_LOW);
 aaa:	40 e0       	ldi	r20, 0x00	; 0
 aac:	62 e0       	ldi	r22, 0x02	; 2
 aae:	82 e0       	ldi	r24, 0x02	; 2
 ab0:	0e 94 bc 02 	call	0x578	; 0x578 <DIO_SetPinValue>
 ab4:	08 95       	ret

Disassembly of section .text.DC_Change_Speed:

00000c58 <DC_Change_Speed>:
		break;
	}
}

void DC_Change_Speed(dc_motor motor,uint16_t speed)
{	switch (motor){
 c58:	88 23       	and	r24, r24
 c5a:	19 f0       	breq	.+6      	; 0xc62 <DC_Change_Speed+0xa>
 c5c:	81 30       	cpi	r24, 0x01	; 1
 c5e:	61 f0       	breq	.+24     	; 0xc78 <DC_Change_Speed+0x20>
 c60:	08 95       	ret
		case DC_Motor1:
			OCR0 =(speed *250)/ 1024;
 c62:	2a ef       	ldi	r18, 0xFA	; 250
 c64:	26 9f       	mul	r18, r22
 c66:	c0 01       	movw	r24, r0
 c68:	27 9f       	mul	r18, r23
 c6a:	90 0d       	add	r25, r0
 c6c:	11 24       	eor	r1, r1
 c6e:	89 2f       	mov	r24, r25
 c70:	86 95       	lsr	r24
 c72:	86 95       	lsr	r24
 c74:	8c bf       	out	0x3c, r24	; 60
		break;
 c76:	08 95       	ret
		case DC_Motor2:
			OCR1A = speed/4;
 c78:	76 95       	lsr	r23
 c7a:	67 95       	ror	r22
 c7c:	76 95       	lsr	r23
 c7e:	67 95       	ror	r22
 c80:	7b bd       	out	0x2b, r23	; 43
 c82:	6a bd       	out	0x2a, r22	; 42
 c84:	08 95       	ret

Disassembly of section .text.ServoMotor_Initialize:

00000cb4 <ServoMotor_Initialize>:

#include "Servo_Private.h"

void ServoMotor_Initialize(void)
{
	DIO_SetPinDirection(SERVO_PORT, SERVO_PIN, DIO_OUTPUT);
 cb4:	82 b3       	in	r24, 0x12	; 18
 cb6:	41 e0       	ldi	r20, 0x01	; 1
 cb8:	65 e0       	ldi	r22, 0x05	; 5
 cba:	0e 94 4b 02 	call	0x496	; 0x496 <DIO_SetPinDirection>
	
	//ICR1 = 2499;		/* Set TOP count for timer1 in ICR1 register */

	/* Set Fast PWM, TOP in ICR1, Clear OC1A on compare match, clk/64 */
	TCCR1A = (1<<WGM11)|(1<<COM1A1);
 cbe:	82 e8       	ldi	r24, 0x82	; 130
 cc0:	8f bd       	out	0x2f, r24	; 47
	TCCR1B = (1<<WGM12)|(1<<WGM13)|(1<<CS10)|(1<<CS11);
 cc2:	8b e1       	ldi	r24, 0x1B	; 27
 cc4:	8e bd       	out	0x2e, r24	; 46
	sei();  // Enable global interrupts
 cc6:	78 94       	sei
	TCNT1 = 0;			/* Set timer1 count zero */
 cc8:	1d bc       	out	0x2d, r1	; 45
 cca:	1c bc       	out	0x2c, r1	; 44
	ICR1 = 19999;  // Set top value for 20 ms period (50Hz)
 ccc:	8f e1       	ldi	r24, 0x1F	; 31
 cce:	9e e4       	ldi	r25, 0x4E	; 78
 cd0:	97 bd       	out	0x27, r25	; 39
 cd2:	86 bd       	out	0x26, r24	; 38
 cd4:	08 95       	ret

Disassembly of section .text.ServoMotor_Rotate:

00000cec <ServoMotor_Rotate>:
}

void ServoMotor_Rotate(uint8_t angle)
{
	// Map the angle (0-180) to the required pulse width (1000-2000 us)
	uint16_t pulse_width = (angle * 11) + 1000;
 cec:	2b e0       	ldi	r18, 0x0B	; 11
 cee:	82 9f       	mul	r24, r18
 cf0:	c0 01       	movw	r24, r0
 cf2:	11 24       	eor	r1, r1
 cf4:	88 51       	subi	r24, 0x18	; 24
 cf6:	9c 4f       	sbci	r25, 0xFC	; 252
	
	// Set the pulse width to control the position of the servo
	OCR1A = pulse_width;
 cf8:	9b bd       	out	0x2b, r25	; 43
 cfa:	8a bd       	out	0x2a, r24	; 42
 cfc:	08 95       	ret

Disassembly of section .text.main:

00000966 <main>:
extern volatile E2PROM_State currentState;
extern uint16_t speed;

int main(void)
{	
	App_Init();
 966:	0e 94 e2 04 	call	0x9c4	; 0x9c4 <App_Init>
	
	/*	Main	Code	*/
    while(1)
    {	
		/* Recieve the message (Temperature)	*/
		UART_Receive_Word(&UART_Rdata);
 96a:	86 e8       	ldi	r24, 0x86	; 134
 96c:	90 e0       	ldi	r25, 0x00	; 0
 96e:	0e 94 81 05 	call	0xb02	; 0xb02 <UART_Receive_Word>
		
		speed=ADC_Read(POT1_PIN);
 972:	80 e0       	ldi	r24, 0x00	; 0
 974:	0e 94 79 04 	call	0x8f2	; 0x8f2 <ADC_Read>
 978:	90 93 85 00 	sts	0x0085, r25	; 0x800085 <speed+0x1>
 97c:	80 93 84 00 	sts	0x0084, r24	; 0x800084 <speed>
		if(Off_Mes==UART_Rdata){
 980:	80 91 86 00 	lds	r24, 0x0086	; 0x800086 <UART_Rdata>
 984:	90 91 87 00 	lds	r25, 0x0087	; 0x800087 <UART_Rdata+0x1>
 988:	8f 3f       	cpi	r24, 0xFF	; 255
 98a:	91 05       	cpc	r25, r1
 98c:	21 f4       	brne	.+8      	; 0x996 <main+0x30>
			speed=0;
 98e:	10 92 85 00 	sts	0x0085, r1	; 0x800085 <speed+0x1>
 992:	10 92 84 00 	sts	0x0084, r1	; 0x800084 <speed>
		}
		DC_Change_Speed(DC_mach1,speed);
 996:	60 91 84 00 	lds	r22, 0x0084	; 0x800084 <speed>
 99a:	70 91 85 00 	lds	r23, 0x0085	; 0x800085 <speed+0x1>
 99e:	80 91 93 00 	lds	r24, 0x0093	; 0x800093 <DC_mach1>
 9a2:	0e 94 2c 06 	call	0xc58	; 0xc58 <DC_Change_Speed>
		//Send the message (Speed)	
		UART_Transmit_Speed(speed);
		*/
		
		/* Handle the message	*/
		handle_Mes(UART_Rdata,DC_mach1,speed,&currentState);
 9a6:	40 91 84 00 	lds	r20, 0x0084	; 0x800084 <speed>
 9aa:	50 91 85 00 	lds	r21, 0x0085	; 0x800085 <speed+0x1>
 9ae:	22 e9       	ldi	r18, 0x92	; 146
 9b0:	30 e0       	ldi	r19, 0x00	; 0
 9b2:	60 91 93 00 	lds	r22, 0x0093	; 0x800093 <DC_mach1>
 9b6:	80 91 86 00 	lds	r24, 0x0086	; 0x800086 <UART_Rdata>
 9ba:	90 91 87 00 	lds	r25, 0x0087	; 0x800087 <UART_Rdata+0x1>
 9be:	0e 94 21 01 	call	0x242	; 0x242 <handle_Mes>
    }
 9c2:	d3 cf       	rjmp	.-90     	; 0x96a <main+0x4>

Disassembly of section .text.ADC_Initialize:

00000d0e <ADC_Initialize>:

#include "ADC_Private.h"

void ADC_Initialize(adc_vref voltage , adc_prescaler prescaler)
{
	ADMUX |= 0x40;
 d0e:	87 b1       	in	r24, 0x07	; 7
 d10:	80 64       	ori	r24, 0x40	; 64
 d12:	87 b9       	out	0x07, r24	; 7
	ADCSRA |= 0xA7;
 d14:	86 b1       	in	r24, 0x06	; 6
 d16:	87 6a       	ori	r24, 0xA7	; 167
 d18:	86 b9       	out	0x06, r24	; 6
 d1a:	08 95       	ret

Disassembly of section .text.ADC_Read:

000008f2 <ADC_Read>:
}

uint16_t ADC_Read(adc_channel channel)
{
 8f2:	e8 2f       	mov	r30, r24
	uint16_t val = 0;

	// Clear the ADC result register by reading it once
	uint16_t dummy = ADC_VAL;
 8f4:	84 b1       	in	r24, 0x04	; 4
 8f6:	95 b1       	in	r25, 0x05	; 5
 
	// Select the ADC channel
	switch (channel)
 8f8:	8e 2f       	mov	r24, r30
 8fa:	90 e0       	ldi	r25, 0x00	; 0
 8fc:	88 30       	cpi	r24, 0x08	; 8
 8fe:	91 05       	cpc	r25, r1
 900:	50 f5       	brcc	.+84     	; 0x956 <ADC_Read+0x64>
 902:	fc 01       	movw	r30, r24
 904:	e6 5d       	subi	r30, 0xD6	; 214
 906:	ff 4f       	sbci	r31, 0xFF	; 255
 908:	0c 94 dd 06 	jmp	0xdba	; 0xdba <__tablejump2__>
	{
		case ADC_0:
		ADMUX = (ADMUX & 0xF8) | 0x00; // Clear the channel bits and set ADC0
 90c:	87 b1       	in	r24, 0x07	; 7
 90e:	88 7f       	andi	r24, 0xF8	; 248
 910:	87 b9       	out	0x07, r24	; 7
		break;
 912:	21 c0       	rjmp	.+66     	; 0x956 <ADC_Read+0x64>
		case ADC_1:
		ADMUX = (ADMUX & 0xF8) | 0x01; // Clear the channel bits and set ADC1
 914:	87 b1       	in	r24, 0x07	; 7
 916:	88 7f       	andi	r24, 0xF8	; 248
 918:	81 60       	ori	r24, 0x01	; 1
 91a:	87 b9       	out	0x07, r24	; 7
		break;
 91c:	1c c0       	rjmp	.+56     	; 0x956 <ADC_Read+0x64>
		case ADC_2:
		ADMUX = (ADMUX & 0xF8) | 0x02; // Clear the channel bits and set ADC2
 91e:	87 b1       	in	r24, 0x07	; 7
 920:	88 7f       	andi	r24, 0xF8	; 248
 922:	82 60       	ori	r24, 0x02	; 2
 924:	87 b9       	out	0x07, r24	; 7
		break;
 926:	17 c0       	rjmp	.+46     	; 0x956 <ADC_Read+0x64>
		case ADC_3:
		ADMUX = (ADMUX & 0xF8) | 0x03; // Clear the channel bits and set ADC3
 928:	87 b1       	in	r24, 0x07	; 7
 92a:	88 7f       	andi	r24, 0xF8	; 248
 92c:	83 60       	ori	r24, 0x03	; 3
 92e:	87 b9       	out	0x07, r24	; 7
		break;
 930:	12 c0       	rjmp	.+36     	; 0x956 <ADC_Read+0x64>
		case ADC_4:
		ADMUX = (ADMUX & 0xF8) | 0x04; // Clear the channel bits and set ADC4
 932:	87 b1       	in	r24, 0x07	; 7
 934:	88 7f       	andi	r24, 0xF8	; 248
 936:	84 60       	ori	r24, 0x04	; 4
 938:	87 b9       	out	0x07, r24	; 7
		break;
 93a:	0d c0       	rjmp	.+26     	; 0x956 <ADC_Read+0x64>
		case ADC_5:
		ADMUX = (ADMUX & 0xF8) | 0x05; // Clear the channel bits and set ADC5
 93c:	87 b1       	in	r24, 0x07	; 7
 93e:	88 7f       	andi	r24, 0xF8	; 248
 940:	85 60       	ori	r24, 0x05	; 5
 942:	87 b9       	out	0x07, r24	; 7
		break;
 944:	08 c0       	rjmp	.+16     	; 0x956 <ADC_Read+0x64>
		case ADC_6:
		ADMUX = (ADMUX & 0xF8) | 0x06; // Clear the channel bits and set ADC6
 946:	87 b1       	in	r24, 0x07	; 7
 948:	88 7f       	andi	r24, 0xF8	; 248
 94a:	86 60       	ori	r24, 0x06	; 6
 94c:	87 b9       	out	0x07, r24	; 7
		break;
 94e:	03 c0       	rjmp	.+6      	; 0x956 <ADC_Read+0x64>
		case ADC_7:
		ADMUX = (ADMUX & 0xF8) | 0x07; // Clear the channel bits and set ADC7
 950:	87 b1       	in	r24, 0x07	; 7
 952:	87 60       	ori	r24, 0x07	; 7
 954:	87 b9       	out	0x07, r24	; 7
		break;
	}

	// Start ADC conversion
	ADCSRA |= (1 << ADSC);
 956:	86 b1       	in	r24, 0x06	; 6
 958:	80 64       	ori	r24, 0x40	; 64
 95a:	86 b9       	out	0x06, r24	; 6

	// Wait for conversion to complete
	while (ADCSRA & (1 << ADSC));
 95c:	36 99       	sbic	0x06, 6	; 6
 95e:	fe cf       	rjmp	.-4      	; 0x95c <ADC_Read+0x6a>

	// Read the converted value
	val = ADC_VAL;
 960:	84 b1       	in	r24, 0x04	; 4
 962:	95 b1       	in	r25, 0x05	; 5

	return val;
}
 964:	08 95       	ret

Disassembly of section .text.DIO_SetPinDirection:

00000496 <DIO_SetPinDirection>:
#include "DIO_Private.h"

/*------------------------PINS---------------------------*/
void DIO_SetPinDirection(port Port, pin Pin, state State)
{
	switch(State)
 496:	44 23       	and	r20, r20
 498:	19 f0       	breq	.+6      	; 0x4a0 <DIO_SetPinDirection+0xa>
 49a:	41 30       	cpi	r20, 0x01	; 1
 49c:	c9 f1       	breq	.+114    	; 0x510 <DIO_SetPinDirection+0x7a>
 49e:	08 95       	ret
	{
		case DIO_INPUT:
		switch (Port)
 4a0:	81 30       	cpi	r24, 0x01	; 1
 4a2:	91 f0       	breq	.+36     	; 0x4c8 <DIO_SetPinDirection+0x32>
 4a4:	28 f0       	brcs	.+10     	; 0x4b0 <DIO_SetPinDirection+0x1a>
 4a6:	82 30       	cpi	r24, 0x02	; 2
 4a8:	d9 f0       	breq	.+54     	; 0x4e0 <DIO_SetPinDirection+0x4a>
 4aa:	83 30       	cpi	r24, 0x03	; 3
 4ac:	29 f1       	breq	.+74     	; 0x4f8 <DIO_SetPinDirection+0x62>
 4ae:	08 95       	ret
		{
			case DIO_PORTA:
			CLR_BIT(DDRA, Pin);
 4b0:	2a b3       	in	r18, 0x1a	; 26
 4b2:	81 e0       	ldi	r24, 0x01	; 1
 4b4:	90 e0       	ldi	r25, 0x00	; 0
 4b6:	02 c0       	rjmp	.+4      	; 0x4bc <DIO_SetPinDirection+0x26>
 4b8:	88 0f       	add	r24, r24
 4ba:	99 1f       	adc	r25, r25
 4bc:	6a 95       	dec	r22
 4be:	e2 f7       	brpl	.-8      	; 0x4b8 <DIO_SetPinDirection+0x22>
 4c0:	80 95       	com	r24
 4c2:	82 23       	and	r24, r18
 4c4:	8a bb       	out	0x1a, r24	; 26
			break;
 4c6:	08 95       	ret
			case DIO_PORTB:
			CLR_BIT(DDRB, Pin);
 4c8:	27 b3       	in	r18, 0x17	; 23
 4ca:	81 e0       	ldi	r24, 0x01	; 1
 4cc:	90 e0       	ldi	r25, 0x00	; 0
 4ce:	02 c0       	rjmp	.+4      	; 0x4d4 <DIO_SetPinDirection+0x3e>
 4d0:	88 0f       	add	r24, r24
 4d2:	99 1f       	adc	r25, r25
 4d4:	6a 95       	dec	r22
 4d6:	e2 f7       	brpl	.-8      	; 0x4d0 <DIO_SetPinDirection+0x3a>
 4d8:	80 95       	com	r24
 4da:	82 23       	and	r24, r18
 4dc:	87 bb       	out	0x17, r24	; 23
			break;
 4de:	08 95       	ret
			case DIO_PORTC:
			CLR_BIT(DDRC, Pin);
 4e0:	24 b3       	in	r18, 0x14	; 20
 4e2:	81 e0       	ldi	r24, 0x01	; 1
 4e4:	90 e0       	ldi	r25, 0x00	; 0
 4e6:	02 c0       	rjmp	.+4      	; 0x4ec <DIO_SetPinDirection+0x56>
 4e8:	88 0f       	add	r24, r24
 4ea:	99 1f       	adc	r25, r25
 4ec:	6a 95       	dec	r22
 4ee:	e2 f7       	brpl	.-8      	; 0x4e8 <DIO_SetPinDirection+0x52>
 4f0:	80 95       	com	r24
 4f2:	82 23       	and	r24, r18
 4f4:	84 bb       	out	0x14, r24	; 20
			break;
 4f6:	08 95       	ret
			case DIO_PORTD:
			CLR_BIT(DDRD, Pin);
 4f8:	21 b3       	in	r18, 0x11	; 17
 4fa:	81 e0       	ldi	r24, 0x01	; 1
 4fc:	90 e0       	ldi	r25, 0x00	; 0
 4fe:	02 c0       	rjmp	.+4      	; 0x504 <DIO_SetPinDirection+0x6e>
 500:	88 0f       	add	r24, r24
 502:	99 1f       	adc	r25, r25
 504:	6a 95       	dec	r22
 506:	e2 f7       	brpl	.-8      	; 0x500 <DIO_SetPinDirection+0x6a>
 508:	80 95       	com	r24
 50a:	82 23       	and	r24, r18
 50c:	81 bb       	out	0x11, r24	; 17
			break;
 50e:	08 95       	ret
		}
		break;
		case DIO_OUTPUT:
		switch (Port)
 510:	81 30       	cpi	r24, 0x01	; 1
 512:	89 f0       	breq	.+34     	; 0x536 <DIO_SetPinDirection+0xa0>
 514:	28 f0       	brcs	.+10     	; 0x520 <DIO_SetPinDirection+0x8a>
 516:	82 30       	cpi	r24, 0x02	; 2
 518:	c9 f0       	breq	.+50     	; 0x54c <DIO_SetPinDirection+0xb6>
 51a:	83 30       	cpi	r24, 0x03	; 3
 51c:	11 f1       	breq	.+68     	; 0x562 <DIO_SetPinDirection+0xcc>
 51e:	08 95       	ret
		{
			case DIO_PORTA:
			SET_BIT(DDRA, Pin);
 520:	2a b3       	in	r18, 0x1a	; 26
 522:	81 e0       	ldi	r24, 0x01	; 1
 524:	90 e0       	ldi	r25, 0x00	; 0
 526:	02 c0       	rjmp	.+4      	; 0x52c <DIO_SetPinDirection+0x96>
 528:	88 0f       	add	r24, r24
 52a:	99 1f       	adc	r25, r25
 52c:	6a 95       	dec	r22
 52e:	e2 f7       	brpl	.-8      	; 0x528 <DIO_SetPinDirection+0x92>
 530:	82 2b       	or	r24, r18
 532:	8a bb       	out	0x1a, r24	; 26
			break;
 534:	08 95       	ret
			case DIO_PORTB:
			SET_BIT(DDRB, Pin);
 536:	27 b3       	in	r18, 0x17	; 23
 538:	81 e0       	ldi	r24, 0x01	; 1
 53a:	90 e0       	ldi	r25, 0x00	; 0
 53c:	02 c0       	rjmp	.+4      	; 0x542 <DIO_SetPinDirection+0xac>
 53e:	88 0f       	add	r24, r24
 540:	99 1f       	adc	r25, r25
 542:	6a 95       	dec	r22
 544:	e2 f7       	brpl	.-8      	; 0x53e <DIO_SetPinDirection+0xa8>
 546:	82 2b       	or	r24, r18
 548:	87 bb       	out	0x17, r24	; 23
			break;
 54a:	08 95       	ret
			case DIO_PORTC:
			SET_BIT(DDRC, Pin);
 54c:	24 b3       	in	r18, 0x14	; 20
 54e:	81 e0       	ldi	r24, 0x01	; 1
 550:	90 e0       	ldi	r25, 0x00	; 0
 552:	02 c0       	rjmp	.+4      	; 0x558 <DIO_SetPinDirection+0xc2>
 554:	88 0f       	add	r24, r24
 556:	99 1f       	adc	r25, r25
 558:	6a 95       	dec	r22
 55a:	e2 f7       	brpl	.-8      	; 0x554 <DIO_SetPinDirection+0xbe>
 55c:	82 2b       	or	r24, r18
 55e:	84 bb       	out	0x14, r24	; 20
			break;
 560:	08 95       	ret
			case DIO_PORTD:
			SET_BIT(DDRD, Pin);
 562:	21 b3       	in	r18, 0x11	; 17
 564:	81 e0       	ldi	r24, 0x01	; 1
 566:	90 e0       	ldi	r25, 0x00	; 0
 568:	02 c0       	rjmp	.+4      	; 0x56e <DIO_SetPinDirection+0xd8>
 56a:	88 0f       	add	r24, r24
 56c:	99 1f       	adc	r25, r25
 56e:	6a 95       	dec	r22
 570:	e2 f7       	brpl	.-8      	; 0x56a <DIO_SetPinDirection+0xd4>
 572:	82 2b       	or	r24, r18
 574:	81 bb       	out	0x11, r24	; 17
 576:	08 95       	ret

Disassembly of section .text.DIO_SetPinValue:

00000578 <DIO_SetPinValue>:
		break;
	}
}
void DIO_SetPinValue(port Port, pin Pin, status Status)
{
	switch(Status)
 578:	44 23       	and	r20, r20
 57a:	19 f0       	breq	.+6      	; 0x582 <DIO_SetPinValue+0xa>
 57c:	41 30       	cpi	r20, 0x01	; 1
 57e:	c9 f1       	breq	.+114    	; 0x5f2 <DIO_SetPinValue+0x7a>
 580:	08 95       	ret
	{
		case DIO_LOW:
		switch (Port)
 582:	81 30       	cpi	r24, 0x01	; 1
 584:	91 f0       	breq	.+36     	; 0x5aa <DIO_SetPinValue+0x32>
 586:	28 f0       	brcs	.+10     	; 0x592 <DIO_SetPinValue+0x1a>
 588:	82 30       	cpi	r24, 0x02	; 2
 58a:	d9 f0       	breq	.+54     	; 0x5c2 <DIO_SetPinValue+0x4a>
 58c:	83 30       	cpi	r24, 0x03	; 3
 58e:	29 f1       	breq	.+74     	; 0x5da <DIO_SetPinValue+0x62>
 590:	08 95       	ret
		{
			case DIO_PORTA:
			CLR_BIT(PORTA, Pin);
 592:	2b b3       	in	r18, 0x1b	; 27
 594:	81 e0       	ldi	r24, 0x01	; 1
 596:	90 e0       	ldi	r25, 0x00	; 0
 598:	02 c0       	rjmp	.+4      	; 0x59e <DIO_SetPinValue+0x26>
 59a:	88 0f       	add	r24, r24
 59c:	99 1f       	adc	r25, r25
 59e:	6a 95       	dec	r22
 5a0:	e2 f7       	brpl	.-8      	; 0x59a <DIO_SetPinValue+0x22>
 5a2:	80 95       	com	r24
 5a4:	82 23       	and	r24, r18
 5a6:	8b bb       	out	0x1b, r24	; 27
			break;
 5a8:	08 95       	ret
			case DIO_PORTB:
			CLR_BIT(PORTB, Pin);
 5aa:	28 b3       	in	r18, 0x18	; 24
 5ac:	81 e0       	ldi	r24, 0x01	; 1
 5ae:	90 e0       	ldi	r25, 0x00	; 0
 5b0:	02 c0       	rjmp	.+4      	; 0x5b6 <DIO_SetPinValue+0x3e>
 5b2:	88 0f       	add	r24, r24
 5b4:	99 1f       	adc	r25, r25
 5b6:	6a 95       	dec	r22
 5b8:	e2 f7       	brpl	.-8      	; 0x5b2 <DIO_SetPinValue+0x3a>
 5ba:	80 95       	com	r24
 5bc:	82 23       	and	r24, r18
 5be:	88 bb       	out	0x18, r24	; 24
			break;
 5c0:	08 95       	ret
			case DIO_PORTC:
			CLR_BIT(PORTC, Pin);
 5c2:	25 b3       	in	r18, 0x15	; 21
 5c4:	81 e0       	ldi	r24, 0x01	; 1
 5c6:	90 e0       	ldi	r25, 0x00	; 0
 5c8:	02 c0       	rjmp	.+4      	; 0x5ce <DIO_SetPinValue+0x56>
 5ca:	88 0f       	add	r24, r24
 5cc:	99 1f       	adc	r25, r25
 5ce:	6a 95       	dec	r22
 5d0:	e2 f7       	brpl	.-8      	; 0x5ca <DIO_SetPinValue+0x52>
 5d2:	80 95       	com	r24
 5d4:	82 23       	and	r24, r18
 5d6:	85 bb       	out	0x15, r24	; 21
			break;
 5d8:	08 95       	ret
			case DIO_PORTD:
			CLR_BIT(PORTD, Pin);
 5da:	22 b3       	in	r18, 0x12	; 18
 5dc:	81 e0       	ldi	r24, 0x01	; 1
 5de:	90 e0       	ldi	r25, 0x00	; 0
 5e0:	02 c0       	rjmp	.+4      	; 0x5e6 <DIO_SetPinValue+0x6e>
 5e2:	88 0f       	add	r24, r24
 5e4:	99 1f       	adc	r25, r25
 5e6:	6a 95       	dec	r22
 5e8:	e2 f7       	brpl	.-8      	; 0x5e2 <DIO_SetPinValue+0x6a>
 5ea:	80 95       	com	r24
 5ec:	82 23       	and	r24, r18
 5ee:	82 bb       	out	0x12, r24	; 18
			break;
 5f0:	08 95       	ret
		}
		break;
		case DIO_HIGH:
		switch (Port)
 5f2:	81 30       	cpi	r24, 0x01	; 1
 5f4:	89 f0       	breq	.+34     	; 0x618 <DIO_SetPinValue+0xa0>
 5f6:	28 f0       	brcs	.+10     	; 0x602 <DIO_SetPinValue+0x8a>
 5f8:	82 30       	cpi	r24, 0x02	; 2
 5fa:	c9 f0       	breq	.+50     	; 0x62e <DIO_SetPinValue+0xb6>
 5fc:	83 30       	cpi	r24, 0x03	; 3
 5fe:	11 f1       	breq	.+68     	; 0x644 <DIO_SetPinValue+0xcc>
 600:	08 95       	ret
		{
			case DIO_PORTA:
			SET_BIT(PORTA, Pin);
 602:	2b b3       	in	r18, 0x1b	; 27
 604:	81 e0       	ldi	r24, 0x01	; 1
 606:	90 e0       	ldi	r25, 0x00	; 0
 608:	02 c0       	rjmp	.+4      	; 0x60e <DIO_SetPinValue+0x96>
 60a:	88 0f       	add	r24, r24
 60c:	99 1f       	adc	r25, r25
 60e:	6a 95       	dec	r22
 610:	e2 f7       	brpl	.-8      	; 0x60a <DIO_SetPinValue+0x92>
 612:	82 2b       	or	r24, r18
 614:	8b bb       	out	0x1b, r24	; 27
			break;
 616:	08 95       	ret
			case DIO_PORTB:
			SET_BIT(PORTB, Pin);
 618:	28 b3       	in	r18, 0x18	; 24
 61a:	81 e0       	ldi	r24, 0x01	; 1
 61c:	90 e0       	ldi	r25, 0x00	; 0
 61e:	02 c0       	rjmp	.+4      	; 0x624 <DIO_SetPinValue+0xac>
 620:	88 0f       	add	r24, r24
 622:	99 1f       	adc	r25, r25
 624:	6a 95       	dec	r22
 626:	e2 f7       	brpl	.-8      	; 0x620 <DIO_SetPinValue+0xa8>
 628:	82 2b       	or	r24, r18
 62a:	88 bb       	out	0x18, r24	; 24
			break;
 62c:	08 95       	ret
			case DIO_PORTC:
			SET_BIT(PORTC, Pin);
 62e:	25 b3       	in	r18, 0x15	; 21
 630:	81 e0       	ldi	r24, 0x01	; 1
 632:	90 e0       	ldi	r25, 0x00	; 0
 634:	02 c0       	rjmp	.+4      	; 0x63a <DIO_SetPinValue+0xc2>
 636:	88 0f       	add	r24, r24
 638:	99 1f       	adc	r25, r25
 63a:	6a 95       	dec	r22
 63c:	e2 f7       	brpl	.-8      	; 0x636 <DIO_SetPinValue+0xbe>
 63e:	82 2b       	or	r24, r18
 640:	85 bb       	out	0x15, r24	; 21
			break;
 642:	08 95       	ret
			case DIO_PORTD:
			SET_BIT(PORTD, Pin);
 644:	22 b3       	in	r18, 0x12	; 18
 646:	81 e0       	ldi	r24, 0x01	; 1
 648:	90 e0       	ldi	r25, 0x00	; 0
 64a:	02 c0       	rjmp	.+4      	; 0x650 <DIO_SetPinValue+0xd8>
 64c:	88 0f       	add	r24, r24
 64e:	99 1f       	adc	r25, r25
 650:	6a 95       	dec	r22
 652:	e2 f7       	brpl	.-8      	; 0x64c <DIO_SetPinValue+0xd4>
 654:	82 2b       	or	r24, r18
 656:	82 bb       	out	0x12, r24	; 18
 658:	08 95       	ret

Disassembly of section .text.UART_Initialize_WithoutInterrupt:

00000376 <UART_Initialize_WithoutInterrupt>:
	uint8_t low_byte = data & 0xFF;
	uart_status s=UART_Transmit_Character(high_byte);
	s|= UART_Transmit_Character(low_byte);
	return s;

}
 376:	0f 93       	push	r16
 378:	31 b3       	in	r19, 0x11	; 17
 37a:	32 60       	ori	r19, 0x02	; 2
 37c:	31 bb       	out	0x11, r19	; 17
 37e:	31 b3       	in	r19, 0x11	; 17
 380:	3e 7f       	andi	r19, 0xFE	; 254
 382:	31 bb       	out	0x11, r19	; 17
 384:	3a b1       	in	r19, 0x0a	; 10
 386:	38 61       	ori	r19, 0x18	; 24
 388:	3a b9       	out	0x0a, r19	; 10
 38a:	66 23       	and	r22, r22
 38c:	19 f0       	breq	.+6      	; 0x394 <UART_Initialize_WithoutInterrupt+0x1e>
 38e:	61 30       	cpi	r22, 0x01	; 1
 390:	29 f0       	breq	.+10     	; 0x39c <UART_Initialize_WithoutInterrupt+0x26>
 392:	07 c0       	rjmp	.+14     	; 0x3a2 <UART_Initialize_WithoutInterrupt+0x2c>
 394:	30 b5       	in	r19, 0x20	; 32
 396:	3f 77       	andi	r19, 0x7F	; 127
 398:	30 bd       	out	0x20, r19	; 32
 39a:	03 c0       	rjmp	.+6      	; 0x3a2 <UART_Initialize_WithoutInterrupt+0x2c>
 39c:	30 b5       	in	r19, 0x20	; 32
 39e:	30 68       	ori	r19, 0x80	; 128
 3a0:	30 bd       	out	0x20, r19	; 32
 3a2:	22 30       	cpi	r18, 0x02	; 2
 3a4:	f9 f0       	breq	.+62     	; 0x3e4 <UART_Initialize_WithoutInterrupt+0x6e>
 3a6:	28 f4       	brcc	.+10     	; 0x3b2 <UART_Initialize_WithoutInterrupt+0x3c>
 3a8:	22 23       	and	r18, r18
 3aa:	41 f0       	breq	.+16     	; 0x3bc <UART_Initialize_WithoutInterrupt+0x46>
 3ac:	21 30       	cpi	r18, 0x01	; 1
 3ae:	81 f0       	breq	.+32     	; 0x3d0 <UART_Initialize_WithoutInterrupt+0x5a>
 3b0:	36 c0       	rjmp	.+108    	; 0x41e <__EEPROM_REGION_LENGTH__+0x1e>
 3b2:	23 30       	cpi	r18, 0x03	; 3
 3b4:	09 f1       	breq	.+66     	; 0x3f8 <UART_Initialize_WithoutInterrupt+0x82>
 3b6:	24 30       	cpi	r18, 0x04	; 4
 3b8:	49 f1       	breq	.+82     	; 0x40c <__EEPROM_REGION_LENGTH__+0xc>
 3ba:	31 c0       	rjmp	.+98     	; 0x41e <__EEPROM_REGION_LENGTH__+0x1e>
 3bc:	2a b1       	in	r18, 0x0a	; 10
 3be:	2b 7f       	andi	r18, 0xFB	; 251
 3c0:	2a b9       	out	0x0a, r18	; 10
 3c2:	20 b5       	in	r18, 0x20	; 32
 3c4:	2b 7f       	andi	r18, 0xFB	; 251
 3c6:	20 bd       	out	0x20, r18	; 32
 3c8:	20 b5       	in	r18, 0x20	; 32
 3ca:	2d 7f       	andi	r18, 0xFD	; 253
 3cc:	20 bd       	out	0x20, r18	; 32
 3ce:	27 c0       	rjmp	.+78     	; 0x41e <__EEPROM_REGION_LENGTH__+0x1e>
 3d0:	2a b1       	in	r18, 0x0a	; 10
 3d2:	2b 7f       	andi	r18, 0xFB	; 251
 3d4:	2a b9       	out	0x0a, r18	; 10
 3d6:	20 b5       	in	r18, 0x20	; 32
 3d8:	2b 7f       	andi	r18, 0xFB	; 251
 3da:	20 bd       	out	0x20, r18	; 32
 3dc:	20 b5       	in	r18, 0x20	; 32
 3de:	22 60       	ori	r18, 0x02	; 2
 3e0:	20 bd       	out	0x20, r18	; 32
 3e2:	1d c0       	rjmp	.+58     	; 0x41e <__EEPROM_REGION_LENGTH__+0x1e>
 3e4:	2a b1       	in	r18, 0x0a	; 10
 3e6:	2b 7f       	andi	r18, 0xFB	; 251
 3e8:	2a b9       	out	0x0a, r18	; 10
 3ea:	20 b5       	in	r18, 0x20	; 32
 3ec:	24 60       	ori	r18, 0x04	; 4
 3ee:	20 bd       	out	0x20, r18	; 32
 3f0:	20 b5       	in	r18, 0x20	; 32
 3f2:	2d 7f       	andi	r18, 0xFD	; 253
 3f4:	20 bd       	out	0x20, r18	; 32
 3f6:	13 c0       	rjmp	.+38     	; 0x41e <__EEPROM_REGION_LENGTH__+0x1e>
 3f8:	2a b1       	in	r18, 0x0a	; 10
 3fa:	2b 7f       	andi	r18, 0xFB	; 251
 3fc:	2a b9       	out	0x0a, r18	; 10
 3fe:	20 b5       	in	r18, 0x20	; 32
 400:	24 60       	ori	r18, 0x04	; 4
 402:	20 bd       	out	0x20, r18	; 32
 404:	20 b5       	in	r18, 0x20	; 32
 406:	22 60       	ori	r18, 0x02	; 2
 408:	20 bd       	out	0x20, r18	; 32
 40a:	09 c0       	rjmp	.+18     	; 0x41e <__EEPROM_REGION_LENGTH__+0x1e>
 40c:	2a b1       	in	r18, 0x0a	; 10
 40e:	24 60       	ori	r18, 0x04	; 4
 410:	2a b9       	out	0x0a, r18	; 10
 412:	20 b5       	in	r18, 0x20	; 32
 414:	24 60       	ori	r18, 0x04	; 4
 416:	20 bd       	out	0x20, r18	; 32
 418:	20 b5       	in	r18, 0x20	; 32
 41a:	22 60       	ori	r18, 0x02	; 2
 41c:	20 bd       	out	0x20, r18	; 32
 41e:	41 30       	cpi	r20, 0x01	; 1
 420:	59 f0       	breq	.+22     	; 0x438 <__EEPROM_REGION_LENGTH__+0x38>
 422:	18 f0       	brcs	.+6      	; 0x42a <__EEPROM_REGION_LENGTH__+0x2a>
 424:	42 30       	cpi	r20, 0x02	; 2
 426:	79 f0       	breq	.+30     	; 0x446 <__EEPROM_REGION_LENGTH__+0x46>
 428:	14 c0       	rjmp	.+40     	; 0x452 <__EEPROM_REGION_LENGTH__+0x52>
 42a:	20 b5       	in	r18, 0x20	; 32
 42c:	2f 7d       	andi	r18, 0xDF	; 223
 42e:	20 bd       	out	0x20, r18	; 32
 430:	20 b5       	in	r18, 0x20	; 32
 432:	2f 7e       	andi	r18, 0xEF	; 239
 434:	20 bd       	out	0x20, r18	; 32
 436:	0d c0       	rjmp	.+26     	; 0x452 <__EEPROM_REGION_LENGTH__+0x52>
 438:	20 b5       	in	r18, 0x20	; 32
 43a:	20 62       	ori	r18, 0x20	; 32
 43c:	20 bd       	out	0x20, r18	; 32
 43e:	20 b5       	in	r18, 0x20	; 32
 440:	2f 7e       	andi	r18, 0xEF	; 239
 442:	20 bd       	out	0x20, r18	; 32
 444:	06 c0       	rjmp	.+12     	; 0x452 <__EEPROM_REGION_LENGTH__+0x52>
 446:	20 b5       	in	r18, 0x20	; 32
 448:	20 62       	ori	r18, 0x20	; 32
 44a:	20 bd       	out	0x20, r18	; 32
 44c:	20 b5       	in	r18, 0x20	; 32
 44e:	20 61       	ori	r18, 0x10	; 16
 450:	20 bd       	out	0x20, r18	; 32
 452:	00 23       	and	r16, r16
 454:	19 f0       	breq	.+6      	; 0x45c <__EEPROM_REGION_LENGTH__+0x5c>
 456:	01 30       	cpi	r16, 0x01	; 1
 458:	29 f0       	breq	.+10     	; 0x464 <__EEPROM_REGION_LENGTH__+0x64>
 45a:	07 c0       	rjmp	.+14     	; 0x46a <__EEPROM_REGION_LENGTH__+0x6a>
 45c:	20 b5       	in	r18, 0x20	; 32
 45e:	27 7f       	andi	r18, 0xF7	; 247
 460:	20 bd       	out	0x20, r18	; 32
 462:	03 c0       	rjmp	.+6      	; 0x46a <__EEPROM_REGION_LENGTH__+0x6a>
 464:	20 b5       	in	r18, 0x20	; 32
 466:	28 60       	ori	r18, 0x08	; 8
 468:	20 bd       	out	0x20, r18	; 32
 46a:	9c 01       	movw	r18, r24
 46c:	22 95       	swap	r18
 46e:	32 95       	swap	r19
 470:	30 7f       	andi	r19, 0xF0	; 240
 472:	32 27       	eor	r19, r18
 474:	20 7f       	andi	r18, 0xF0	; 240
 476:	32 27       	eor	r19, r18
 478:	40 e0       	ldi	r20, 0x00	; 0
 47a:	50 e0       	ldi	r21, 0x00	; 0
 47c:	60 e0       	ldi	r22, 0x00	; 0
 47e:	71 e7       	ldi	r23, 0x71	; 113
 480:	82 e0       	ldi	r24, 0x02	; 2
 482:	90 e0       	ldi	r25, 0x00	; 0
 484:	0e 94 43 06 	call	0xc86	; 0xc86 <__divmodsi4>
 488:	21 50       	subi	r18, 0x01	; 1
 48a:	31 09       	sbc	r19, r1
 48c:	29 b9       	out	0x09, r18	; 9
 48e:	30 bd       	out	0x20, r19	; 32
 490:	81 e0       	ldi	r24, 0x01	; 1
 492:	0f 91       	pop	r16
 494:	08 95       	ret

Disassembly of section .text.UART_Receive_Character:

00000d1c <UART_Receive_Character>:
 d1c:	5f 9b       	sbis	0x0b, 7	; 11
 d1e:	fe cf       	rjmp	.-4      	; 0xd1c <UART_Receive_Character>
 d20:	2c b1       	in	r18, 0x0c	; 12
 d22:	fc 01       	movw	r30, r24
 d24:	20 83       	st	Z, r18
 d26:	81 e0       	ldi	r24, 0x01	; 1
 d28:	08 95       	ret

Disassembly of section .text.Reassemble_uint16:

00000dc6 <Reassemble_uint16>:
	*data=Reassemble_uint16(high_byte,low_byte);
	return s;
}

uint16_t Reassemble_uint16(uint8_t high_byte, uint8_t low_byte){
	return ((uint16_t)high_byte << 8) | low_byte;
 dc6:	90 e0       	ldi	r25, 0x00	; 0
 dc8:	98 2f       	mov	r25, r24
 dca:	88 27       	eor	r24, r24
}
 dcc:	86 2b       	or	r24, r22
 dce:	08 95       	ret

Disassembly of section .text.UART_Receive_Word:

00000b02 <UART_Receive_Word>:
	uint8_t low_byte = data & 0xFF;
	uart_status s=UART_Transmit_Character(high_byte);
	s|= UART_Transmit_Character(low_byte);
	return s;

}
 b02:	ef 92       	push	r14
 b04:	ff 92       	push	r15
 b06:	1f 93       	push	r17
 b08:	cf 93       	push	r28
 b0a:	df 93       	push	r29
 b0c:	00 d0       	rcall	.+0      	; 0xb0e <UART_Receive_Word+0xc>
 b0e:	cd b7       	in	r28, 0x3d	; 61
 b10:	de b7       	in	r29, 0x3e	; 62
 b12:	7c 01       	movw	r14, r24
 b14:	19 82       	std	Y+1, r1	; 0x01
 b16:	1a 82       	std	Y+2, r1	; 0x02
 b18:	ce 01       	movw	r24, r28
 b1a:	01 96       	adiw	r24, 0x01	; 1
 b1c:	0e 94 8e 06 	call	0xd1c	; 0xd1c <UART_Receive_Character>
 b20:	18 2f       	mov	r17, r24
 b22:	ce 01       	movw	r24, r28
 b24:	02 96       	adiw	r24, 0x02	; 2
 b26:	0e 94 8e 06 	call	0xd1c	; 0xd1c <UART_Receive_Character>
 b2a:	18 2b       	or	r17, r24
 b2c:	6a 81       	ldd	r22, Y+2	; 0x02
 b2e:	89 81       	ldd	r24, Y+1	; 0x01
 b30:	0e 94 e3 06 	call	0xdc6	; 0xdc6 <Reassemble_uint16>
 b34:	f7 01       	movw	r30, r14
 b36:	91 83       	std	Z+1, r25	; 0x01
 b38:	80 83       	st	Z, r24
 b3a:	81 2f       	mov	r24, r17
 b3c:	0f 90       	pop	r0
 b3e:	0f 90       	pop	r0
 b40:	df 91       	pop	r29
 b42:	cf 91       	pop	r28
 b44:	1f 91       	pop	r17
 b46:	ff 90       	pop	r15
 b48:	ef 90       	pop	r14
 b4a:	08 95       	ret

Disassembly of section .text.vListInsertEnd:

00000bd8 <vListInsertEnd>:
	pxItem->pvContainer = NULL;
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 bd8:	cf 93       	push	r28
 bda:	df 93       	push	r29
 bdc:	9c 01       	movw	r18, r24
 bde:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
 be0:	dc 01       	movw	r26, r24
 be2:	11 96       	adiw	r26, 0x01	; 1
 be4:	cd 91       	ld	r28, X+
 be6:	dc 91       	ld	r29, X
 be8:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 bea:	d3 83       	std	Z+3, r29	; 0x03
 bec:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 bee:	8c 81       	ldd	r24, Y+4	; 0x04
 bf0:	9d 81       	ldd	r25, Y+5	; 0x05
 bf2:	95 83       	std	Z+5, r25	; 0x05
 bf4:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
 bf6:	8c 81       	ldd	r24, Y+4	; 0x04
 bf8:	9d 81       	ldd	r25, Y+5	; 0x05
 bfa:	dc 01       	movw	r26, r24
 bfc:	13 96       	adiw	r26, 0x03	; 3
 bfe:	7c 93       	st	X, r23
 c00:	6e 93       	st	-X, r22
 c02:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
 c04:	7d 83       	std	Y+5, r23	; 0x05
 c06:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 c08:	31 87       	std	Z+9, r19	; 0x09
 c0a:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
 c0c:	f9 01       	movw	r30, r18
 c0e:	80 81       	ld	r24, Z
 c10:	8f 5f       	subi	r24, 0xFF	; 255
 c12:	80 83       	st	Z, r24
}
 c14:	df 91       	pop	r29
 c16:	cf 91       	pop	r28
 c18:	08 95       	ret

Disassembly of section .text.uxListRemove:

00000ab6 <uxListRemove>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 ab6:	cf 93       	push	r28
 ab8:	df 93       	push	r29
 aba:	fc 01       	movw	r30, r24
 abc:	a0 85       	ldd	r26, Z+8	; 0x08
 abe:	b1 85       	ldd	r27, Z+9	; 0x09
 ac0:	c2 81       	ldd	r28, Z+2	; 0x02
 ac2:	d3 81       	ldd	r29, Z+3	; 0x03
 ac4:	84 81       	ldd	r24, Z+4	; 0x04
 ac6:	95 81       	ldd	r25, Z+5	; 0x05
 ac8:	9d 83       	std	Y+5, r25	; 0x05
 aca:	8c 83       	std	Y+4, r24	; 0x04
 acc:	c4 81       	ldd	r28, Z+4	; 0x04
 ace:	d5 81       	ldd	r29, Z+5	; 0x05
 ad0:	82 81       	ldd	r24, Z+2	; 0x02
 ad2:	93 81       	ldd	r25, Z+3	; 0x03
 ad4:	9b 83       	std	Y+3, r25	; 0x03
 ad6:	8a 83       	std	Y+2, r24	; 0x02
 ad8:	11 96       	adiw	r26, 0x01	; 1
 ada:	8d 91       	ld	r24, X+
 adc:	9c 91       	ld	r25, X
 ade:	12 97       	sbiw	r26, 0x02	; 2
 ae0:	e8 17       	cp	r30, r24
 ae2:	f9 07       	cpc	r31, r25
 ae4:	31 f4       	brne	.+12     	; 0xaf2 <uxListRemove+0x3c>
 ae6:	84 81       	ldd	r24, Z+4	; 0x04
 ae8:	95 81       	ldd	r25, Z+5	; 0x05
 aea:	12 96       	adiw	r26, 0x02	; 2
 aec:	9c 93       	st	X, r25
 aee:	8e 93       	st	-X, r24
 af0:	11 97       	sbiw	r26, 0x01	; 1
 af2:	11 86       	std	Z+9, r1	; 0x09
 af4:	10 86       	std	Z+8, r1	; 0x08
 af6:	8c 91       	ld	r24, X
 af8:	81 50       	subi	r24, 0x01	; 1
 afa:	8c 93       	st	X, r24
 afc:	df 91       	pop	r29
 afe:	cf 91       	pop	r28
 b00:	08 95       	ret

Disassembly of section .text.vPortYieldFromTick:

0000065a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
 65a:	0f 92       	push	r0
 65c:	0f b6       	in	r0, 0x3f	; 63
 65e:	f8 94       	cli
 660:	0f 92       	push	r0
 662:	1f 92       	push	r1
 664:	11 24       	eor	r1, r1
 666:	2f 92       	push	r2
 668:	3f 92       	push	r3
 66a:	4f 92       	push	r4
 66c:	5f 92       	push	r5
 66e:	6f 92       	push	r6
 670:	7f 92       	push	r7
 672:	8f 92       	push	r8
 674:	9f 92       	push	r9
 676:	af 92       	push	r10
 678:	bf 92       	push	r11
 67a:	cf 92       	push	r12
 67c:	df 92       	push	r13
 67e:	ef 92       	push	r14
 680:	ff 92       	push	r15
 682:	0f 93       	push	r16
 684:	1f 93       	push	r17
 686:	2f 93       	push	r18
 688:	3f 93       	push	r19
 68a:	4f 93       	push	r20
 68c:	5f 93       	push	r21
 68e:	6f 93       	push	r22
 690:	7f 93       	push	r23
 692:	8f 93       	push	r24
 694:	9f 93       	push	r25
 696:	af 93       	push	r26
 698:	bf 93       	push	r27
 69a:	cf 93       	push	r28
 69c:	df 93       	push	r29
 69e:	ef 93       	push	r30
 6a0:	ff 93       	push	r31
 6a2:	a0 91 90 00 	lds	r26, 0x0090	; 0x800090 <pxCurrentTCB>
 6a6:	b0 91 91 00 	lds	r27, 0x0091	; 0x800091 <pxCurrentTCB+0x1>
 6aa:	0d b6       	in	r0, 0x3d	; 61
 6ac:	0d 92       	st	X+, r0
 6ae:	0e b6       	in	r0, 0x3e	; 62
 6b0:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
 6b2:	0e 94 65 00 	call	0xca	; 0xca <__data_load_end>
 6b6:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
 6b8:	0e 94 89 03 	call	0x712	; 0x712 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
 6bc:	a0 91 90 00 	lds	r26, 0x0090	; 0x800090 <pxCurrentTCB>
 6c0:	b0 91 91 00 	lds	r27, 0x0091	; 0x800091 <pxCurrentTCB+0x1>
 6c4:	cd 91       	ld	r28, X+
 6c6:	cd bf       	out	0x3d, r28	; 61
 6c8:	dd 91       	ld	r29, X+
 6ca:	de bf       	out	0x3e, r29	; 62
 6cc:	ff 91       	pop	r31
 6ce:	ef 91       	pop	r30
 6d0:	df 91       	pop	r29
 6d2:	cf 91       	pop	r28
 6d4:	bf 91       	pop	r27
 6d6:	af 91       	pop	r26
 6d8:	9f 91       	pop	r25
 6da:	8f 91       	pop	r24
 6dc:	7f 91       	pop	r23
 6de:	6f 91       	pop	r22
 6e0:	5f 91       	pop	r21
 6e2:	4f 91       	pop	r20
 6e4:	3f 91       	pop	r19
 6e6:	2f 91       	pop	r18
 6e8:	1f 91       	pop	r17
 6ea:	0f 91       	pop	r16
 6ec:	ff 90       	pop	r15
 6ee:	ef 90       	pop	r14
 6f0:	df 90       	pop	r13
 6f2:	cf 90       	pop	r12
 6f4:	bf 90       	pop	r11
 6f6:	af 90       	pop	r10
 6f8:	9f 90       	pop	r9
 6fa:	8f 90       	pop	r8
 6fc:	7f 90       	pop	r7
 6fe:	6f 90       	pop	r6
 700:	5f 90       	pop	r5
 702:	4f 90       	pop	r4
 704:	3f 90       	pop	r3
 706:	2f 90       	pop	r2
 708:	1f 90       	pop	r1
 70a:	0f 90       	pop	r0
 70c:	0f be       	out	0x3f, r0	; 63
 70e:	0f 90       	pop	r0

	asm volatile ( "ret" );
 710:	08 95       	ret

Disassembly of section .text.__vector_7:

00000de4 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
 de4:	0e 94 2d 03 	call	0x65a	; 0x65a <vPortYieldFromTick>
		asm volatile ( "reti" );
 de8:	18 95       	reti

Disassembly of section .text.prvResetNextTaskUnblockTime:

00000c1a <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 c1a:	e0 91 8e 00 	lds	r30, 0x008E	; 0x80008e <pxDelayedTaskList>
 c1e:	f0 91 8f 00 	lds	r31, 0x008F	; 0x80008f <pxDelayedTaskList+0x1>
 c22:	80 81       	ld	r24, Z
 c24:	81 11       	cpse	r24, r1
 c26:	07 c0       	rjmp	.+14     	; 0xc36 <prvResetNextTaskUnblockTime+0x1c>
		/* The new current delayed list is empty.  Set
		xNextTaskUnblockTime to the maximum possible value so it is
		extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 c28:	8f ef       	ldi	r24, 0xFF	; 255
 c2a:	9f ef       	ldi	r25, 0xFF	; 255
 c2c:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <xNextTaskUnblockTime+0x1>
 c30:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <xNextTaskUnblockTime>
 c34:	08 95       	ret
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 c36:	e0 91 8e 00 	lds	r30, 0x008E	; 0x80008e <pxDelayedTaskList>
 c3a:	f0 91 8f 00 	lds	r31, 0x008F	; 0x80008f <pxDelayedTaskList+0x1>
 c3e:	05 80       	ldd	r0, Z+5	; 0x05
 c40:	f6 81       	ldd	r31, Z+6	; 0x06
 c42:	e0 2d       	mov	r30, r0
 c44:	06 80       	ldd	r0, Z+6	; 0x06
 c46:	f7 81       	ldd	r31, Z+7	; 0x07
 c48:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
 c4a:	82 81       	ldd	r24, Z+2	; 0x02
 c4c:	93 81       	ldd	r25, Z+3	; 0x03
 c4e:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <xNextTaskUnblockTime+0x1>
 c52:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <xNextTaskUnblockTime>
 c56:	08 95       	ret

Disassembly of section .text.xTaskIncrementTick:

000000ca <xTaskIncrementTick>:
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
			{
				taskYIELD();
  ca:	df 92       	push	r13
  cc:	ef 92       	push	r14
  ce:	ff 92       	push	r15
  d0:	0f 93       	push	r16
  d2:	1f 93       	push	r17
  d4:	cf 93       	push	r28
  d6:	df 93       	push	r29
  d8:	80 91 94 00 	lds	r24, 0x0094	; 0x800094 <uxSchedulerSuspended>
  dc:	81 11       	cpse	r24, r1
  de:	99 c0       	rjmp	.+306    	; 0x212 <xTaskIncrementTick+0x148>
  e0:	80 91 8a 00 	lds	r24, 0x008A	; 0x80008a <xTickCount>
  e4:	90 91 8b 00 	lds	r25, 0x008B	; 0x80008b <xTickCount+0x1>
  e8:	01 96       	adiw	r24, 0x01	; 1
  ea:	90 93 8b 00 	sts	0x008B, r25	; 0x80008b <xTickCount+0x1>
  ee:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <xTickCount>
  f2:	e0 90 8a 00 	lds	r14, 0x008A	; 0x80008a <xTickCount>
  f6:	f0 90 8b 00 	lds	r15, 0x008B	; 0x80008b <xTickCount+0x1>
  fa:	e1 14       	cp	r14, r1
  fc:	f1 04       	cpc	r15, r1
  fe:	b9 f4       	brne	.+46     	; 0x12e <xTaskIncrementTick+0x64>
 100:	80 91 8e 00 	lds	r24, 0x008E	; 0x80008e <pxDelayedTaskList>
 104:	90 91 8f 00 	lds	r25, 0x008F	; 0x80008f <pxDelayedTaskList+0x1>
 108:	20 91 8c 00 	lds	r18, 0x008C	; 0x80008c <pxOverflowDelayedTaskList>
 10c:	30 91 8d 00 	lds	r19, 0x008D	; 0x80008d <pxOverflowDelayedTaskList+0x1>
 110:	30 93 8f 00 	sts	0x008F, r19	; 0x80008f <pxDelayedTaskList+0x1>
 114:	20 93 8e 00 	sts	0x008E, r18	; 0x80008e <pxDelayedTaskList>
 118:	90 93 8d 00 	sts	0x008D, r25	; 0x80008d <pxOverflowDelayedTaskList+0x1>
 11c:	80 93 8c 00 	sts	0x008C, r24	; 0x80008c <pxOverflowDelayedTaskList>
 120:	80 91 95 00 	lds	r24, 0x0095	; 0x800095 <xNumOfOverflows>
 124:	8f 5f       	subi	r24, 0xFF	; 255
 126:	80 93 95 00 	sts	0x0095, r24	; 0x800095 <xNumOfOverflows>
 12a:	0e 94 0d 06 	call	0xc1a	; 0xc1a <prvResetNextTaskUnblockTime>
 12e:	80 91 88 00 	lds	r24, 0x0088	; 0x800088 <xNextTaskUnblockTime>
 132:	90 91 89 00 	lds	r25, 0x0089	; 0x800089 <xNextTaskUnblockTime+0x1>
 136:	e8 16       	cp	r14, r24
 138:	f9 06       	cpc	r15, r25
 13a:	28 f4       	brcc	.+10     	; 0x146 <xTaskIncrementTick+0x7c>
 13c:	d1 2c       	mov	r13, r1
 13e:	53 c0       	rjmp	.+166    	; 0x1e6 <xTaskIncrementTick+0x11c>
 140:	dd 24       	eor	r13, r13
 142:	d3 94       	inc	r13
 144:	01 c0       	rjmp	.+2      	; 0x148 <xTaskIncrementTick+0x7e>
 146:	d1 2c       	mov	r13, r1
 148:	e0 91 8e 00 	lds	r30, 0x008E	; 0x80008e <pxDelayedTaskList>
 14c:	f0 91 8f 00 	lds	r31, 0x008F	; 0x80008f <pxDelayedTaskList+0x1>
 150:	80 81       	ld	r24, Z
 152:	81 11       	cpse	r24, r1
 154:	07 c0       	rjmp	.+14     	; 0x164 <xTaskIncrementTick+0x9a>
 156:	8f ef       	ldi	r24, 0xFF	; 255
 158:	9f ef       	ldi	r25, 0xFF	; 255
 15a:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <xNextTaskUnblockTime+0x1>
 15e:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <xNextTaskUnblockTime>
 162:	41 c0       	rjmp	.+130    	; 0x1e6 <xTaskIncrementTick+0x11c>
 164:	e0 91 8e 00 	lds	r30, 0x008E	; 0x80008e <pxDelayedTaskList>
 168:	f0 91 8f 00 	lds	r31, 0x008F	; 0x80008f <pxDelayedTaskList+0x1>
 16c:	05 80       	ldd	r0, Z+5	; 0x05
 16e:	f6 81       	ldd	r31, Z+6	; 0x06
 170:	e0 2d       	mov	r30, r0
 172:	c6 81       	ldd	r28, Z+6	; 0x06
 174:	d7 81       	ldd	r29, Z+7	; 0x07
 176:	8a 81       	ldd	r24, Y+2	; 0x02
 178:	9b 81       	ldd	r25, Y+3	; 0x03
 17a:	e8 16       	cp	r14, r24
 17c:	f9 06       	cpc	r15, r25
 17e:	28 f4       	brcc	.+10     	; 0x18a <xTaskIncrementTick+0xc0>
 180:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <xNextTaskUnblockTime+0x1>
 184:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <xNextTaskUnblockTime>
 188:	2e c0       	rjmp	.+92     	; 0x1e6 <xTaskIncrementTick+0x11c>
 18a:	8e 01       	movw	r16, r28
 18c:	0e 5f       	subi	r16, 0xFE	; 254
 18e:	1f 4f       	sbci	r17, 0xFF	; 255
 190:	c8 01       	movw	r24, r16
 192:	0e 94 5b 05 	call	0xab6	; 0xab6 <uxListRemove>
 196:	8c 89       	ldd	r24, Y+20	; 0x14
 198:	9d 89       	ldd	r25, Y+21	; 0x15
 19a:	89 2b       	or	r24, r25
 19c:	21 f0       	breq	.+8      	; 0x1a6 <xTaskIncrementTick+0xdc>
 19e:	ce 01       	movw	r24, r28
 1a0:	0c 96       	adiw	r24, 0x0c	; 12
 1a2:	0e 94 5b 05 	call	0xab6	; 0xab6 <uxListRemove>
 1a6:	8e 89       	ldd	r24, Y+22	; 0x16
 1a8:	90 91 98 00 	lds	r25, 0x0098	; 0x800098 <uxTopReadyPriority>
 1ac:	98 17       	cp	r25, r24
 1ae:	10 f4       	brcc	.+4      	; 0x1b4 <xTaskIncrementTick+0xea>
 1b0:	80 93 98 00 	sts	0x0098, r24	; 0x800098 <uxTopReadyPriority>
 1b4:	90 e0       	ldi	r25, 0x00	; 0
 1b6:	9c 01       	movw	r18, r24
 1b8:	22 0f       	add	r18, r18
 1ba:	33 1f       	adc	r19, r19
 1bc:	22 0f       	add	r18, r18
 1be:	33 1f       	adc	r19, r19
 1c0:	22 0f       	add	r18, r18
 1c2:	33 1f       	adc	r19, r19
 1c4:	82 0f       	add	r24, r18
 1c6:	93 1f       	adc	r25, r19
 1c8:	b8 01       	movw	r22, r16
 1ca:	80 5a       	subi	r24, 0xA0	; 160
 1cc:	9f 4f       	sbci	r25, 0xFF	; 255
 1ce:	0e 94 ec 05 	call	0xbd8	; 0xbd8 <vListInsertEnd>
 1d2:	9e 89       	ldd	r25, Y+22	; 0x16
 1d4:	e0 91 90 00 	lds	r30, 0x0090	; 0x800090 <pxCurrentTCB>
 1d8:	f0 91 91 00 	lds	r31, 0x0091	; 0x800091 <pxCurrentTCB+0x1>
 1dc:	86 89       	ldd	r24, Z+22	; 0x16
 1de:	98 17       	cp	r25, r24
 1e0:	08 f0       	brcs	.+2      	; 0x1e4 <xTaskIncrementTick+0x11a>
 1e2:	ae cf       	rjmp	.-164    	; 0x140 <xTaskIncrementTick+0x76>
 1e4:	b1 cf       	rjmp	.-158    	; 0x148 <xTaskIncrementTick+0x7e>
 1e6:	e0 91 90 00 	lds	r30, 0x0090	; 0x800090 <pxCurrentTCB>
 1ea:	f0 91 91 00 	lds	r31, 0x0091	; 0x800091 <pxCurrentTCB+0x1>
 1ee:	86 89       	ldd	r24, Z+22	; 0x16
 1f0:	90 e0       	ldi	r25, 0x00	; 0
 1f2:	fc 01       	movw	r30, r24
 1f4:	ee 0f       	add	r30, r30
 1f6:	ff 1f       	adc	r31, r31
 1f8:	ee 0f       	add	r30, r30
 1fa:	ff 1f       	adc	r31, r31
 1fc:	ee 0f       	add	r30, r30
 1fe:	ff 1f       	adc	r31, r31
 200:	8e 0f       	add	r24, r30
 202:	9f 1f       	adc	r25, r31
 204:	fc 01       	movw	r30, r24
 206:	e0 5a       	subi	r30, 0xA0	; 160
 208:	ff 4f       	sbci	r31, 0xFF	; 255
 20a:	80 81       	ld	r24, Z
 20c:	82 30       	cpi	r24, 0x02	; 2
 20e:	40 f4       	brcc	.+16     	; 0x220 <xTaskIncrementTick+0x156>
 210:	09 c0       	rjmp	.+18     	; 0x224 <xTaskIncrementTick+0x15a>
 212:	80 91 97 00 	lds	r24, 0x0097	; 0x800097 <uxPendedTicks>
 216:	8f 5f       	subi	r24, 0xFF	; 255
 218:	80 93 97 00 	sts	0x0097, r24	; 0x800097 <uxPendedTicks>
 21c:	d1 2c       	mov	r13, r1
 21e:	02 c0       	rjmp	.+4      	; 0x224 <xTaskIncrementTick+0x15a>
 220:	dd 24       	eor	r13, r13
 222:	d3 94       	inc	r13
 224:	80 91 96 00 	lds	r24, 0x0096	; 0x800096 <xYieldPending>
 228:	88 23       	and	r24, r24
 22a:	11 f0       	breq	.+4      	; 0x230 <xTaskIncrementTick+0x166>
 22c:	dd 24       	eor	r13, r13
 22e:	d3 94       	inc	r13
 230:	8d 2d       	mov	r24, r13
 232:	df 91       	pop	r29
 234:	cf 91       	pop	r28
 236:	1f 91       	pop	r17
 238:	0f 91       	pop	r16
 23a:	ff 90       	pop	r15
 23c:	ef 90       	pop	r14
 23e:	df 90       	pop	r13
 240:	08 95       	ret

Disassembly of section .text.vTaskSwitchContext:

00000712 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 712:	80 91 94 00 	lds	r24, 0x0094	; 0x800094 <uxSchedulerSuspended>
 716:	88 23       	and	r24, r24
 718:	21 f0       	breq	.+8      	; 0x722 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 71a:	81 e0       	ldi	r24, 0x01	; 1
 71c:	80 93 96 00 	sts	0x0096, r24	; 0x800096 <xYieldPending>
 720:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
 722:	10 92 96 00 	sts	0x0096, r1	; 0x800096 <xYieldPending>
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
 726:	05 c0       	rjmp	.+10     	; 0x732 <vTaskSwitchContext+0x20>
 728:	80 91 98 00 	lds	r24, 0x0098	; 0x800098 <uxTopReadyPriority>
 72c:	81 50       	subi	r24, 0x01	; 1
 72e:	80 93 98 00 	sts	0x0098, r24	; 0x800098 <uxTopReadyPriority>
 732:	80 91 98 00 	lds	r24, 0x0098	; 0x800098 <uxTopReadyPriority>
 736:	90 e0       	ldi	r25, 0x00	; 0
 738:	fc 01       	movw	r30, r24
 73a:	ee 0f       	add	r30, r30
 73c:	ff 1f       	adc	r31, r31
 73e:	ee 0f       	add	r30, r30
 740:	ff 1f       	adc	r31, r31
 742:	ee 0f       	add	r30, r30
 744:	ff 1f       	adc	r31, r31
 746:	8e 0f       	add	r24, r30
 748:	9f 1f       	adc	r25, r31
 74a:	fc 01       	movw	r30, r24
 74c:	e0 5a       	subi	r30, 0xA0	; 160
 74e:	ff 4f       	sbci	r31, 0xFF	; 255
 750:	80 81       	ld	r24, Z
 752:	88 23       	and	r24, r24
 754:	49 f3       	breq	.-46     	; 0x728 <vTaskSwitchContext+0x16>
 756:	80 91 98 00 	lds	r24, 0x0098	; 0x800098 <uxTopReadyPriority>
 75a:	90 e0       	ldi	r25, 0x00	; 0
 75c:	9c 01       	movw	r18, r24
 75e:	22 0f       	add	r18, r18
 760:	33 1f       	adc	r19, r19
 762:	22 0f       	add	r18, r18
 764:	33 1f       	adc	r19, r19
 766:	22 0f       	add	r18, r18
 768:	33 1f       	adc	r19, r19
 76a:	28 0f       	add	r18, r24
 76c:	39 1f       	adc	r19, r25
 76e:	d9 01       	movw	r26, r18
 770:	a0 5a       	subi	r26, 0xA0	; 160
 772:	bf 4f       	sbci	r27, 0xFF	; 255
 774:	11 96       	adiw	r26, 0x01	; 1
 776:	ed 91       	ld	r30, X+
 778:	fc 91       	ld	r31, X
 77a:	12 97       	sbiw	r26, 0x02	; 2
 77c:	02 80       	ldd	r0, Z+2	; 0x02
 77e:	f3 81       	ldd	r31, Z+3	; 0x03
 780:	e0 2d       	mov	r30, r0
 782:	12 96       	adiw	r26, 0x02	; 2
 784:	fc 93       	st	X, r31
 786:	ee 93       	st	-X, r30
 788:	11 97       	sbiw	r26, 0x01	; 1
 78a:	2d 59       	subi	r18, 0x9D	; 157
 78c:	3f 4f       	sbci	r19, 0xFF	; 255
 78e:	e2 17       	cp	r30, r18
 790:	f3 07       	cpc	r31, r19
 792:	29 f4       	brne	.+10     	; 0x79e <vTaskSwitchContext+0x8c>
 794:	22 81       	ldd	r18, Z+2	; 0x02
 796:	33 81       	ldd	r19, Z+3	; 0x03
 798:	fd 01       	movw	r30, r26
 79a:	32 83       	std	Z+2, r19	; 0x02
 79c:	21 83       	std	Z+1, r18	; 0x01
 79e:	fc 01       	movw	r30, r24
 7a0:	ee 0f       	add	r30, r30
 7a2:	ff 1f       	adc	r31, r31
 7a4:	ee 0f       	add	r30, r30
 7a6:	ff 1f       	adc	r31, r31
 7a8:	ee 0f       	add	r30, r30
 7aa:	ff 1f       	adc	r31, r31
 7ac:	8e 0f       	add	r24, r30
 7ae:	9f 1f       	adc	r25, r31
 7b0:	fc 01       	movw	r30, r24
 7b2:	e0 5a       	subi	r30, 0xA0	; 160
 7b4:	ff 4f       	sbci	r31, 0xFF	; 255
 7b6:	01 80       	ldd	r0, Z+1	; 0x01
 7b8:	f2 81       	ldd	r31, Z+2	; 0x02
 7ba:	e0 2d       	mov	r30, r0
 7bc:	86 81       	ldd	r24, Z+6	; 0x06
 7be:	97 81       	ldd	r25, Z+7	; 0x07
 7c0:	90 93 91 00 	sts	0x0091, r25	; 0x800091 <pxCurrentTCB+0x1>
 7c4:	80 93 90 00 	sts	0x0090, r24	; 0x800090 <pxCurrentTCB>
 7c8:	08 95       	ret

Disassembly of section .text:

00000dd0 <__cmpsf2>:
 dd0:	0e 94 a6 05 	call	0xb4c	; 0xb4c <__fp_cmp>
 dd4:	08 f4       	brcc	.+2      	; 0xdd8 <__cmpsf2+0x8>
 dd6:	81 e0       	ldi	r24, 0x01	; 1
 dd8:	08 95       	ret

Disassembly of section .text:

00000878 <__floatunsisf>:
 878:	e8 94       	clt
 87a:	09 c0       	rjmp	.+18     	; 0x88e <__floatsisf+0x12>

0000087c <__floatsisf>:
 87c:	97 fb       	bst	r25, 7
 87e:	3e f4       	brtc	.+14     	; 0x88e <__floatsisf+0x12>
 880:	90 95       	com	r25
 882:	80 95       	com	r24
 884:	70 95       	com	r23
 886:	61 95       	neg	r22
 888:	7f 4f       	sbci	r23, 0xFF	; 255
 88a:	8f 4f       	sbci	r24, 0xFF	; 255
 88c:	9f 4f       	sbci	r25, 0xFF	; 255
 88e:	99 23       	and	r25, r25
 890:	a9 f0       	breq	.+42     	; 0x8bc <__floatsisf+0x40>
 892:	f9 2f       	mov	r31, r25
 894:	96 e9       	ldi	r25, 0x96	; 150
 896:	bb 27       	eor	r27, r27
 898:	93 95       	inc	r25
 89a:	f6 95       	lsr	r31
 89c:	87 95       	ror	r24
 89e:	77 95       	ror	r23
 8a0:	67 95       	ror	r22
 8a2:	b7 95       	ror	r27
 8a4:	f1 11       	cpse	r31, r1
 8a6:	f8 cf       	rjmp	.-16     	; 0x898 <__floatsisf+0x1c>
 8a8:	fa f4       	brpl	.+62     	; 0x8e8 <__floatsisf+0x6c>
 8aa:	bb 0f       	add	r27, r27
 8ac:	11 f4       	brne	.+4      	; 0x8b2 <__floatsisf+0x36>
 8ae:	60 ff       	sbrs	r22, 0
 8b0:	1b c0       	rjmp	.+54     	; 0x8e8 <__floatsisf+0x6c>
 8b2:	6f 5f       	subi	r22, 0xFF	; 255
 8b4:	7f 4f       	sbci	r23, 0xFF	; 255
 8b6:	8f 4f       	sbci	r24, 0xFF	; 255
 8b8:	9f 4f       	sbci	r25, 0xFF	; 255
 8ba:	16 c0       	rjmp	.+44     	; 0x8e8 <__floatsisf+0x6c>
 8bc:	88 23       	and	r24, r24
 8be:	11 f0       	breq	.+4      	; 0x8c4 <__floatsisf+0x48>
 8c0:	96 e9       	ldi	r25, 0x96	; 150
 8c2:	11 c0       	rjmp	.+34     	; 0x8e6 <__floatsisf+0x6a>
 8c4:	77 23       	and	r23, r23
 8c6:	21 f0       	breq	.+8      	; 0x8d0 <__floatsisf+0x54>
 8c8:	9e e8       	ldi	r25, 0x8E	; 142
 8ca:	87 2f       	mov	r24, r23
 8cc:	76 2f       	mov	r23, r22
 8ce:	05 c0       	rjmp	.+10     	; 0x8da <__floatsisf+0x5e>
 8d0:	66 23       	and	r22, r22
 8d2:	71 f0       	breq	.+28     	; 0x8f0 <__floatsisf+0x74>
 8d4:	96 e8       	ldi	r25, 0x86	; 134
 8d6:	86 2f       	mov	r24, r22
 8d8:	70 e0       	ldi	r23, 0x00	; 0
 8da:	60 e0       	ldi	r22, 0x00	; 0
 8dc:	2a f0       	brmi	.+10     	; 0x8e8 <__floatsisf+0x6c>
 8de:	9a 95       	dec	r25
 8e0:	66 0f       	add	r22, r22
 8e2:	77 1f       	adc	r23, r23
 8e4:	88 1f       	adc	r24, r24
 8e6:	da f7       	brpl	.-10     	; 0x8de <__floatsisf+0x62>
 8e8:	88 0f       	add	r24, r24
 8ea:	96 95       	lsr	r25
 8ec:	87 95       	ror	r24
 8ee:	97 f9       	bld	r25, 7
 8f0:	08 95       	ret

Disassembly of section .text:

00000b4c <__fp_cmp>:
 b4c:	99 0f       	add	r25, r25
 b4e:	00 08       	sbc	r0, r0
 b50:	55 0f       	add	r21, r21
 b52:	aa 0b       	sbc	r26, r26
 b54:	e0 e8       	ldi	r30, 0x80	; 128
 b56:	fe ef       	ldi	r31, 0xFE	; 254
 b58:	16 16       	cp	r1, r22
 b5a:	17 06       	cpc	r1, r23
 b5c:	e8 07       	cpc	r30, r24
 b5e:	f9 07       	cpc	r31, r25
 b60:	c0 f0       	brcs	.+48     	; 0xb92 <__fp_cmp+0x46>
 b62:	12 16       	cp	r1, r18
 b64:	13 06       	cpc	r1, r19
 b66:	e4 07       	cpc	r30, r20
 b68:	f5 07       	cpc	r31, r21
 b6a:	98 f0       	brcs	.+38     	; 0xb92 <__fp_cmp+0x46>
 b6c:	62 1b       	sub	r22, r18
 b6e:	73 0b       	sbc	r23, r19
 b70:	84 0b       	sbc	r24, r20
 b72:	95 0b       	sbc	r25, r21
 b74:	39 f4       	brne	.+14     	; 0xb84 <__fp_cmp+0x38>
 b76:	0a 26       	eor	r0, r26
 b78:	61 f0       	breq	.+24     	; 0xb92 <__fp_cmp+0x46>
 b7a:	23 2b       	or	r18, r19
 b7c:	24 2b       	or	r18, r20
 b7e:	25 2b       	or	r18, r21
 b80:	21 f4       	brne	.+8      	; 0xb8a <__fp_cmp+0x3e>
 b82:	08 95       	ret
 b84:	0a 26       	eor	r0, r26
 b86:	09 f4       	brne	.+2      	; 0xb8a <__fp_cmp+0x3e>
 b88:	a1 40       	sbci	r26, 0x01	; 1
 b8a:	a6 95       	lsr	r26
 b8c:	8f ef       	ldi	r24, 0xFF	; 255
 b8e:	81 1d       	adc	r24, r1
 b90:	81 1d       	adc	r24, r1
 b92:	08 95       	ret

Disassembly of section .text:

00000dda <__gesf2>:
 dda:	0e 94 a6 05 	call	0xb4c	; 0xb4c <__fp_cmp>
 dde:	08 f4       	brcc	.+2      	; 0xde2 <__gesf2+0x8>
 de0:	8f ef       	ldi	r24, 0xFF	; 255
 de2:	08 95       	ret

Disassembly of section .text.libgcc.div:

00000b94 <__udivmodsi4>:
 b94:	a1 e2       	ldi	r26, 0x21	; 33
 b96:	1a 2e       	mov	r1, r26
 b98:	aa 1b       	sub	r26, r26
 b9a:	bb 1b       	sub	r27, r27
 b9c:	fd 01       	movw	r30, r26
 b9e:	0d c0       	rjmp	.+26     	; 0xbba <__udivmodsi4_ep>

00000ba0 <__udivmodsi4_loop>:
 ba0:	aa 1f       	adc	r26, r26
 ba2:	bb 1f       	adc	r27, r27
 ba4:	ee 1f       	adc	r30, r30
 ba6:	ff 1f       	adc	r31, r31
 ba8:	a2 17       	cp	r26, r18
 baa:	b3 07       	cpc	r27, r19
 bac:	e4 07       	cpc	r30, r20
 bae:	f5 07       	cpc	r31, r21
 bb0:	20 f0       	brcs	.+8      	; 0xbba <__udivmodsi4_ep>
 bb2:	a2 1b       	sub	r26, r18
 bb4:	b3 0b       	sbc	r27, r19
 bb6:	e4 0b       	sbc	r30, r20
 bb8:	f5 0b       	sbc	r31, r21

00000bba <__udivmodsi4_ep>:
 bba:	66 1f       	adc	r22, r22
 bbc:	77 1f       	adc	r23, r23
 bbe:	88 1f       	adc	r24, r24
 bc0:	99 1f       	adc	r25, r25
 bc2:	1a 94       	dec	r1
 bc4:	69 f7       	brne	.-38     	; 0xba0 <__udivmodsi4_loop>
 bc6:	60 95       	com	r22
 bc8:	70 95       	com	r23
 bca:	80 95       	com	r24
 bcc:	90 95       	com	r25
 bce:	9b 01       	movw	r18, r22
 bd0:	ac 01       	movw	r20, r24
 bd2:	bd 01       	movw	r22, r26
 bd4:	cf 01       	movw	r24, r30
 bd6:	08 95       	ret

Disassembly of section .text.libgcc.div:

00000c86 <__divmodsi4>:
 c86:	05 2e       	mov	r0, r21
 c88:	97 fb       	bst	r25, 7
 c8a:	1e f4       	brtc	.+6      	; 0xc92 <__divmodsi4+0xc>
 c8c:	00 94       	com	r0
 c8e:	0e 94 7f 06 	call	0xcfe	; 0xcfe <__negsi2>
 c92:	57 fd       	sbrc	r21, 7
 c94:	07 d0       	rcall	.+14     	; 0xca4 <__divmodsi4_neg2>
 c96:	0e 94 ca 05 	call	0xb94	; 0xb94 <__udivmodsi4>
 c9a:	07 fc       	sbrc	r0, 7
 c9c:	03 d0       	rcall	.+6      	; 0xca4 <__divmodsi4_neg2>
 c9e:	4e f4       	brtc	.+18     	; 0xcb2 <__divmodsi4_exit>
 ca0:	0c 94 7f 06 	jmp	0xcfe	; 0xcfe <__negsi2>

00000ca4 <__divmodsi4_neg2>:
 ca4:	50 95       	com	r21
 ca6:	40 95       	com	r20
 ca8:	30 95       	com	r19
 caa:	21 95       	neg	r18
 cac:	3f 4f       	sbci	r19, 0xFF	; 255
 cae:	4f 4f       	sbci	r20, 0xFF	; 255
 cb0:	5f 4f       	sbci	r21, 0xFF	; 255

00000cb2 <__divmodsi4_exit>:
 cb2:	08 95       	ret

Disassembly of section .text.libgcc.div:

00000cfe <__negsi2>:
 cfe:	90 95       	com	r25
 d00:	80 95       	com	r24
 d02:	70 95       	com	r23
 d04:	61 95       	neg	r22
 d06:	7f 4f       	sbci	r23, 0xFF	; 255
 d08:	8f 4f       	sbci	r24, 0xFF	; 255
 d0a:	9f 4f       	sbci	r25, 0xFF	; 255
 d0c:	08 95       	ret

Disassembly of section .text.libgcc:

00000dba <__tablejump2__>:
 dba:	ee 0f       	add	r30, r30
 dbc:	ff 1f       	adc	r31, r31
 dbe:	05 90       	lpm	r0, Z+
 dc0:	f4 91       	lpm	r31, Z
 dc2:	e0 2d       	mov	r30, r0
 dc4:	09 94       	ijmp

Disassembly of section .text.__dummy_fini:

00000df2 <_fini>:
 df2:	08 95       	ret

Disassembly of section .text.__dummy_funcs_on_exit:

00000df4 <__funcs_on_exit>:
 df4:	08 95       	ret

Disassembly of section .text.__dummy_simulator_exit:

00000df6 <__simulator_exit>:
 df6:	08 95       	ret

Disassembly of section .text.exit:

00000cd6 <exit>:
 cd6:	ec 01       	movw	r28, r24
 cd8:	0e 94 fa 06 	call	0xdf4	; 0xdf4 <__funcs_on_exit>
 cdc:	0e 94 f9 06 	call	0xdf2	; 0xdf2 <_fini>
 ce0:	ce 01       	movw	r24, r28
 ce2:	0e 94 fb 06 	call	0xdf6	; 0xdf6 <__simulator_exit>
 ce6:	ce 01       	movw	r24, r28
 ce8:	0e 94 f7 06 	call	0xdee	; 0xdee <_Exit>

Disassembly of section .text._Exit:

00000dee <_Exit>:
 dee:	0e 94 63 00 	call	0xc6	; 0xc6 <_exit>
