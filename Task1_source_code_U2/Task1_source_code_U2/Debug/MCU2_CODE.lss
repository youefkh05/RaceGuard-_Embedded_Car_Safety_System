
MCU2_CODE.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000000ca  00000000  00000000  000000d4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00800060  00800060  00000e86  2**0
                  ALLOC, LOAD, DATA
  2 .comment      0000002f  00000000  00000000  00000e86  2**0
                  CONTENTS, READONLY
  3 .stack.descriptors.hdr 0000007e  00000000  00000000  00000eb5  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000448  00000000  00000000  00000f33  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00006a5e  00000000  00000000  0000137b  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00001247  00000000  00000000  00007dd9  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000025ba  00000000  00000000  00009020  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000009ac  00000000  00000000  0000b5dc  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000060e  00000000  00000000  0000bf88  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000026a6  00000000  00000000  0000c596  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000003a0  00000000  00000000  0000ec3c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .text         00000004  00000da2  00000da2  00000e76  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 13 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  0000efdc  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .text.App_Init 0000004e  00000998  00000998  00000a6c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 15 .text.handle_Mes 00000130  00000242  00000242  00000316  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 16 .bss.speed    00000002  00800084  00800084  00000e86  2**0
                  ALLOC
 17 .bss.currentState 00000001  00800092  00800092  00000e86  2**0
                  ALLOC
 18 .bss.UART_Rdata 00000002  00800086  00800086  00000e86  2**0
                  ALLOC
 19 .bss.DC_mach1 00000001  00800093  00800093  00000e86  2**0
                  ALLOC
 20 .text.BUZZER_Initialize 0000000c  00000ce2  00000ce2  00000db6  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 21 .text.BUZZER_ON 0000000c  00000cee  00000cee  00000dc2  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 22 .text.BUZZER_OFF 0000000c  00000cfa  00000cfa  00000dce  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 23 .text.LED1_Initialize 0000000c  00000d06  00000d06  00000dda  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 24 .text.LED1_ON 0000000c  00000d12  00000d12  00000de6  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 25 .text.LED1_OFF 0000000c  00000d1e  00000d1e  00000df2  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 26 .text.LED2_Initialize 0000000c  00000d2a  00000d2a  00000dfe  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 27 .text.LED2_ON 0000000c  00000d36  00000d36  00000e0a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 28 .text.LED2_OFF 0000000c  00000d42  00000d42  00000e16  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 29 .text.LED3_Initialize 0000000c  00000d4e  00000d4e  00000e22  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 30 .text.LED3_ON 0000000c  00000d5a  00000d5a  00000e2e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 31 .text.LED3_OFF 0000000c  00000d66  00000d66  00000e3a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 32 .text.DC_Initialize 00000050  00000948  00000948  00000a1c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 33 .text.DC_Start 00000094  000007c6  000007c6  0000089a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 34 .text.DC_Stop 0000004e  000009e6  000009e6  00000aba  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 35 .text.DC_Change_Speed 0000002e  00000c10  00000c10  00000ce4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 36 .text.ServoMotor_Initialize 00000022  00000c6c  00000c6c  00000d40  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 37 .text.ServoMotor_Rotate 00000012  00000ca4  00000ca4  00000d78  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 38 .text.main    0000003a  00000bd6  00000bd6  00000caa  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 39 .text.ADC_Initialize 0000000e  00000cc6  00000cc6  00000d9a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 40 .text.ADC_Read 00000074  000008d4  000008d4  000009a8  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 41 .text.DIO_SetPinDirection 000000e2  00000492  00000492  00000566  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 42 .text.DIO_SetPinValue 000000e2  00000574  00000574  00000648  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 43 .text.UART_Initialize_WithoutInterrupt 00000120  00000372  00000372  00000446  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 44 .text.UART_Receive_Character 0000000e  00000cd4  00000cd4  00000da8  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 45 .text.Reassemble_uint16 0000000a  00000d7e  00000d7e  00000e52  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 46 .text.UART_Receive_Word 0000004a  00000a80  00000a80  00000b54  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 47 .text.vListInsertEnd 00000042  00000b56  00000b56  00000c2a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 48 .text.uxListRemove 0000004c  00000a34  00000a34  00000b08  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 49 .text.vPortYieldFromTick 000000b8  00000656  00000656  0000072a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 50 .text.__vector_7 00000006  00000d9c  00000d9c  00000e70  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 51 .text.prvResetNextTaskUnblockTime 0000003e  00000b98  00000b98  00000c6c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 52 .text.xTaskIncrementTick 00000178  000000ca  000000ca  0000019e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 53 .text.vTaskSwitchContext 000000b8  0000070e  0000070e  000007e2  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 54 .bss.uxSchedulerSuspended 00000001  00800094  00800094  00000e86  2**0
                  ALLOC
 55 .data.xNextTaskUnblockTime 00000002  00800088  00000db0  00000e84  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 56 .bss.xNumOfOverflows 00000001  00800095  00800095  00000e86  2**0
                  ALLOC
 57 .bss.xYieldPending 00000001  00800096  00800096  00000e86  2**0
                  ALLOC
 58 .bss.uxPendedTicks 00000001  00800097  00800097  00000e86  2**0
                  ALLOC
 59 .bss.uxTopReadyPriority 00000001  00800098  00800098  00000e86  2**0
                  ALLOC
 60 .bss.xTickCount 00000002  0080008a  0080008a  00000e86  2**0
                  ALLOC
 61 .bss.pxOverflowDelayedTaskList 00000002  0080008c  0080008c  00000e86  2**0
                  ALLOC
 62 .bss.pxDelayedTaskList 00000002  0080008e  0080008e  00000e86  2**0
                  ALLOC
 63 .bss.pxReadyTasksLists 00000024  00800060  00800060  00000e86  2**0
                  ALLOC
 64 .bss.pxCurrentTCB 00000002  00800090  00800090  00000e86  2**0
                  ALLOC
 65 .text         0000000a  00000d88  00000d88  00000e5c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 66 .text         0000007a  0000085a  0000085a  0000092e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 67 .text         00000048  00000aca  00000aca  00000b9e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 68 .text         0000000a  00000d92  00000d92  00000e66  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 69 .text.libgcc.div 00000044  00000b12  00000b12  00000be6  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 70 .text.libgcc.div 0000002e  00000c3e  00000c3e  00000d12  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 71 .text.libgcc.div 00000010  00000cb6  00000cb6  00000d8a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 72 .text.libgcc  0000000c  00000d72  00000d72  00000e46  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 73 .text.__dummy_fini 00000002  00000daa  00000daa  00000e7e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 74 .text.__dummy_funcs_on_exit 00000002  00000dac  00000dac  00000e80  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 75 .text.__dummy_simulator_exit 00000002  00000dae  00000dae  00000e82  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 76 .text.exit    00000016  00000c8e  00000c8e  00000d62  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 77 .text._Exit   00000004  00000da6  00000da6  00000e7a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 3b 00 	jmp	0x76	; 0x76 <__ctors_end>
   4:	0c 94 d1 06 	jmp	0xda2	; 0xda2 <__bad_interrupt>
   8:	0c 94 d1 06 	jmp	0xda2	; 0xda2 <__bad_interrupt>
   c:	0c 94 d1 06 	jmp	0xda2	; 0xda2 <__bad_interrupt>
  10:	0c 94 d1 06 	jmp	0xda2	; 0xda2 <__bad_interrupt>
  14:	0c 94 d1 06 	jmp	0xda2	; 0xda2 <__bad_interrupt>
  18:	0c 94 d1 06 	jmp	0xda2	; 0xda2 <__bad_interrupt>
  1c:	0c 94 ce 06 	jmp	0xd9c	; 0xd9c <__vector_7>
  20:	0c 94 d1 06 	jmp	0xda2	; 0xda2 <__bad_interrupt>
  24:	0c 94 d1 06 	jmp	0xda2	; 0xda2 <__bad_interrupt>
  28:	0c 94 d1 06 	jmp	0xda2	; 0xda2 <__bad_interrupt>
  2c:	0c 94 d1 06 	jmp	0xda2	; 0xda2 <__bad_interrupt>
  30:	0c 94 d1 06 	jmp	0xda2	; 0xda2 <__bad_interrupt>
  34:	0c 94 d1 06 	jmp	0xda2	; 0xda2 <__bad_interrupt>
  38:	0c 94 d1 06 	jmp	0xda2	; 0xda2 <__bad_interrupt>
  3c:	0c 94 d1 06 	jmp	0xda2	; 0xda2 <__bad_interrupt>
  40:	0c 94 d1 06 	jmp	0xda2	; 0xda2 <__bad_interrupt>
  44:	0c 94 d1 06 	jmp	0xda2	; 0xda2 <__bad_interrupt>
  48:	0c 94 d1 06 	jmp	0xda2	; 0xda2 <__bad_interrupt>
  4c:	0c 94 d1 06 	jmp	0xda2	; 0xda2 <__bad_interrupt>
  50:	0c 94 d1 06 	jmp	0xda2	; 0xda2 <__bad_interrupt>
  54:	77 04       	cpc	r7, r7
  56:	7b 04       	cpc	r7, r11
  58:	80 04       	cpc	r8, r0
  5a:	85 04       	cpc	r8, r5
  5c:	8a 04       	cpc	r8, r10
  5e:	8f 04       	cpc	r8, r15
  60:	94 04       	cpc	r9, r4
  62:	99 04       	cpc	r9, r9

00000064 <.dinit>:
  64:	00 60       	ori	r16, 0x00	; 0
  66:	00 88       	ldd	r0, Z+16	; 0x10
  68:	80 00       	.word	0x0080	; ????
  6a:	88 00       	.word	0x0088	; ????
  6c:	8a 00       	.word	0x008a	; ????
  6e:	0d b0       	in	r0, 0x0d	; 13
  70:	00 8a       	std	Z+16, r0	; 0x10
  72:	00 99       	sbic	0x00, 0	; 0
  74:	80 00       	.word	0x0080	; ????

00000076 <__ctors_end>:
  76:	11 24       	eor	r1, r1
  78:	1f be       	out	0x3f, r1	; 63
  7a:	cf e5       	ldi	r28, 0x5F	; 95
  7c:	d8 e0       	ldi	r29, 0x08	; 8
  7e:	de bf       	out	0x3e, r29	; 62
  80:	cd bf       	out	0x3d, r28	; 61

00000082 <__do_copy_data>:
  82:	e4 e6       	ldi	r30, 0x64	; 100
  84:	f0 e0       	ldi	r31, 0x00	; 0
  86:	40 e0       	ldi	r20, 0x00	; 0
  88:	17 c0       	rjmp	.+46     	; 0xb8 <__do_clear_bss+0x8>
  8a:	b5 91       	lpm	r27, Z+
  8c:	a5 91       	lpm	r26, Z+
  8e:	35 91       	lpm	r19, Z+
  90:	25 91       	lpm	r18, Z+
  92:	05 91       	lpm	r16, Z+
  94:	07 fd       	sbrc	r16, 7
  96:	0c c0       	rjmp	.+24     	; 0xb0 <__do_clear_bss>
  98:	95 91       	lpm	r25, Z+
  9a:	85 91       	lpm	r24, Z+
  9c:	ef 01       	movw	r28, r30
  9e:	f9 2f       	mov	r31, r25
  a0:	e8 2f       	mov	r30, r24
  a2:	05 90       	lpm	r0, Z+
  a4:	0d 92       	st	X+, r0
  a6:	a2 17       	cp	r26, r18
  a8:	b3 07       	cpc	r27, r19
  aa:	d9 f7       	brne	.-10     	; 0xa2 <__do_copy_data+0x20>
  ac:	fe 01       	movw	r30, r28
  ae:	04 c0       	rjmp	.+8      	; 0xb8 <__do_clear_bss+0x8>

000000b0 <__do_clear_bss>:
  b0:	1d 92       	st	X+, r1
  b2:	a2 17       	cp	r26, r18
  b4:	b3 07       	cpc	r27, r19
  b6:	e1 f7       	brne	.-8      	; 0xb0 <__do_clear_bss>
  b8:	e5 37       	cpi	r30, 0x75	; 117
  ba:	f4 07       	cpc	r31, r20
  bc:	31 f7       	brne	.-52     	; 0x8a <__do_copy_data+0x8>
  be:	0e 94 eb 05 	call	0xbd6	; 0xbd6 <main>
  c2:	0c 94 47 06 	jmp	0xc8e	; 0xc8e <exit>

000000c6 <_exit>:
  c6:	f8 94       	cli

000000c8 <__stop_program>:
  c8:	ff cf       	rjmp	.-2      	; 0xc8 <__stop_program>

Disassembly of section .text:

00000da2 <__bad_interrupt>:
 da2:	0c 94 00 00 	jmp	0	; 0x0 <__TEXT_REGION_ORIGIN__>

Disassembly of section .text.App_Init:

00000998 <App_Init>:
//variables (LOCAL But golbal to debugg)
uint16_t UART_Rdata=0;
volatile E2PROM_State currentState =Normal_state;
uint16_t speed=0;

void App_Init(void){
 998:	0f 93       	push	r16
	/*		Initializations		*/
	DC_Initialize(DC_mach1);
 99a:	80 91 93 00 	lds	r24, 0x0093	; 0x800093 <DC_mach1>
 99e:	0e 94 a4 04 	call	0x948	; 0x948 <DC_Initialize>
	ServoMotor_Initialize();
 9a2:	0e 94 36 06 	call	0xc6c	; 0xc6c <ServoMotor_Initialize>
	LED1_Initialize();
 9a6:	0e 94 83 06 	call	0xd06	; 0xd06 <LED1_Initialize>
	LED2_Initialize();
 9aa:	0e 94 95 06 	call	0xd2a	; 0xd2a <LED2_Initialize>
	LED3_Initialize();
 9ae:	0e 94 a7 06 	call	0xd4e	; 0xd4e <LED3_Initialize>
	//LED4_Initialize();
	BUZZER_Initialize();
 9b2:	0e 94 71 06 	call	0xce2	; 0xce2 <BUZZER_Initialize>
	ADC_Initialize(AVCC,ADC_PRE0);
 9b6:	60 e0       	ldi	r22, 0x00	; 0
 9b8:	81 e0       	ldi	r24, 0x01	; 1
 9ba:	0e 94 63 06 	call	0xcc6	; 0xcc6 <ADC_Initialize>
	uart_status UART_State= UART_Initialize_WithoutInterrupt(UART_9600,Synchronous, Disable , Bits_8, Bit_1);
 9be:	00 e0       	ldi	r16, 0x00	; 0
 9c0:	23 e0       	ldi	r18, 0x03	; 3
 9c2:	40 e0       	ldi	r20, 0x00	; 0
 9c4:	61 e0       	ldi	r22, 0x01	; 1
 9c6:	80 e6       	ldi	r24, 0x60	; 96
 9c8:	90 e0       	ldi	r25, 0x00	; 0
 9ca:	0e 94 b9 01 	call	0x372	; 0x372 <UART_Initialize_WithoutInterrupt>
	if(UART_State==UART_NOK){
 9ce:	88 23       	and	r24, r24
 9d0:	41 f0       	breq	.+16     	; 0x9e2 <App_Init+0x4a>
		return ;
	}
	
	//Start the machine
	ServoMotor_Rotate(90);
 9d2:	8a e5       	ldi	r24, 0x5A	; 90
 9d4:	0e 94 52 06 	call	0xca4	; 0xca4 <ServoMotor_Rotate>
	DC_Start(DC_mach1,DC_CW);
 9d8:	60 e0       	ldi	r22, 0x00	; 0
 9da:	80 91 93 00 	lds	r24, 0x0093	; 0x800093 <DC_mach1>
 9de:	0e 94 e3 03 	call	0x7c6	; 0x7c6 <DC_Start>
}
 9e2:	0f 91       	pop	r16
 9e4:	08 95       	ret

Disassembly of section .text.handle_Mes:

00000242 <handle_Mes>:

void handle_Mes(temp T,dc_motor DC_MOT, E2PROM_State* S){
 242:	af 92       	push	r10
 244:	bf 92       	push	r11
 246:	cf 92       	push	r12
 248:	df 92       	push	r13
 24a:	ef 92       	push	r14
 24c:	ff 92       	push	r15
 24e:	1f 93       	push	r17
 250:	cf 93       	push	r28
 252:	df 93       	push	r29
 254:	ec 01       	movw	r28, r24
 256:	16 2f       	mov	r17, r22
 258:	5a 01       	movw	r10, r20
	
	// off all LED and Buzzer
	LED1_OFF();
 25a:	0e 94 8f 06 	call	0xd1e	; 0xd1e <LED1_OFF>
	LED2_OFF();
 25e:	0e 94 a1 06 	call	0xd42	; 0xd42 <LED2_OFF>
	LED3_OFF();
 262:	0e 94 b3 06 	call	0xd66	; 0xd66 <LED3_OFF>
	BUZZER_OFF();
 266:	0e 94 7d 06 	call	0xcfa	; 0xcfa <BUZZER_OFF>
	DC_Start(DC_MOT,DC_CW);
 26a:	60 e0       	ldi	r22, 0x00	; 0
 26c:	81 2f       	mov	r24, r17
 26e:	0e 94 e3 03 	call	0x7c6	; 0x7c6 <DC_Start>
	
	if(T<=20.0){
 272:	be 01       	movw	r22, r28
 274:	80 e0       	ldi	r24, 0x00	; 0
 276:	90 e0       	ldi	r25, 0x00	; 0
 278:	0e 94 2d 04 	call	0x85a	; 0x85a <__floatunsisf>
 27c:	6b 01       	movw	r12, r22
 27e:	7c 01       	movw	r14, r24
 280:	20 e0       	ldi	r18, 0x00	; 0
 282:	30 e0       	ldi	r19, 0x00	; 0
 284:	40 ea       	ldi	r20, 0xA0	; 160
 286:	51 e4       	ldi	r21, 0x41	; 65
 288:	0e 94 c4 06 	call	0xd88	; 0xd88 <__cmpsf2>
 28c:	18 16       	cp	r1, r24
 28e:	2c f0       	brlt	.+10     	; 0x29a <handle_Mes+0x58>
		LED3_ON();
 290:	0e 94 ad 06 	call	0xd5a	; 0xd5a <LED3_ON>
		*S=Normal_state;
 294:	f5 01       	movw	r30, r10
 296:	10 82       	st	Z, r1
 298:	62 c0       	rjmp	.+196    	; 0x35e <handle_Mes+0x11c>
	}
	else if (T>20.0 && T<=40.0){
 29a:	20 e0       	ldi	r18, 0x00	; 0
 29c:	30 e0       	ldi	r19, 0x00	; 0
 29e:	40 ea       	ldi	r20, 0xA0	; 160
 2a0:	51 e4       	ldi	r21, 0x41	; 65
 2a2:	c7 01       	movw	r24, r14
 2a4:	b6 01       	movw	r22, r12
 2a6:	0e 94 c9 06 	call	0xd92	; 0xd92 <__gesf2>
 2aa:	18 16       	cp	r1, r24
 2ac:	7c f4       	brge	.+30     	; 0x2cc <handle_Mes+0x8a>
 2ae:	20 e0       	ldi	r18, 0x00	; 0
 2b0:	30 e0       	ldi	r19, 0x00	; 0
 2b2:	40 e2       	ldi	r20, 0x20	; 32
 2b4:	52 e4       	ldi	r21, 0x42	; 66
 2b6:	c7 01       	movw	r24, r14
 2b8:	b6 01       	movw	r22, r12
 2ba:	0e 94 c4 06 	call	0xd88	; 0xd88 <__cmpsf2>
 2be:	18 16       	cp	r1, r24
 2c0:	2c f0       	brlt	.+10     	; 0x2cc <handle_Mes+0x8a>
		LED2_ON();
 2c2:	0e 94 9b 06 	call	0xd36	; 0xd36 <LED2_ON>
		*S=Normal_state;
 2c6:	f5 01       	movw	r30, r10
 2c8:	10 82       	st	Z, r1
 2ca:	49 c0       	rjmp	.+146    	; 0x35e <handle_Mes+0x11c>
	}
	else if (T>40.0 && T<=50.0){
 2cc:	20 e0       	ldi	r18, 0x00	; 0
 2ce:	30 e0       	ldi	r19, 0x00	; 0
 2d0:	40 e2       	ldi	r20, 0x20	; 32
 2d2:	52 e4       	ldi	r21, 0x42	; 66
 2d4:	c7 01       	movw	r24, r14
 2d6:	b6 01       	movw	r22, r12
 2d8:	0e 94 c9 06 	call	0xd92	; 0xd92 <__gesf2>
 2dc:	18 16       	cp	r1, r24
 2de:	6c f4       	brge	.+26     	; 0x2fa <handle_Mes+0xb8>
 2e0:	20 e0       	ldi	r18, 0x00	; 0
 2e2:	30 e0       	ldi	r19, 0x00	; 0
 2e4:	48 e4       	ldi	r20, 0x48	; 72
 2e6:	52 e4       	ldi	r21, 0x42	; 66
 2e8:	c7 01       	movw	r24, r14
 2ea:	b6 01       	movw	r22, r12
 2ec:	0e 94 c4 06 	call	0xd88	; 0xd88 <__cmpsf2>
 2f0:	18 16       	cp	r1, r24
 2f2:	1c f0       	brlt	.+6      	; 0x2fa <handle_Mes+0xb8>
		LED1_ON();
 2f4:	0e 94 89 06 	call	0xd12	; 0xd12 <LED1_ON>
 2f8:	32 c0       	rjmp	.+100    	; 0x35e <handle_Mes+0x11c>
	}
	else if (T==Off_Mes)
 2fa:	cf 3f       	cpi	r28, 0xFF	; 255
 2fc:	d1 05       	cpc	r29, r1
 2fe:	49 f4       	brne	.+18     	; 0x312 <handle_Mes+0xd0>
	{
		*S=Off_state;
 300:	83 e0       	ldi	r24, 0x03	; 3
 302:	f5 01       	movw	r30, r10
 304:	80 83       	st	Z, r24
		LED1_ON();
 306:	0e 94 89 06 	call	0xd12	; 0xd12 <LED1_ON>
		DC_Stop(DC_MOT);
 30a:	81 2f       	mov	r24, r17
 30c:	0e 94 f3 04 	call	0x9e6	; 0x9e6 <DC_Stop>
 310:	26 c0       	rjmp	.+76     	; 0x35e <handle_Mes+0x11c>
	}
	else if (T==Emergency_Mes)
 312:	cc 32       	cpi	r28, 0x2C	; 44
 314:	f1 e0       	ldi	r31, 0x01	; 1
 316:	df 07       	cpc	r29, r31
 318:	41 f4       	brne	.+16     	; 0x32a <handle_Mes+0xe8>
	{
		*S=Emergency_state;
 31a:	81 e0       	ldi	r24, 0x01	; 1
 31c:	f5 01       	movw	r30, r10
 31e:	80 83       	st	Z, r24
		LED1_ON();
 320:	0e 94 89 06 	call	0xd12	; 0xd12 <LED1_ON>
		BUZZER_ON();
 324:	0e 94 77 06 	call	0xcee	; 0xcee <BUZZER_ON>
 328:	1a c0       	rjmp	.+52     	; 0x35e <handle_Mes+0x11c>
	}
	else if (T==Abnormal_Mes)
 32a:	ce 35       	cpi	r28, 0x5E	; 94
 32c:	d1 40       	sbci	r29, 0x01	; 1
 32e:	71 f4       	brne	.+28     	; 0x34c <handle_Mes+0x10a>
	{
		*S=Abnormal_Mes;
 330:	8e e5       	ldi	r24, 0x5E	; 94
 332:	f5 01       	movw	r30, r10
 334:	80 83       	st	Z, r24
		LED1_ON();
 336:	0e 94 89 06 	call	0xd12	; 0xd12 <LED1_ON>
		BUZZER_ON();
 33a:	0e 94 77 06 	call	0xcee	; 0xcee <BUZZER_ON>
		DC_Stop(DC_MOT);
 33e:	81 2f       	mov	r24, r17
 340:	0e 94 f3 04 	call	0x9e6	; 0x9e6 <DC_Stop>
		ServoMotor_Rotate(90);
 344:	8a e5       	ldi	r24, 0x5A	; 90
 346:	0e 94 52 06 	call	0xca4	; 0xca4 <ServoMotor_Rotate>
 34a:	09 c0       	rjmp	.+18     	; 0x35e <handle_Mes+0x11c>
		
	}
	else {
		//for debugg
		LED1_ON();
 34c:	0e 94 89 06 	call	0xd12	; 0xd12 <LED1_ON>
		LED2_ON();
 350:	0e 94 9b 06 	call	0xd36	; 0xd36 <LED2_ON>
		LED3_ON();
 354:	0e 94 ad 06 	call	0xd5a	; 0xd5a <LED3_ON>
		*S=Emergency_state;
 358:	81 e0       	ldi	r24, 0x01	; 1
 35a:	f5 01       	movw	r30, r10
 35c:	80 83       	st	Z, r24
	}
}
 35e:	df 91       	pop	r29
 360:	cf 91       	pop	r28
 362:	1f 91       	pop	r17
 364:	ff 90       	pop	r15
 366:	ef 90       	pop	r14
 368:	df 90       	pop	r13
 36a:	cf 90       	pop	r12
 36c:	bf 90       	pop	r11
 36e:	af 90       	pop	r10
 370:	08 95       	ret

Disassembly of section .text.BUZZER_Initialize:

00000ce2 <BUZZER_Initialize>:



void BUZZER_Initialize(void)
{
	DIO_SetPinDirection(BUZZER_PORT, BUZZER_PIN, BUZZER_OUTPUT);
 ce2:	41 e0       	ldi	r20, 0x01	; 1
 ce4:	64 e0       	ldi	r22, 0x04	; 4
 ce6:	81 e0       	ldi	r24, 0x01	; 1
 ce8:	0e 94 49 02 	call	0x492	; 0x492 <DIO_SetPinDirection>
 cec:	08 95       	ret

Disassembly of section .text.BUZZER_ON:

00000cee <BUZZER_ON>:
}
void BUZZER_ON(void)
{
	DIO_SetPinValue(BUZZER_PORT, BUZZER_PIN, BUZZER_HIGH);
 cee:	41 e0       	ldi	r20, 0x01	; 1
 cf0:	64 e0       	ldi	r22, 0x04	; 4
 cf2:	81 e0       	ldi	r24, 0x01	; 1
 cf4:	0e 94 ba 02 	call	0x574	; 0x574 <DIO_SetPinValue>
 cf8:	08 95       	ret

Disassembly of section .text.BUZZER_OFF:

00000cfa <BUZZER_OFF>:
}
void BUZZER_OFF(void)
{
	DIO_SetPinValue(BUZZER_PORT, BUZZER_PIN, BUZZER_LOW);
 cfa:	40 e0       	ldi	r20, 0x00	; 0
 cfc:	64 e0       	ldi	r22, 0x04	; 4
 cfe:	81 e0       	ldi	r24, 0x01	; 1
 d00:	0e 94 ba 02 	call	0x574	; 0x574 <DIO_SetPinValue>
 d04:	08 95       	ret

Disassembly of section .text.LED1_Initialize:

00000d06 <LED1_Initialize>:

static char num_arr[]={0xC0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90};

void LED1_Initialize(void)
{
	DIO_SetPinDirection(LED1_PORT, LED1_PIN, LED1_OUTPUT);
 d06:	41 e0       	ldi	r20, 0x01	; 1
 d08:	60 e0       	ldi	r22, 0x00	; 0
 d0a:	81 e0       	ldi	r24, 0x01	; 1
 d0c:	0e 94 49 02 	call	0x492	; 0x492 <DIO_SetPinDirection>
 d10:	08 95       	ret

Disassembly of section .text.LED1_ON:

00000d12 <LED1_ON>:
}
void LED1_ON(void)
{
	DIO_SetPinValue(LED1_PORT, LED1_PIN, LED1_HIGH);
 d12:	41 e0       	ldi	r20, 0x01	; 1
 d14:	60 e0       	ldi	r22, 0x00	; 0
 d16:	81 e0       	ldi	r24, 0x01	; 1
 d18:	0e 94 ba 02 	call	0x574	; 0x574 <DIO_SetPinValue>
 d1c:	08 95       	ret

Disassembly of section .text.LED1_OFF:

00000d1e <LED1_OFF>:
}
void LED1_OFF(void)
{
	DIO_SetPinValue(LED1_PORT, LED1_PIN, LED1_LOW);
 d1e:	40 e0       	ldi	r20, 0x00	; 0
 d20:	60 e0       	ldi	r22, 0x00	; 0
 d22:	81 e0       	ldi	r24, 0x01	; 1
 d24:	0e 94 ba 02 	call	0x574	; 0x574 <DIO_SetPinValue>
 d28:	08 95       	ret

Disassembly of section .text.LED2_Initialize:

00000d2a <LED2_Initialize>:

#include "LED2_Private.h"

void LED2_Initialize(void)
{
	DIO_SetPinDirection(LED2_PORT, LED2_PIN, LED2_OUTPUT);
 d2a:	41 e0       	ldi	r20, 0x01	; 1
 d2c:	61 e0       	ldi	r22, 0x01	; 1
 d2e:	81 e0       	ldi	r24, 0x01	; 1
 d30:	0e 94 49 02 	call	0x492	; 0x492 <DIO_SetPinDirection>
 d34:	08 95       	ret

Disassembly of section .text.LED2_ON:

00000d36 <LED2_ON>:
}
void LED2_ON(void)
{
	DIO_SetPinValue(LED2_PORT, LED2_PIN, LED2_HIGH);
 d36:	41 e0       	ldi	r20, 0x01	; 1
 d38:	61 e0       	ldi	r22, 0x01	; 1
 d3a:	81 e0       	ldi	r24, 0x01	; 1
 d3c:	0e 94 ba 02 	call	0x574	; 0x574 <DIO_SetPinValue>
 d40:	08 95       	ret

Disassembly of section .text.LED2_OFF:

00000d42 <LED2_OFF>:
}
void LED2_OFF(void)
{
	DIO_SetPinValue(LED2_PORT, LED2_PIN, LED2_LOW);
 d42:	40 e0       	ldi	r20, 0x00	; 0
 d44:	61 e0       	ldi	r22, 0x01	; 1
 d46:	81 e0       	ldi	r24, 0x01	; 1
 d48:	0e 94 ba 02 	call	0x574	; 0x574 <DIO_SetPinValue>
 d4c:	08 95       	ret

Disassembly of section .text.LED3_Initialize:

00000d4e <LED3_Initialize>:

#include "LED3_Private.h"

void LED3_Initialize(void)
{
	DIO_SetPinDirection(LED3_PORT, LED3_PIN, LED3_OUTPUT);
 d4e:	41 e0       	ldi	r20, 0x01	; 1
 d50:	62 e0       	ldi	r22, 0x02	; 2
 d52:	81 e0       	ldi	r24, 0x01	; 1
 d54:	0e 94 49 02 	call	0x492	; 0x492 <DIO_SetPinDirection>
 d58:	08 95       	ret

Disassembly of section .text.LED3_ON:

00000d5a <LED3_ON>:
}
void LED3_ON(void)
{
	DIO_SetPinValue(LED3_PORT, LED3_PIN, LED3_HIGH);
 d5a:	41 e0       	ldi	r20, 0x01	; 1
 d5c:	62 e0       	ldi	r22, 0x02	; 2
 d5e:	81 e0       	ldi	r24, 0x01	; 1
 d60:	0e 94 ba 02 	call	0x574	; 0x574 <DIO_SetPinValue>
 d64:	08 95       	ret

Disassembly of section .text.LED3_OFF:

00000d66 <LED3_OFF>:
}
void LED3_OFF(void)
{
	DIO_SetPinValue(LED3_PORT, LED3_PIN, LED3_LOW);
 d66:	40 e0       	ldi	r20, 0x00	; 0
 d68:	62 e0       	ldi	r22, 0x02	; 2
 d6a:	81 e0       	ldi	r24, 0x01	; 1
 d6c:	0e 94 ba 02 	call	0x574	; 0x574 <DIO_SetPinValue>
 d70:	08 95       	ret

Disassembly of section .text.DC_Initialize:

00000948 <DC_Initialize>:

#include "DC_Private.h"

void DC_Initialize(dc_motor motor)
{	
	switch(motor)
 948:	88 23       	and	r24, r24
 94a:	19 f0       	breq	.+6      	; 0x952 <DC_Initialize+0xa>
 94c:	81 30       	cpi	r24, 0x01	; 1
 94e:	a1 f0       	breq	.+40     	; 0x978 <DC_Initialize+0x30>
 950:	08 95       	ret
	{
		case DC_Motor1:
		DIO_SetPinDirection(DC_Enable_Port, DC_Enable1_Pin, DC_OUTPUT);
 952:	41 e0       	ldi	r20, 0x01	; 1
 954:	63 e0       	ldi	r22, 0x03	; 3
 956:	81 e0       	ldi	r24, 0x01	; 1
 958:	0e 94 49 02 	call	0x492	; 0x492 <DIO_SetPinDirection>
		DIO_SetPinDirection(DC_Motor_Port, DC_Motor1_A1, DC_OUTPUT);
 95c:	41 e0       	ldi	r20, 0x01	; 1
 95e:	61 e0       	ldi	r22, 0x01	; 1
 960:	82 e0       	ldi	r24, 0x02	; 2
 962:	0e 94 49 02 	call	0x492	; 0x492 <DIO_SetPinDirection>
		DIO_SetPinDirection(DC_Motor_Port, DC_Motor1_A2, DC_OUTPUT);
 966:	41 e0       	ldi	r20, 0x01	; 1
 968:	62 e0       	ldi	r22, 0x02	; 2
 96a:	82 e0       	ldi	r24, 0x02	; 2
 96c:	0e 94 49 02 	call	0x492	; 0x492 <DIO_SetPinDirection>
		TCNT0 = 0;			/* Set timer0 count zero */
 970:	12 be       	out	0x32, r1	; 50
		TCCR0 = (1<<WGM00)|(1<<WGM01)|(1<<COM01)|(1<<CS00)|(1<<CS01);/* Set Fast PWM with Fosc/64 Timer0 clock */
 972:	8b e6       	ldi	r24, 0x6B	; 107
 974:	83 bf       	out	0x33, r24	; 51
		break;
 976:	08 95       	ret
		case DC_Motor2:
		DIO_SetPinDirection(DC_Enable_Port, DC_Enable2_Pin, DC_OUTPUT);
 978:	41 e0       	ldi	r20, 0x01	; 1
 97a:	62 e0       	ldi	r22, 0x02	; 2
 97c:	81 e0       	ldi	r24, 0x01	; 1
 97e:	0e 94 49 02 	call	0x492	; 0x492 <DIO_SetPinDirection>
		DIO_SetPinDirection(DC_Motor_Port, DC_Motor2_A3, DC_OUTPUT);
 982:	41 e0       	ldi	r20, 0x01	; 1
 984:	62 e0       	ldi	r22, 0x02	; 2
 986:	82 e0       	ldi	r24, 0x02	; 2
 988:	0e 94 49 02 	call	0x492	; 0x492 <DIO_SetPinDirection>
		DIO_SetPinDirection(DC_Motor_Port, DC_Motor2_A4, DC_OUTPUT);
 98c:	41 e0       	ldi	r20, 0x01	; 1
 98e:	62 e0       	ldi	r22, 0x02	; 2
 990:	82 e0       	ldi	r24, 0x02	; 2
 992:	0e 94 49 02 	call	0x492	; 0x492 <DIO_SetPinDirection>
 996:	08 95       	ret

Disassembly of section .text.DC_Start:

000007c6 <DC_Start>:
	}
	
}

void DC_Start(dc_motor motor, dc_motor_direction direction)
{	
 7c6:	cf 93       	push	r28
 7c8:	c6 2f       	mov	r28, r22
	switch(motor)
 7ca:	88 23       	and	r24, r24
 7cc:	19 f0       	breq	.+6      	; 0x7d4 <DC_Start+0xe>
 7ce:	81 30       	cpi	r24, 0x01	; 1
 7d0:	19 f1       	breq	.+70     	; 0x818 <__DATA_REGION_LENGTH__+0x18>
 7d2:	41 c0       	rjmp	.+130    	; 0x856 <__DATA_REGION_LENGTH__+0x56>
	{
		case DC_Motor1:
		DIO_SetPinValue(DC_Enable_Port, DC_Enable1_Pin, DC_HIGH);
 7d4:	41 e0       	ldi	r20, 0x01	; 1
 7d6:	63 e0       	ldi	r22, 0x03	; 3
 7d8:	81 e0       	ldi	r24, 0x01	; 1
 7da:	0e 94 ba 02 	call	0x574	; 0x574 <DIO_SetPinValue>
		OCR0=125;
 7de:	8d e7       	ldi	r24, 0x7D	; 125
 7e0:	8c bf       	out	0x3c, r24	; 60
		switch(direction)
 7e2:	cc 23       	and	r28, r28
 7e4:	19 f0       	breq	.+6      	; 0x7ec <DC_Start+0x26>
 7e6:	c1 30       	cpi	r28, 0x01	; 1
 7e8:	61 f0       	breq	.+24     	; 0x802 <__DATA_REGION_LENGTH__+0x2>
 7ea:	35 c0       	rjmp	.+106    	; 0x856 <__DATA_REGION_LENGTH__+0x56>
		{
			case DC_CW:
			DIO_SetPinValue(DC_Motor_Port, DC_Motor1_A1, DC_HIGH);
 7ec:	41 e0       	ldi	r20, 0x01	; 1
 7ee:	61 e0       	ldi	r22, 0x01	; 1
 7f0:	82 e0       	ldi	r24, 0x02	; 2
 7f2:	0e 94 ba 02 	call	0x574	; 0x574 <DIO_SetPinValue>
			DIO_SetPinValue(DC_Motor_Port, DC_Motor1_A2, DC_LOW);
 7f6:	40 e0       	ldi	r20, 0x00	; 0
 7f8:	62 e0       	ldi	r22, 0x02	; 2
 7fa:	82 e0       	ldi	r24, 0x02	; 2
 7fc:	0e 94 ba 02 	call	0x574	; 0x574 <DIO_SetPinValue>
			break;
 800:	2a c0       	rjmp	.+84     	; 0x856 <__DATA_REGION_LENGTH__+0x56>
			case DC_CCW:
			DIO_SetPinValue(DC_Motor_Port, DC_Motor1_A1, DC_LOW);
 802:	40 e0       	ldi	r20, 0x00	; 0
 804:	61 e0       	ldi	r22, 0x01	; 1
 806:	82 e0       	ldi	r24, 0x02	; 2
 808:	0e 94 ba 02 	call	0x574	; 0x574 <DIO_SetPinValue>
			DIO_SetPinValue(DC_Motor_Port, DC_Motor1_A2, DC_HIGH);
 80c:	41 e0       	ldi	r20, 0x01	; 1
 80e:	62 e0       	ldi	r22, 0x02	; 2
 810:	82 e0       	ldi	r24, 0x02	; 2
 812:	0e 94 ba 02 	call	0x574	; 0x574 <DIO_SetPinValue>
			break;
 816:	1f c0       	rjmp	.+62     	; 0x856 <__DATA_REGION_LENGTH__+0x56>
		}
		break;
		case DC_Motor2:
		DIO_SetPinValue(DC_Enable_Port, DC_Enable2_Pin, DC_HIGH);
 818:	41 e0       	ldi	r20, 0x01	; 1
 81a:	62 e0       	ldi	r22, 0x02	; 2
 81c:	81 e0       	ldi	r24, 0x01	; 1
 81e:	0e 94 ba 02 	call	0x574	; 0x574 <DIO_SetPinValue>
		switch(direction)
 822:	cc 23       	and	r28, r28
 824:	19 f0       	breq	.+6      	; 0x82c <__DATA_REGION_LENGTH__+0x2c>
 826:	c1 30       	cpi	r28, 0x01	; 1
 828:	61 f0       	breq	.+24     	; 0x842 <__DATA_REGION_LENGTH__+0x42>
 82a:	15 c0       	rjmp	.+42     	; 0x856 <__DATA_REGION_LENGTH__+0x56>
		{
			case DC_CW:
			DIO_SetPinValue(DC_Motor_Port, DC_Motor2_A3, DC_HIGH);
 82c:	41 e0       	ldi	r20, 0x01	; 1
 82e:	62 e0       	ldi	r22, 0x02	; 2
 830:	82 e0       	ldi	r24, 0x02	; 2
 832:	0e 94 ba 02 	call	0x574	; 0x574 <DIO_SetPinValue>
			DIO_SetPinValue(DC_Motor_Port, DC_Motor2_A4, DC_LOW);
 836:	40 e0       	ldi	r20, 0x00	; 0
 838:	62 e0       	ldi	r22, 0x02	; 2
 83a:	82 e0       	ldi	r24, 0x02	; 2
 83c:	0e 94 ba 02 	call	0x574	; 0x574 <DIO_SetPinValue>
			break;
 840:	0a c0       	rjmp	.+20     	; 0x856 <__DATA_REGION_LENGTH__+0x56>
			case DC_CCW:
			DIO_SetPinValue(DC_Motor_Port, DC_Motor2_A3, DC_LOW);
 842:	40 e0       	ldi	r20, 0x00	; 0
 844:	62 e0       	ldi	r22, 0x02	; 2
 846:	82 e0       	ldi	r24, 0x02	; 2
 848:	0e 94 ba 02 	call	0x574	; 0x574 <DIO_SetPinValue>
			DIO_SetPinValue(DC_Motor_Port, DC_Motor2_A4, DC_HIGH);
 84c:	41 e0       	ldi	r20, 0x01	; 1
 84e:	62 e0       	ldi	r22, 0x02	; 2
 850:	82 e0       	ldi	r24, 0x02	; 2
 852:	0e 94 ba 02 	call	0x574	; 0x574 <DIO_SetPinValue>
			break;
		}
		break;
	}
}
 856:	cf 91       	pop	r28
 858:	08 95       	ret

Disassembly of section .text.DC_Stop:

000009e6 <DC_Stop>:

void DC_Stop(dc_motor motor)
{
	switch(motor)
 9e6:	88 23       	and	r24, r24
 9e8:	19 f0       	breq	.+6      	; 0x9f0 <DC_Stop+0xa>
 9ea:	81 30       	cpi	r24, 0x01	; 1
 9ec:	99 f0       	breq	.+38     	; 0xa14 <DC_Stop+0x2e>
 9ee:	08 95       	ret
	{
		case DC_Motor1:
		OCR1B = 0;
 9f0:	19 bc       	out	0x29, r1	; 41
 9f2:	18 bc       	out	0x28, r1	; 40
		DIO_SetPinValue(DC_Enable_Port, DC_Enable1_Pin, DC_LOW);
 9f4:	40 e0       	ldi	r20, 0x00	; 0
 9f6:	63 e0       	ldi	r22, 0x03	; 3
 9f8:	81 e0       	ldi	r24, 0x01	; 1
 9fa:	0e 94 ba 02 	call	0x574	; 0x574 <DIO_SetPinValue>
		DIO_SetPinValue(DC_Motor_Port, DC_Motor1_A1, DC_LOW);
 9fe:	40 e0       	ldi	r20, 0x00	; 0
 a00:	61 e0       	ldi	r22, 0x01	; 1
 a02:	82 e0       	ldi	r24, 0x02	; 2
 a04:	0e 94 ba 02 	call	0x574	; 0x574 <DIO_SetPinValue>
		DIO_SetPinValue(DC_Motor_Port, DC_Motor1_A2, DC_LOW);
 a08:	40 e0       	ldi	r20, 0x00	; 0
 a0a:	62 e0       	ldi	r22, 0x02	; 2
 a0c:	82 e0       	ldi	r24, 0x02	; 2
 a0e:	0e 94 ba 02 	call	0x574	; 0x574 <DIO_SetPinValue>
		break;
 a12:	08 95       	ret
		case DC_Motor2:
		DIO_SetPinValue(DC_Enable_Port, DC_Enable2_Pin, DC_LOW);
 a14:	40 e0       	ldi	r20, 0x00	; 0
 a16:	62 e0       	ldi	r22, 0x02	; 2
 a18:	81 e0       	ldi	r24, 0x01	; 1
 a1a:	0e 94 ba 02 	call	0x574	; 0x574 <DIO_SetPinValue>
		DIO_SetPinValue(DC_Motor_Port, DC_Motor2_A3, DC_LOW);
 a1e:	40 e0       	ldi	r20, 0x00	; 0
 a20:	62 e0       	ldi	r22, 0x02	; 2
 a22:	82 e0       	ldi	r24, 0x02	; 2
 a24:	0e 94 ba 02 	call	0x574	; 0x574 <DIO_SetPinValue>
		DIO_SetPinValue(DC_Motor_Port, DC_Motor2_A4, DC_LOW);
 a28:	40 e0       	ldi	r20, 0x00	; 0
 a2a:	62 e0       	ldi	r22, 0x02	; 2
 a2c:	82 e0       	ldi	r24, 0x02	; 2
 a2e:	0e 94 ba 02 	call	0x574	; 0x574 <DIO_SetPinValue>
 a32:	08 95       	ret

Disassembly of section .text.DC_Change_Speed:

00000c10 <DC_Change_Speed>:
		break;
	}
}

void DC_Change_Speed(dc_motor motor,uint16_t speed)
{	switch (motor){
 c10:	88 23       	and	r24, r24
 c12:	19 f0       	breq	.+6      	; 0xc1a <DC_Change_Speed+0xa>
 c14:	81 30       	cpi	r24, 0x01	; 1
 c16:	61 f0       	breq	.+24     	; 0xc30 <DC_Change_Speed+0x20>
 c18:	08 95       	ret
		case DC_Motor1:
			OCR0 =(speed *100)/ 1024;
 c1a:	24 e6       	ldi	r18, 0x64	; 100
 c1c:	26 9f       	mul	r18, r22
 c1e:	c0 01       	movw	r24, r0
 c20:	27 9f       	mul	r18, r23
 c22:	90 0d       	add	r25, r0
 c24:	11 24       	eor	r1, r1
 c26:	89 2f       	mov	r24, r25
 c28:	86 95       	lsr	r24
 c2a:	86 95       	lsr	r24
 c2c:	8c bf       	out	0x3c, r24	; 60
		break;
 c2e:	08 95       	ret
		case DC_Motor2:
			OCR1A = speed/4;
 c30:	76 95       	lsr	r23
 c32:	67 95       	ror	r22
 c34:	76 95       	lsr	r23
 c36:	67 95       	ror	r22
 c38:	7b bd       	out	0x2b, r23	; 43
 c3a:	6a bd       	out	0x2a, r22	; 42
 c3c:	08 95       	ret

Disassembly of section .text.ServoMotor_Initialize:

00000c6c <ServoMotor_Initialize>:

#include "Servo_Private.h"

void ServoMotor_Initialize(void)
{
	DIO_SetPinDirection(SERVO_PORT, SERVO_PIN, DIO_OUTPUT);
 c6c:	82 b3       	in	r24, 0x12	; 18
 c6e:	41 e0       	ldi	r20, 0x01	; 1
 c70:	65 e0       	ldi	r22, 0x05	; 5
 c72:	0e 94 49 02 	call	0x492	; 0x492 <DIO_SetPinDirection>
	
	//ICR1 = 2499;		/* Set TOP count for timer1 in ICR1 register */

	/* Set Fast PWM, TOP in ICR1, Clear OC1A on compare match, clk/64 */
	TCCR1A = (1<<WGM11)|(1<<COM1A1);
 c76:	82 e8       	ldi	r24, 0x82	; 130
 c78:	8f bd       	out	0x2f, r24	; 47
	TCCR1B = (1<<WGM12)|(1<<WGM13)|(1<<CS10)|(1<<CS11);
 c7a:	8b e1       	ldi	r24, 0x1B	; 27
 c7c:	8e bd       	out	0x2e, r24	; 46
	sei();  // Enable global interrupts
 c7e:	78 94       	sei
	TCNT1 = 0;			/* Set timer1 count zero */
 c80:	1d bc       	out	0x2d, r1	; 45
 c82:	1c bc       	out	0x2c, r1	; 44
	ICR1 = 19999;  // Set top value for 20 ms period (50Hz)
 c84:	8f e1       	ldi	r24, 0x1F	; 31
 c86:	9e e4       	ldi	r25, 0x4E	; 78
 c88:	97 bd       	out	0x27, r25	; 39
 c8a:	86 bd       	out	0x26, r24	; 38
 c8c:	08 95       	ret

Disassembly of section .text.ServoMotor_Rotate:

00000ca4 <ServoMotor_Rotate>:
}

void ServoMotor_Rotate(uint8_t angle)
{
	// Map the angle (0-180) to the required pulse width (1000-2000 us)
	uint16_t pulse_width = (angle * 11) + 1000;
 ca4:	2b e0       	ldi	r18, 0x0B	; 11
 ca6:	82 9f       	mul	r24, r18
 ca8:	c0 01       	movw	r24, r0
 caa:	11 24       	eor	r1, r1
 cac:	88 51       	subi	r24, 0x18	; 24
 cae:	9c 4f       	sbci	r25, 0xFC	; 252
	
	// Set the pulse width to control the position of the servo
	OCR1A = pulse_width;
 cb0:	9b bd       	out	0x2b, r25	; 43
 cb2:	8a bd       	out	0x2a, r24	; 42
 cb4:	08 95       	ret

Disassembly of section .text.main:

00000bd6 <main>:
extern volatile E2PROM_State currentState;
extern uint16_t speed;

int main(void)
{	
	App_Init();
 bd6:	0e 94 cc 04 	call	0x998	; 0x998 <App_Init>
	
	/*	Main	Code	*/
    while(1)
    {	
		/* Recieve the message (Temperature)	*/
		UART_Receive_Word(&UART_Rdata);
 bda:	86 e8       	ldi	r24, 0x86	; 134
 bdc:	90 e0       	ldi	r25, 0x00	; 0
 bde:	0e 94 40 05 	call	0xa80	; 0xa80 <UART_Receive_Word>
		
		speed=ADC_Read(POT1_PIN);
 be2:	80 e0       	ldi	r24, 0x00	; 0
 be4:	0e 94 6a 04 	call	0x8d4	; 0x8d4 <ADC_Read>
 be8:	90 93 85 00 	sts	0x0085, r25	; 0x800085 <speed+0x1>
 bec:	80 93 84 00 	sts	0x0084, r24	; 0x800084 <speed>
		
		DC_Change_Speed(DC_mach1,speed);
 bf0:	bc 01       	movw	r22, r24
 bf2:	80 91 93 00 	lds	r24, 0x0093	; 0x800093 <DC_mach1>
 bf6:	0e 94 08 06 	call	0xc10	; 0xc10 <DC_Change_Speed>
		//Send the message (Speed)	
		UART_Transmit_Speed(speed);
		*/
		
		/* Handle the message	*/
		handle_Mes(UART_Rdata,DC_mach1,&currentState);
 bfa:	42 e9       	ldi	r20, 0x92	; 146
 bfc:	50 e0       	ldi	r21, 0x00	; 0
 bfe:	60 91 93 00 	lds	r22, 0x0093	; 0x800093 <DC_mach1>
 c02:	80 91 86 00 	lds	r24, 0x0086	; 0x800086 <UART_Rdata>
 c06:	90 91 87 00 	lds	r25, 0x0087	; 0x800087 <UART_Rdata+0x1>
 c0a:	0e 94 21 01 	call	0x242	; 0x242 <handle_Mes>
 c0e:	e5 cf       	rjmp	.-54     	; 0xbda <main+0x4>

Disassembly of section .text.ADC_Initialize:

00000cc6 <ADC_Initialize>:

#include "ADC_Private.h"

void ADC_Initialize(adc_vref voltage , adc_prescaler prescaler)
{
	ADMUX |= 0x40;
 cc6:	87 b1       	in	r24, 0x07	; 7
 cc8:	80 64       	ori	r24, 0x40	; 64
 cca:	87 b9       	out	0x07, r24	; 7
	ADCSRA |= 0xA7;
 ccc:	86 b1       	in	r24, 0x06	; 6
 cce:	87 6a       	ori	r24, 0xA7	; 167
 cd0:	86 b9       	out	0x06, r24	; 6
 cd2:	08 95       	ret

Disassembly of section .text.ADC_Read:

000008d4 <ADC_Read>:
}

uint16_t ADC_Read(adc_channel channel)
{
 8d4:	e8 2f       	mov	r30, r24
	uint16_t val = 0;

	// Clear the ADC result register by reading it once
	uint16_t dummy = ADC_VAL;
 8d6:	84 b1       	in	r24, 0x04	; 4
 8d8:	95 b1       	in	r25, 0x05	; 5
 
	// Select the ADC channel
	switch (channel)
 8da:	8e 2f       	mov	r24, r30
 8dc:	90 e0       	ldi	r25, 0x00	; 0
 8de:	88 30       	cpi	r24, 0x08	; 8
 8e0:	91 05       	cpc	r25, r1
 8e2:	50 f5       	brcc	.+84     	; 0x938 <ADC_Read+0x64>
 8e4:	fc 01       	movw	r30, r24
 8e6:	e6 5d       	subi	r30, 0xD6	; 214
 8e8:	ff 4f       	sbci	r31, 0xFF	; 255
 8ea:	0c 94 b9 06 	jmp	0xd72	; 0xd72 <__tablejump2__>
	{
		case ADC_0:
		ADMUX = (ADMUX & 0xF8) | 0x00; // Clear the channel bits and set ADC0
 8ee:	87 b1       	in	r24, 0x07	; 7
 8f0:	88 7f       	andi	r24, 0xF8	; 248
 8f2:	87 b9       	out	0x07, r24	; 7
		break;
 8f4:	21 c0       	rjmp	.+66     	; 0x938 <ADC_Read+0x64>
		case ADC_1:
		ADMUX = (ADMUX & 0xF8) | 0x01; // Clear the channel bits and set ADC1
 8f6:	87 b1       	in	r24, 0x07	; 7
 8f8:	88 7f       	andi	r24, 0xF8	; 248
 8fa:	81 60       	ori	r24, 0x01	; 1
 8fc:	87 b9       	out	0x07, r24	; 7
		break;
 8fe:	1c c0       	rjmp	.+56     	; 0x938 <ADC_Read+0x64>
		case ADC_2:
		ADMUX = (ADMUX & 0xF8) | 0x02; // Clear the channel bits and set ADC2
 900:	87 b1       	in	r24, 0x07	; 7
 902:	88 7f       	andi	r24, 0xF8	; 248
 904:	82 60       	ori	r24, 0x02	; 2
 906:	87 b9       	out	0x07, r24	; 7
		break;
 908:	17 c0       	rjmp	.+46     	; 0x938 <ADC_Read+0x64>
		case ADC_3:
		ADMUX = (ADMUX & 0xF8) | 0x03; // Clear the channel bits and set ADC3
 90a:	87 b1       	in	r24, 0x07	; 7
 90c:	88 7f       	andi	r24, 0xF8	; 248
 90e:	83 60       	ori	r24, 0x03	; 3
 910:	87 b9       	out	0x07, r24	; 7
		break;
 912:	12 c0       	rjmp	.+36     	; 0x938 <ADC_Read+0x64>
		case ADC_4:
		ADMUX = (ADMUX & 0xF8) | 0x04; // Clear the channel bits and set ADC4
 914:	87 b1       	in	r24, 0x07	; 7
 916:	88 7f       	andi	r24, 0xF8	; 248
 918:	84 60       	ori	r24, 0x04	; 4
 91a:	87 b9       	out	0x07, r24	; 7
		break;
 91c:	0d c0       	rjmp	.+26     	; 0x938 <ADC_Read+0x64>
		case ADC_5:
		ADMUX = (ADMUX & 0xF8) | 0x05; // Clear the channel bits and set ADC5
 91e:	87 b1       	in	r24, 0x07	; 7
 920:	88 7f       	andi	r24, 0xF8	; 248
 922:	85 60       	ori	r24, 0x05	; 5
 924:	87 b9       	out	0x07, r24	; 7
		break;
 926:	08 c0       	rjmp	.+16     	; 0x938 <ADC_Read+0x64>
		case ADC_6:
		ADMUX = (ADMUX & 0xF8) | 0x06; // Clear the channel bits and set ADC6
 928:	87 b1       	in	r24, 0x07	; 7
 92a:	88 7f       	andi	r24, 0xF8	; 248
 92c:	86 60       	ori	r24, 0x06	; 6
 92e:	87 b9       	out	0x07, r24	; 7
		break;
 930:	03 c0       	rjmp	.+6      	; 0x938 <ADC_Read+0x64>
		case ADC_7:
		ADMUX = (ADMUX & 0xF8) | 0x07; // Clear the channel bits and set ADC7
 932:	87 b1       	in	r24, 0x07	; 7
 934:	87 60       	ori	r24, 0x07	; 7
 936:	87 b9       	out	0x07, r24	; 7
		break;
	}

	// Start ADC conversion
	ADCSRA |= (1 << ADSC);
 938:	86 b1       	in	r24, 0x06	; 6
 93a:	80 64       	ori	r24, 0x40	; 64
 93c:	86 b9       	out	0x06, r24	; 6

	// Wait for conversion to complete
	while (ADCSRA & (1 << ADSC));
 93e:	36 99       	sbic	0x06, 6	; 6
 940:	fe cf       	rjmp	.-4      	; 0x93e <ADC_Read+0x6a>

	// Read the converted value
	val = ADC_VAL;
 942:	84 b1       	in	r24, 0x04	; 4
 944:	95 b1       	in	r25, 0x05	; 5

	return val;
}
 946:	08 95       	ret

Disassembly of section .text.DIO_SetPinDirection:

00000492 <DIO_SetPinDirection>:
#include "DIO_Private.h"

/*------------------------PINS---------------------------*/
void DIO_SetPinDirection(port Port, pin Pin, state State)
{
	switch(State)
 492:	44 23       	and	r20, r20
 494:	19 f0       	breq	.+6      	; 0x49c <DIO_SetPinDirection+0xa>
 496:	41 30       	cpi	r20, 0x01	; 1
 498:	c9 f1       	breq	.+114    	; 0x50c <DIO_SetPinDirection+0x7a>
 49a:	08 95       	ret
	{
		case DIO_INPUT:
		switch (Port)
 49c:	81 30       	cpi	r24, 0x01	; 1
 49e:	91 f0       	breq	.+36     	; 0x4c4 <DIO_SetPinDirection+0x32>
 4a0:	28 f0       	brcs	.+10     	; 0x4ac <DIO_SetPinDirection+0x1a>
 4a2:	82 30       	cpi	r24, 0x02	; 2
 4a4:	d9 f0       	breq	.+54     	; 0x4dc <DIO_SetPinDirection+0x4a>
 4a6:	83 30       	cpi	r24, 0x03	; 3
 4a8:	29 f1       	breq	.+74     	; 0x4f4 <DIO_SetPinDirection+0x62>
 4aa:	08 95       	ret
		{
			case DIO_PORTA:
			CLR_BIT(DDRA, Pin);
 4ac:	2a b3       	in	r18, 0x1a	; 26
 4ae:	81 e0       	ldi	r24, 0x01	; 1
 4b0:	90 e0       	ldi	r25, 0x00	; 0
 4b2:	02 c0       	rjmp	.+4      	; 0x4b8 <DIO_SetPinDirection+0x26>
 4b4:	88 0f       	add	r24, r24
 4b6:	99 1f       	adc	r25, r25
 4b8:	6a 95       	dec	r22
 4ba:	e2 f7       	brpl	.-8      	; 0x4b4 <DIO_SetPinDirection+0x22>
 4bc:	80 95       	com	r24
 4be:	82 23       	and	r24, r18
 4c0:	8a bb       	out	0x1a, r24	; 26
			break;
 4c2:	08 95       	ret
			case DIO_PORTB:
			CLR_BIT(DDRB, Pin);
 4c4:	27 b3       	in	r18, 0x17	; 23
 4c6:	81 e0       	ldi	r24, 0x01	; 1
 4c8:	90 e0       	ldi	r25, 0x00	; 0
 4ca:	02 c0       	rjmp	.+4      	; 0x4d0 <DIO_SetPinDirection+0x3e>
 4cc:	88 0f       	add	r24, r24
 4ce:	99 1f       	adc	r25, r25
 4d0:	6a 95       	dec	r22
 4d2:	e2 f7       	brpl	.-8      	; 0x4cc <DIO_SetPinDirection+0x3a>
 4d4:	80 95       	com	r24
 4d6:	82 23       	and	r24, r18
 4d8:	87 bb       	out	0x17, r24	; 23
			break;
 4da:	08 95       	ret
			case DIO_PORTC:
			CLR_BIT(DDRC, Pin);
 4dc:	24 b3       	in	r18, 0x14	; 20
 4de:	81 e0       	ldi	r24, 0x01	; 1
 4e0:	90 e0       	ldi	r25, 0x00	; 0
 4e2:	02 c0       	rjmp	.+4      	; 0x4e8 <DIO_SetPinDirection+0x56>
 4e4:	88 0f       	add	r24, r24
 4e6:	99 1f       	adc	r25, r25
 4e8:	6a 95       	dec	r22
 4ea:	e2 f7       	brpl	.-8      	; 0x4e4 <DIO_SetPinDirection+0x52>
 4ec:	80 95       	com	r24
 4ee:	82 23       	and	r24, r18
 4f0:	84 bb       	out	0x14, r24	; 20
			break;
 4f2:	08 95       	ret
			case DIO_PORTD:
			CLR_BIT(DDRD, Pin);
 4f4:	21 b3       	in	r18, 0x11	; 17
 4f6:	81 e0       	ldi	r24, 0x01	; 1
 4f8:	90 e0       	ldi	r25, 0x00	; 0
 4fa:	02 c0       	rjmp	.+4      	; 0x500 <DIO_SetPinDirection+0x6e>
 4fc:	88 0f       	add	r24, r24
 4fe:	99 1f       	adc	r25, r25
 500:	6a 95       	dec	r22
 502:	e2 f7       	brpl	.-8      	; 0x4fc <DIO_SetPinDirection+0x6a>
 504:	80 95       	com	r24
 506:	82 23       	and	r24, r18
 508:	81 bb       	out	0x11, r24	; 17
			break;
 50a:	08 95       	ret
		}
		break;
		case DIO_OUTPUT:
		switch (Port)
 50c:	81 30       	cpi	r24, 0x01	; 1
 50e:	89 f0       	breq	.+34     	; 0x532 <DIO_SetPinDirection+0xa0>
 510:	28 f0       	brcs	.+10     	; 0x51c <DIO_SetPinDirection+0x8a>
 512:	82 30       	cpi	r24, 0x02	; 2
 514:	c9 f0       	breq	.+50     	; 0x548 <DIO_SetPinDirection+0xb6>
 516:	83 30       	cpi	r24, 0x03	; 3
 518:	11 f1       	breq	.+68     	; 0x55e <DIO_SetPinDirection+0xcc>
 51a:	08 95       	ret
		{
			case DIO_PORTA:
			SET_BIT(DDRA, Pin);
 51c:	2a b3       	in	r18, 0x1a	; 26
 51e:	81 e0       	ldi	r24, 0x01	; 1
 520:	90 e0       	ldi	r25, 0x00	; 0
 522:	02 c0       	rjmp	.+4      	; 0x528 <DIO_SetPinDirection+0x96>
 524:	88 0f       	add	r24, r24
 526:	99 1f       	adc	r25, r25
 528:	6a 95       	dec	r22
 52a:	e2 f7       	brpl	.-8      	; 0x524 <DIO_SetPinDirection+0x92>
 52c:	82 2b       	or	r24, r18
 52e:	8a bb       	out	0x1a, r24	; 26
			break;
 530:	08 95       	ret
			case DIO_PORTB:
			SET_BIT(DDRB, Pin);
 532:	27 b3       	in	r18, 0x17	; 23
 534:	81 e0       	ldi	r24, 0x01	; 1
 536:	90 e0       	ldi	r25, 0x00	; 0
 538:	02 c0       	rjmp	.+4      	; 0x53e <DIO_SetPinDirection+0xac>
 53a:	88 0f       	add	r24, r24
 53c:	99 1f       	adc	r25, r25
 53e:	6a 95       	dec	r22
 540:	e2 f7       	brpl	.-8      	; 0x53a <DIO_SetPinDirection+0xa8>
 542:	82 2b       	or	r24, r18
 544:	87 bb       	out	0x17, r24	; 23
			break;
 546:	08 95       	ret
			case DIO_PORTC:
			SET_BIT(DDRC, Pin);
 548:	24 b3       	in	r18, 0x14	; 20
 54a:	81 e0       	ldi	r24, 0x01	; 1
 54c:	90 e0       	ldi	r25, 0x00	; 0
 54e:	02 c0       	rjmp	.+4      	; 0x554 <DIO_SetPinDirection+0xc2>
 550:	88 0f       	add	r24, r24
 552:	99 1f       	adc	r25, r25
 554:	6a 95       	dec	r22
 556:	e2 f7       	brpl	.-8      	; 0x550 <DIO_SetPinDirection+0xbe>
 558:	82 2b       	or	r24, r18
 55a:	84 bb       	out	0x14, r24	; 20
			break;
 55c:	08 95       	ret
			case DIO_PORTD:
			SET_BIT(DDRD, Pin);
 55e:	21 b3       	in	r18, 0x11	; 17
 560:	81 e0       	ldi	r24, 0x01	; 1
 562:	90 e0       	ldi	r25, 0x00	; 0
 564:	02 c0       	rjmp	.+4      	; 0x56a <DIO_SetPinDirection+0xd8>
 566:	88 0f       	add	r24, r24
 568:	99 1f       	adc	r25, r25
 56a:	6a 95       	dec	r22
 56c:	e2 f7       	brpl	.-8      	; 0x566 <DIO_SetPinDirection+0xd4>
 56e:	82 2b       	or	r24, r18
 570:	81 bb       	out	0x11, r24	; 17
 572:	08 95       	ret

Disassembly of section .text.DIO_SetPinValue:

00000574 <DIO_SetPinValue>:
		break;
	}
}
void DIO_SetPinValue(port Port, pin Pin, status Status)
{
	switch(Status)
 574:	44 23       	and	r20, r20
 576:	19 f0       	breq	.+6      	; 0x57e <DIO_SetPinValue+0xa>
 578:	41 30       	cpi	r20, 0x01	; 1
 57a:	c9 f1       	breq	.+114    	; 0x5ee <DIO_SetPinValue+0x7a>
 57c:	08 95       	ret
	{
		case DIO_LOW:
		switch (Port)
 57e:	81 30       	cpi	r24, 0x01	; 1
 580:	91 f0       	breq	.+36     	; 0x5a6 <DIO_SetPinValue+0x32>
 582:	28 f0       	brcs	.+10     	; 0x58e <DIO_SetPinValue+0x1a>
 584:	82 30       	cpi	r24, 0x02	; 2
 586:	d9 f0       	breq	.+54     	; 0x5be <DIO_SetPinValue+0x4a>
 588:	83 30       	cpi	r24, 0x03	; 3
 58a:	29 f1       	breq	.+74     	; 0x5d6 <DIO_SetPinValue+0x62>
 58c:	08 95       	ret
		{
			case DIO_PORTA:
			CLR_BIT(PORTA, Pin);
 58e:	2b b3       	in	r18, 0x1b	; 27
 590:	81 e0       	ldi	r24, 0x01	; 1
 592:	90 e0       	ldi	r25, 0x00	; 0
 594:	02 c0       	rjmp	.+4      	; 0x59a <DIO_SetPinValue+0x26>
 596:	88 0f       	add	r24, r24
 598:	99 1f       	adc	r25, r25
 59a:	6a 95       	dec	r22
 59c:	e2 f7       	brpl	.-8      	; 0x596 <DIO_SetPinValue+0x22>
 59e:	80 95       	com	r24
 5a0:	82 23       	and	r24, r18
 5a2:	8b bb       	out	0x1b, r24	; 27
			break;
 5a4:	08 95       	ret
			case DIO_PORTB:
			CLR_BIT(PORTB, Pin);
 5a6:	28 b3       	in	r18, 0x18	; 24
 5a8:	81 e0       	ldi	r24, 0x01	; 1
 5aa:	90 e0       	ldi	r25, 0x00	; 0
 5ac:	02 c0       	rjmp	.+4      	; 0x5b2 <DIO_SetPinValue+0x3e>
 5ae:	88 0f       	add	r24, r24
 5b0:	99 1f       	adc	r25, r25
 5b2:	6a 95       	dec	r22
 5b4:	e2 f7       	brpl	.-8      	; 0x5ae <DIO_SetPinValue+0x3a>
 5b6:	80 95       	com	r24
 5b8:	82 23       	and	r24, r18
 5ba:	88 bb       	out	0x18, r24	; 24
			break;
 5bc:	08 95       	ret
			case DIO_PORTC:
			CLR_BIT(PORTC, Pin);
 5be:	25 b3       	in	r18, 0x15	; 21
 5c0:	81 e0       	ldi	r24, 0x01	; 1
 5c2:	90 e0       	ldi	r25, 0x00	; 0
 5c4:	02 c0       	rjmp	.+4      	; 0x5ca <DIO_SetPinValue+0x56>
 5c6:	88 0f       	add	r24, r24
 5c8:	99 1f       	adc	r25, r25
 5ca:	6a 95       	dec	r22
 5cc:	e2 f7       	brpl	.-8      	; 0x5c6 <DIO_SetPinValue+0x52>
 5ce:	80 95       	com	r24
 5d0:	82 23       	and	r24, r18
 5d2:	85 bb       	out	0x15, r24	; 21
			break;
 5d4:	08 95       	ret
			case DIO_PORTD:
			CLR_BIT(PORTD, Pin);
 5d6:	22 b3       	in	r18, 0x12	; 18
 5d8:	81 e0       	ldi	r24, 0x01	; 1
 5da:	90 e0       	ldi	r25, 0x00	; 0
 5dc:	02 c0       	rjmp	.+4      	; 0x5e2 <DIO_SetPinValue+0x6e>
 5de:	88 0f       	add	r24, r24
 5e0:	99 1f       	adc	r25, r25
 5e2:	6a 95       	dec	r22
 5e4:	e2 f7       	brpl	.-8      	; 0x5de <DIO_SetPinValue+0x6a>
 5e6:	80 95       	com	r24
 5e8:	82 23       	and	r24, r18
 5ea:	82 bb       	out	0x12, r24	; 18
			break;
 5ec:	08 95       	ret
		}
		break;
		case DIO_HIGH:
		switch (Port)
 5ee:	81 30       	cpi	r24, 0x01	; 1
 5f0:	89 f0       	breq	.+34     	; 0x614 <DIO_SetPinValue+0xa0>
 5f2:	28 f0       	brcs	.+10     	; 0x5fe <DIO_SetPinValue+0x8a>
 5f4:	82 30       	cpi	r24, 0x02	; 2
 5f6:	c9 f0       	breq	.+50     	; 0x62a <DIO_SetPinValue+0xb6>
 5f8:	83 30       	cpi	r24, 0x03	; 3
 5fa:	11 f1       	breq	.+68     	; 0x640 <DIO_SetPinValue+0xcc>
 5fc:	08 95       	ret
		{
			case DIO_PORTA:
			SET_BIT(PORTA, Pin);
 5fe:	2b b3       	in	r18, 0x1b	; 27
 600:	81 e0       	ldi	r24, 0x01	; 1
 602:	90 e0       	ldi	r25, 0x00	; 0
 604:	02 c0       	rjmp	.+4      	; 0x60a <DIO_SetPinValue+0x96>
 606:	88 0f       	add	r24, r24
 608:	99 1f       	adc	r25, r25
 60a:	6a 95       	dec	r22
 60c:	e2 f7       	brpl	.-8      	; 0x606 <DIO_SetPinValue+0x92>
 60e:	82 2b       	or	r24, r18
 610:	8b bb       	out	0x1b, r24	; 27
			break;
 612:	08 95       	ret
			case DIO_PORTB:
			SET_BIT(PORTB, Pin);
 614:	28 b3       	in	r18, 0x18	; 24
 616:	81 e0       	ldi	r24, 0x01	; 1
 618:	90 e0       	ldi	r25, 0x00	; 0
 61a:	02 c0       	rjmp	.+4      	; 0x620 <DIO_SetPinValue+0xac>
 61c:	88 0f       	add	r24, r24
 61e:	99 1f       	adc	r25, r25
 620:	6a 95       	dec	r22
 622:	e2 f7       	brpl	.-8      	; 0x61c <DIO_SetPinValue+0xa8>
 624:	82 2b       	or	r24, r18
 626:	88 bb       	out	0x18, r24	; 24
			break;
 628:	08 95       	ret
			case DIO_PORTC:
			SET_BIT(PORTC, Pin);
 62a:	25 b3       	in	r18, 0x15	; 21
 62c:	81 e0       	ldi	r24, 0x01	; 1
 62e:	90 e0       	ldi	r25, 0x00	; 0
 630:	02 c0       	rjmp	.+4      	; 0x636 <DIO_SetPinValue+0xc2>
 632:	88 0f       	add	r24, r24
 634:	99 1f       	adc	r25, r25
 636:	6a 95       	dec	r22
 638:	e2 f7       	brpl	.-8      	; 0x632 <DIO_SetPinValue+0xbe>
 63a:	82 2b       	or	r24, r18
 63c:	85 bb       	out	0x15, r24	; 21
			break;
 63e:	08 95       	ret
			case DIO_PORTD:
			SET_BIT(PORTD, Pin);
 640:	22 b3       	in	r18, 0x12	; 18
 642:	81 e0       	ldi	r24, 0x01	; 1
 644:	90 e0       	ldi	r25, 0x00	; 0
 646:	02 c0       	rjmp	.+4      	; 0x64c <DIO_SetPinValue+0xd8>
 648:	88 0f       	add	r24, r24
 64a:	99 1f       	adc	r25, r25
 64c:	6a 95       	dec	r22
 64e:	e2 f7       	brpl	.-8      	; 0x648 <DIO_SetPinValue+0xd4>
 650:	82 2b       	or	r24, r18
 652:	82 bb       	out	0x12, r24	; 18
 654:	08 95       	ret

Disassembly of section .text.UART_Initialize_WithoutInterrupt:

00000372 <UART_Initialize_WithoutInterrupt>:
	uint8_t low_byte = data & 0xFF;
	uart_status s=UART_Transmit_Character(high_byte);
	s|= UART_Transmit_Character(low_byte);
	return s;

}
 372:	0f 93       	push	r16
 374:	31 b3       	in	r19, 0x11	; 17
 376:	32 60       	ori	r19, 0x02	; 2
 378:	31 bb       	out	0x11, r19	; 17
 37a:	31 b3       	in	r19, 0x11	; 17
 37c:	3e 7f       	andi	r19, 0xFE	; 254
 37e:	31 bb       	out	0x11, r19	; 17
 380:	3a b1       	in	r19, 0x0a	; 10
 382:	38 61       	ori	r19, 0x18	; 24
 384:	3a b9       	out	0x0a, r19	; 10
 386:	66 23       	and	r22, r22
 388:	19 f0       	breq	.+6      	; 0x390 <UART_Initialize_WithoutInterrupt+0x1e>
 38a:	61 30       	cpi	r22, 0x01	; 1
 38c:	29 f0       	breq	.+10     	; 0x398 <UART_Initialize_WithoutInterrupt+0x26>
 38e:	07 c0       	rjmp	.+14     	; 0x39e <UART_Initialize_WithoutInterrupt+0x2c>
 390:	30 b5       	in	r19, 0x20	; 32
 392:	3f 77       	andi	r19, 0x7F	; 127
 394:	30 bd       	out	0x20, r19	; 32
 396:	03 c0       	rjmp	.+6      	; 0x39e <UART_Initialize_WithoutInterrupt+0x2c>
 398:	30 b5       	in	r19, 0x20	; 32
 39a:	30 68       	ori	r19, 0x80	; 128
 39c:	30 bd       	out	0x20, r19	; 32
 39e:	22 30       	cpi	r18, 0x02	; 2
 3a0:	f9 f0       	breq	.+62     	; 0x3e0 <UART_Initialize_WithoutInterrupt+0x6e>
 3a2:	28 f4       	brcc	.+10     	; 0x3ae <UART_Initialize_WithoutInterrupt+0x3c>
 3a4:	22 23       	and	r18, r18
 3a6:	41 f0       	breq	.+16     	; 0x3b8 <UART_Initialize_WithoutInterrupt+0x46>
 3a8:	21 30       	cpi	r18, 0x01	; 1
 3aa:	81 f0       	breq	.+32     	; 0x3cc <UART_Initialize_WithoutInterrupt+0x5a>
 3ac:	36 c0       	rjmp	.+108    	; 0x41a <__EEPROM_REGION_LENGTH__+0x1a>
 3ae:	23 30       	cpi	r18, 0x03	; 3
 3b0:	09 f1       	breq	.+66     	; 0x3f4 <UART_Initialize_WithoutInterrupt+0x82>
 3b2:	24 30       	cpi	r18, 0x04	; 4
 3b4:	49 f1       	breq	.+82     	; 0x408 <__EEPROM_REGION_LENGTH__+0x8>
 3b6:	31 c0       	rjmp	.+98     	; 0x41a <__EEPROM_REGION_LENGTH__+0x1a>
 3b8:	2a b1       	in	r18, 0x0a	; 10
 3ba:	2b 7f       	andi	r18, 0xFB	; 251
 3bc:	2a b9       	out	0x0a, r18	; 10
 3be:	20 b5       	in	r18, 0x20	; 32
 3c0:	2b 7f       	andi	r18, 0xFB	; 251
 3c2:	20 bd       	out	0x20, r18	; 32
 3c4:	20 b5       	in	r18, 0x20	; 32
 3c6:	2d 7f       	andi	r18, 0xFD	; 253
 3c8:	20 bd       	out	0x20, r18	; 32
 3ca:	27 c0       	rjmp	.+78     	; 0x41a <__EEPROM_REGION_LENGTH__+0x1a>
 3cc:	2a b1       	in	r18, 0x0a	; 10
 3ce:	2b 7f       	andi	r18, 0xFB	; 251
 3d0:	2a b9       	out	0x0a, r18	; 10
 3d2:	20 b5       	in	r18, 0x20	; 32
 3d4:	2b 7f       	andi	r18, 0xFB	; 251
 3d6:	20 bd       	out	0x20, r18	; 32
 3d8:	20 b5       	in	r18, 0x20	; 32
 3da:	22 60       	ori	r18, 0x02	; 2
 3dc:	20 bd       	out	0x20, r18	; 32
 3de:	1d c0       	rjmp	.+58     	; 0x41a <__EEPROM_REGION_LENGTH__+0x1a>
 3e0:	2a b1       	in	r18, 0x0a	; 10
 3e2:	2b 7f       	andi	r18, 0xFB	; 251
 3e4:	2a b9       	out	0x0a, r18	; 10
 3e6:	20 b5       	in	r18, 0x20	; 32
 3e8:	24 60       	ori	r18, 0x04	; 4
 3ea:	20 bd       	out	0x20, r18	; 32
 3ec:	20 b5       	in	r18, 0x20	; 32
 3ee:	2d 7f       	andi	r18, 0xFD	; 253
 3f0:	20 bd       	out	0x20, r18	; 32
 3f2:	13 c0       	rjmp	.+38     	; 0x41a <__EEPROM_REGION_LENGTH__+0x1a>
 3f4:	2a b1       	in	r18, 0x0a	; 10
 3f6:	2b 7f       	andi	r18, 0xFB	; 251
 3f8:	2a b9       	out	0x0a, r18	; 10
 3fa:	20 b5       	in	r18, 0x20	; 32
 3fc:	24 60       	ori	r18, 0x04	; 4
 3fe:	20 bd       	out	0x20, r18	; 32
 400:	20 b5       	in	r18, 0x20	; 32
 402:	22 60       	ori	r18, 0x02	; 2
 404:	20 bd       	out	0x20, r18	; 32
 406:	09 c0       	rjmp	.+18     	; 0x41a <__EEPROM_REGION_LENGTH__+0x1a>
 408:	2a b1       	in	r18, 0x0a	; 10
 40a:	24 60       	ori	r18, 0x04	; 4
 40c:	2a b9       	out	0x0a, r18	; 10
 40e:	20 b5       	in	r18, 0x20	; 32
 410:	24 60       	ori	r18, 0x04	; 4
 412:	20 bd       	out	0x20, r18	; 32
 414:	20 b5       	in	r18, 0x20	; 32
 416:	22 60       	ori	r18, 0x02	; 2
 418:	20 bd       	out	0x20, r18	; 32
 41a:	41 30       	cpi	r20, 0x01	; 1
 41c:	59 f0       	breq	.+22     	; 0x434 <__EEPROM_REGION_LENGTH__+0x34>
 41e:	18 f0       	brcs	.+6      	; 0x426 <__EEPROM_REGION_LENGTH__+0x26>
 420:	42 30       	cpi	r20, 0x02	; 2
 422:	79 f0       	breq	.+30     	; 0x442 <__EEPROM_REGION_LENGTH__+0x42>
 424:	14 c0       	rjmp	.+40     	; 0x44e <__EEPROM_REGION_LENGTH__+0x4e>
 426:	20 b5       	in	r18, 0x20	; 32
 428:	2f 7d       	andi	r18, 0xDF	; 223
 42a:	20 bd       	out	0x20, r18	; 32
 42c:	20 b5       	in	r18, 0x20	; 32
 42e:	2f 7e       	andi	r18, 0xEF	; 239
 430:	20 bd       	out	0x20, r18	; 32
 432:	0d c0       	rjmp	.+26     	; 0x44e <__EEPROM_REGION_LENGTH__+0x4e>
 434:	20 b5       	in	r18, 0x20	; 32
 436:	20 62       	ori	r18, 0x20	; 32
 438:	20 bd       	out	0x20, r18	; 32
 43a:	20 b5       	in	r18, 0x20	; 32
 43c:	2f 7e       	andi	r18, 0xEF	; 239
 43e:	20 bd       	out	0x20, r18	; 32
 440:	06 c0       	rjmp	.+12     	; 0x44e <__EEPROM_REGION_LENGTH__+0x4e>
 442:	20 b5       	in	r18, 0x20	; 32
 444:	20 62       	ori	r18, 0x20	; 32
 446:	20 bd       	out	0x20, r18	; 32
 448:	20 b5       	in	r18, 0x20	; 32
 44a:	20 61       	ori	r18, 0x10	; 16
 44c:	20 bd       	out	0x20, r18	; 32
 44e:	00 23       	and	r16, r16
 450:	19 f0       	breq	.+6      	; 0x458 <__EEPROM_REGION_LENGTH__+0x58>
 452:	01 30       	cpi	r16, 0x01	; 1
 454:	29 f0       	breq	.+10     	; 0x460 <__EEPROM_REGION_LENGTH__+0x60>
 456:	07 c0       	rjmp	.+14     	; 0x466 <__EEPROM_REGION_LENGTH__+0x66>
 458:	20 b5       	in	r18, 0x20	; 32
 45a:	27 7f       	andi	r18, 0xF7	; 247
 45c:	20 bd       	out	0x20, r18	; 32
 45e:	03 c0       	rjmp	.+6      	; 0x466 <__EEPROM_REGION_LENGTH__+0x66>
 460:	20 b5       	in	r18, 0x20	; 32
 462:	28 60       	ori	r18, 0x08	; 8
 464:	20 bd       	out	0x20, r18	; 32
 466:	9c 01       	movw	r18, r24
 468:	22 95       	swap	r18
 46a:	32 95       	swap	r19
 46c:	30 7f       	andi	r19, 0xF0	; 240
 46e:	32 27       	eor	r19, r18
 470:	20 7f       	andi	r18, 0xF0	; 240
 472:	32 27       	eor	r19, r18
 474:	40 e0       	ldi	r20, 0x00	; 0
 476:	50 e0       	ldi	r21, 0x00	; 0
 478:	60 e0       	ldi	r22, 0x00	; 0
 47a:	71 e7       	ldi	r23, 0x71	; 113
 47c:	82 e0       	ldi	r24, 0x02	; 2
 47e:	90 e0       	ldi	r25, 0x00	; 0
 480:	0e 94 1f 06 	call	0xc3e	; 0xc3e <__divmodsi4>
 484:	21 50       	subi	r18, 0x01	; 1
 486:	31 09       	sbc	r19, r1
 488:	29 b9       	out	0x09, r18	; 9
 48a:	30 bd       	out	0x20, r19	; 32
 48c:	81 e0       	ldi	r24, 0x01	; 1
 48e:	0f 91       	pop	r16
 490:	08 95       	ret

Disassembly of section .text.UART_Receive_Character:

00000cd4 <UART_Receive_Character>:
 cd4:	5f 9b       	sbis	0x0b, 7	; 11
 cd6:	fe cf       	rjmp	.-4      	; 0xcd4 <UART_Receive_Character>
 cd8:	2c b1       	in	r18, 0x0c	; 12
 cda:	fc 01       	movw	r30, r24
 cdc:	20 83       	st	Z, r18
 cde:	81 e0       	ldi	r24, 0x01	; 1
 ce0:	08 95       	ret

Disassembly of section .text.Reassemble_uint16:

00000d7e <Reassemble_uint16>:
	*data=Reassemble_uint16(high_byte,low_byte);
	return s;
}

uint16_t Reassemble_uint16(uint8_t high_byte, uint8_t low_byte){
	return ((uint16_t)high_byte << 8) | low_byte;
 d7e:	90 e0       	ldi	r25, 0x00	; 0
 d80:	98 2f       	mov	r25, r24
 d82:	88 27       	eor	r24, r24
}
 d84:	86 2b       	or	r24, r22
 d86:	08 95       	ret

Disassembly of section .text.UART_Receive_Word:

00000a80 <UART_Receive_Word>:
	uint8_t low_byte = data & 0xFF;
	uart_status s=UART_Transmit_Character(high_byte);
	s|= UART_Transmit_Character(low_byte);
	return s;

}
 a80:	ef 92       	push	r14
 a82:	ff 92       	push	r15
 a84:	1f 93       	push	r17
 a86:	cf 93       	push	r28
 a88:	df 93       	push	r29
 a8a:	00 d0       	rcall	.+0      	; 0xa8c <UART_Receive_Word+0xc>
 a8c:	cd b7       	in	r28, 0x3d	; 61
 a8e:	de b7       	in	r29, 0x3e	; 62
 a90:	7c 01       	movw	r14, r24
 a92:	19 82       	std	Y+1, r1	; 0x01
 a94:	1a 82       	std	Y+2, r1	; 0x02
 a96:	ce 01       	movw	r24, r28
 a98:	01 96       	adiw	r24, 0x01	; 1
 a9a:	0e 94 6a 06 	call	0xcd4	; 0xcd4 <UART_Receive_Character>
 a9e:	18 2f       	mov	r17, r24
 aa0:	ce 01       	movw	r24, r28
 aa2:	02 96       	adiw	r24, 0x02	; 2
 aa4:	0e 94 6a 06 	call	0xcd4	; 0xcd4 <UART_Receive_Character>
 aa8:	18 2b       	or	r17, r24
 aaa:	6a 81       	ldd	r22, Y+2	; 0x02
 aac:	89 81       	ldd	r24, Y+1	; 0x01
 aae:	0e 94 bf 06 	call	0xd7e	; 0xd7e <Reassemble_uint16>
 ab2:	f7 01       	movw	r30, r14
 ab4:	91 83       	std	Z+1, r25	; 0x01
 ab6:	80 83       	st	Z, r24
 ab8:	81 2f       	mov	r24, r17
 aba:	0f 90       	pop	r0
 abc:	0f 90       	pop	r0
 abe:	df 91       	pop	r29
 ac0:	cf 91       	pop	r28
 ac2:	1f 91       	pop	r17
 ac4:	ff 90       	pop	r15
 ac6:	ef 90       	pop	r14
 ac8:	08 95       	ret

Disassembly of section .text.vListInsertEnd:

00000b56 <vListInsertEnd>:
	pxItem->pvContainer = NULL;
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 b56:	cf 93       	push	r28
 b58:	df 93       	push	r29
 b5a:	9c 01       	movw	r18, r24
 b5c:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
 b5e:	dc 01       	movw	r26, r24
 b60:	11 96       	adiw	r26, 0x01	; 1
 b62:	cd 91       	ld	r28, X+
 b64:	dc 91       	ld	r29, X
 b66:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 b68:	d3 83       	std	Z+3, r29	; 0x03
 b6a:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 b6c:	8c 81       	ldd	r24, Y+4	; 0x04
 b6e:	9d 81       	ldd	r25, Y+5	; 0x05
 b70:	95 83       	std	Z+5, r25	; 0x05
 b72:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
 b74:	8c 81       	ldd	r24, Y+4	; 0x04
 b76:	9d 81       	ldd	r25, Y+5	; 0x05
 b78:	dc 01       	movw	r26, r24
 b7a:	13 96       	adiw	r26, 0x03	; 3
 b7c:	7c 93       	st	X, r23
 b7e:	6e 93       	st	-X, r22
 b80:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
 b82:	7d 83       	std	Y+5, r23	; 0x05
 b84:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 b86:	31 87       	std	Z+9, r19	; 0x09
 b88:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
 b8a:	f9 01       	movw	r30, r18
 b8c:	80 81       	ld	r24, Z
 b8e:	8f 5f       	subi	r24, 0xFF	; 255
 b90:	80 83       	st	Z, r24
}
 b92:	df 91       	pop	r29
 b94:	cf 91       	pop	r28
 b96:	08 95       	ret

Disassembly of section .text.uxListRemove:

00000a34 <uxListRemove>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 a34:	cf 93       	push	r28
 a36:	df 93       	push	r29
 a38:	fc 01       	movw	r30, r24
 a3a:	a0 85       	ldd	r26, Z+8	; 0x08
 a3c:	b1 85       	ldd	r27, Z+9	; 0x09
 a3e:	c2 81       	ldd	r28, Z+2	; 0x02
 a40:	d3 81       	ldd	r29, Z+3	; 0x03
 a42:	84 81       	ldd	r24, Z+4	; 0x04
 a44:	95 81       	ldd	r25, Z+5	; 0x05
 a46:	9d 83       	std	Y+5, r25	; 0x05
 a48:	8c 83       	std	Y+4, r24	; 0x04
 a4a:	c4 81       	ldd	r28, Z+4	; 0x04
 a4c:	d5 81       	ldd	r29, Z+5	; 0x05
 a4e:	82 81       	ldd	r24, Z+2	; 0x02
 a50:	93 81       	ldd	r25, Z+3	; 0x03
 a52:	9b 83       	std	Y+3, r25	; 0x03
 a54:	8a 83       	std	Y+2, r24	; 0x02
 a56:	11 96       	adiw	r26, 0x01	; 1
 a58:	8d 91       	ld	r24, X+
 a5a:	9c 91       	ld	r25, X
 a5c:	12 97       	sbiw	r26, 0x02	; 2
 a5e:	e8 17       	cp	r30, r24
 a60:	f9 07       	cpc	r31, r25
 a62:	31 f4       	brne	.+12     	; 0xa70 <uxListRemove+0x3c>
 a64:	84 81       	ldd	r24, Z+4	; 0x04
 a66:	95 81       	ldd	r25, Z+5	; 0x05
 a68:	12 96       	adiw	r26, 0x02	; 2
 a6a:	9c 93       	st	X, r25
 a6c:	8e 93       	st	-X, r24
 a6e:	11 97       	sbiw	r26, 0x01	; 1
 a70:	11 86       	std	Z+9, r1	; 0x09
 a72:	10 86       	std	Z+8, r1	; 0x08
 a74:	8c 91       	ld	r24, X
 a76:	81 50       	subi	r24, 0x01	; 1
 a78:	8c 93       	st	X, r24
 a7a:	df 91       	pop	r29
 a7c:	cf 91       	pop	r28
 a7e:	08 95       	ret

Disassembly of section .text.vPortYieldFromTick:

00000656 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
 656:	0f 92       	push	r0
 658:	0f b6       	in	r0, 0x3f	; 63
 65a:	f8 94       	cli
 65c:	0f 92       	push	r0
 65e:	1f 92       	push	r1
 660:	11 24       	eor	r1, r1
 662:	2f 92       	push	r2
 664:	3f 92       	push	r3
 666:	4f 92       	push	r4
 668:	5f 92       	push	r5
 66a:	6f 92       	push	r6
 66c:	7f 92       	push	r7
 66e:	8f 92       	push	r8
 670:	9f 92       	push	r9
 672:	af 92       	push	r10
 674:	bf 92       	push	r11
 676:	cf 92       	push	r12
 678:	df 92       	push	r13
 67a:	ef 92       	push	r14
 67c:	ff 92       	push	r15
 67e:	0f 93       	push	r16
 680:	1f 93       	push	r17
 682:	2f 93       	push	r18
 684:	3f 93       	push	r19
 686:	4f 93       	push	r20
 688:	5f 93       	push	r21
 68a:	6f 93       	push	r22
 68c:	7f 93       	push	r23
 68e:	8f 93       	push	r24
 690:	9f 93       	push	r25
 692:	af 93       	push	r26
 694:	bf 93       	push	r27
 696:	cf 93       	push	r28
 698:	df 93       	push	r29
 69a:	ef 93       	push	r30
 69c:	ff 93       	push	r31
 69e:	a0 91 90 00 	lds	r26, 0x0090	; 0x800090 <pxCurrentTCB>
 6a2:	b0 91 91 00 	lds	r27, 0x0091	; 0x800091 <pxCurrentTCB+0x1>
 6a6:	0d b6       	in	r0, 0x3d	; 61
 6a8:	0d 92       	st	X+, r0
 6aa:	0e b6       	in	r0, 0x3e	; 62
 6ac:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
 6ae:	0e 94 65 00 	call	0xca	; 0xca <__data_load_end>
 6b2:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
 6b4:	0e 94 87 03 	call	0x70e	; 0x70e <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
 6b8:	a0 91 90 00 	lds	r26, 0x0090	; 0x800090 <pxCurrentTCB>
 6bc:	b0 91 91 00 	lds	r27, 0x0091	; 0x800091 <pxCurrentTCB+0x1>
 6c0:	cd 91       	ld	r28, X+
 6c2:	cd bf       	out	0x3d, r28	; 61
 6c4:	dd 91       	ld	r29, X+
 6c6:	de bf       	out	0x3e, r29	; 62
 6c8:	ff 91       	pop	r31
 6ca:	ef 91       	pop	r30
 6cc:	df 91       	pop	r29
 6ce:	cf 91       	pop	r28
 6d0:	bf 91       	pop	r27
 6d2:	af 91       	pop	r26
 6d4:	9f 91       	pop	r25
 6d6:	8f 91       	pop	r24
 6d8:	7f 91       	pop	r23
 6da:	6f 91       	pop	r22
 6dc:	5f 91       	pop	r21
 6de:	4f 91       	pop	r20
 6e0:	3f 91       	pop	r19
 6e2:	2f 91       	pop	r18
 6e4:	1f 91       	pop	r17
 6e6:	0f 91       	pop	r16
 6e8:	ff 90       	pop	r15
 6ea:	ef 90       	pop	r14
 6ec:	df 90       	pop	r13
 6ee:	cf 90       	pop	r12
 6f0:	bf 90       	pop	r11
 6f2:	af 90       	pop	r10
 6f4:	9f 90       	pop	r9
 6f6:	8f 90       	pop	r8
 6f8:	7f 90       	pop	r7
 6fa:	6f 90       	pop	r6
 6fc:	5f 90       	pop	r5
 6fe:	4f 90       	pop	r4
 700:	3f 90       	pop	r3
 702:	2f 90       	pop	r2
 704:	1f 90       	pop	r1
 706:	0f 90       	pop	r0
 708:	0f be       	out	0x3f, r0	; 63
 70a:	0f 90       	pop	r0

	asm volatile ( "ret" );
 70c:	08 95       	ret

Disassembly of section .text.__vector_7:

00000d9c <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
 d9c:	0e 94 2b 03 	call	0x656	; 0x656 <vPortYieldFromTick>
		asm volatile ( "reti" );
 da0:	18 95       	reti

Disassembly of section .text.prvResetNextTaskUnblockTime:

00000b98 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 b98:	e0 91 8e 00 	lds	r30, 0x008E	; 0x80008e <pxDelayedTaskList>
 b9c:	f0 91 8f 00 	lds	r31, 0x008F	; 0x80008f <pxDelayedTaskList+0x1>
 ba0:	80 81       	ld	r24, Z
 ba2:	81 11       	cpse	r24, r1
 ba4:	07 c0       	rjmp	.+14     	; 0xbb4 <prvResetNextTaskUnblockTime+0x1c>
		/* The new current delayed list is empty.  Set
		xNextTaskUnblockTime to the maximum possible value so it is
		extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 ba6:	8f ef       	ldi	r24, 0xFF	; 255
 ba8:	9f ef       	ldi	r25, 0xFF	; 255
 baa:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <xNextTaskUnblockTime+0x1>
 bae:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <xNextTaskUnblockTime>
 bb2:	08 95       	ret
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 bb4:	e0 91 8e 00 	lds	r30, 0x008E	; 0x80008e <pxDelayedTaskList>
 bb8:	f0 91 8f 00 	lds	r31, 0x008F	; 0x80008f <pxDelayedTaskList+0x1>
 bbc:	05 80       	ldd	r0, Z+5	; 0x05
 bbe:	f6 81       	ldd	r31, Z+6	; 0x06
 bc0:	e0 2d       	mov	r30, r0
 bc2:	06 80       	ldd	r0, Z+6	; 0x06
 bc4:	f7 81       	ldd	r31, Z+7	; 0x07
 bc6:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
 bc8:	82 81       	ldd	r24, Z+2	; 0x02
 bca:	93 81       	ldd	r25, Z+3	; 0x03
 bcc:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <xNextTaskUnblockTime+0x1>
 bd0:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <xNextTaskUnblockTime>
 bd4:	08 95       	ret

Disassembly of section .text.xTaskIncrementTick:

000000ca <xTaskIncrementTick>:
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
			{
				taskYIELD();
  ca:	df 92       	push	r13
  cc:	ef 92       	push	r14
  ce:	ff 92       	push	r15
  d0:	0f 93       	push	r16
  d2:	1f 93       	push	r17
  d4:	cf 93       	push	r28
  d6:	df 93       	push	r29
  d8:	80 91 94 00 	lds	r24, 0x0094	; 0x800094 <uxSchedulerSuspended>
  dc:	81 11       	cpse	r24, r1
  de:	99 c0       	rjmp	.+306    	; 0x212 <xTaskIncrementTick+0x148>
  e0:	80 91 8a 00 	lds	r24, 0x008A	; 0x80008a <xTickCount>
  e4:	90 91 8b 00 	lds	r25, 0x008B	; 0x80008b <xTickCount+0x1>
  e8:	01 96       	adiw	r24, 0x01	; 1
  ea:	90 93 8b 00 	sts	0x008B, r25	; 0x80008b <xTickCount+0x1>
  ee:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <xTickCount>
  f2:	e0 90 8a 00 	lds	r14, 0x008A	; 0x80008a <xTickCount>
  f6:	f0 90 8b 00 	lds	r15, 0x008B	; 0x80008b <xTickCount+0x1>
  fa:	e1 14       	cp	r14, r1
  fc:	f1 04       	cpc	r15, r1
  fe:	b9 f4       	brne	.+46     	; 0x12e <xTaskIncrementTick+0x64>
 100:	80 91 8e 00 	lds	r24, 0x008E	; 0x80008e <pxDelayedTaskList>
 104:	90 91 8f 00 	lds	r25, 0x008F	; 0x80008f <pxDelayedTaskList+0x1>
 108:	20 91 8c 00 	lds	r18, 0x008C	; 0x80008c <pxOverflowDelayedTaskList>
 10c:	30 91 8d 00 	lds	r19, 0x008D	; 0x80008d <pxOverflowDelayedTaskList+0x1>
 110:	30 93 8f 00 	sts	0x008F, r19	; 0x80008f <pxDelayedTaskList+0x1>
 114:	20 93 8e 00 	sts	0x008E, r18	; 0x80008e <pxDelayedTaskList>
 118:	90 93 8d 00 	sts	0x008D, r25	; 0x80008d <pxOverflowDelayedTaskList+0x1>
 11c:	80 93 8c 00 	sts	0x008C, r24	; 0x80008c <pxOverflowDelayedTaskList>
 120:	80 91 95 00 	lds	r24, 0x0095	; 0x800095 <xNumOfOverflows>
 124:	8f 5f       	subi	r24, 0xFF	; 255
 126:	80 93 95 00 	sts	0x0095, r24	; 0x800095 <xNumOfOverflows>
 12a:	0e 94 cc 05 	call	0xb98	; 0xb98 <prvResetNextTaskUnblockTime>
 12e:	80 91 88 00 	lds	r24, 0x0088	; 0x800088 <xNextTaskUnblockTime>
 132:	90 91 89 00 	lds	r25, 0x0089	; 0x800089 <xNextTaskUnblockTime+0x1>
 136:	e8 16       	cp	r14, r24
 138:	f9 06       	cpc	r15, r25
 13a:	28 f4       	brcc	.+10     	; 0x146 <xTaskIncrementTick+0x7c>
 13c:	d1 2c       	mov	r13, r1
 13e:	53 c0       	rjmp	.+166    	; 0x1e6 <xTaskIncrementTick+0x11c>
 140:	dd 24       	eor	r13, r13
 142:	d3 94       	inc	r13
 144:	01 c0       	rjmp	.+2      	; 0x148 <xTaskIncrementTick+0x7e>
 146:	d1 2c       	mov	r13, r1
 148:	e0 91 8e 00 	lds	r30, 0x008E	; 0x80008e <pxDelayedTaskList>
 14c:	f0 91 8f 00 	lds	r31, 0x008F	; 0x80008f <pxDelayedTaskList+0x1>
 150:	80 81       	ld	r24, Z
 152:	81 11       	cpse	r24, r1
 154:	07 c0       	rjmp	.+14     	; 0x164 <xTaskIncrementTick+0x9a>
 156:	8f ef       	ldi	r24, 0xFF	; 255
 158:	9f ef       	ldi	r25, 0xFF	; 255
 15a:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <xNextTaskUnblockTime+0x1>
 15e:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <xNextTaskUnblockTime>
 162:	41 c0       	rjmp	.+130    	; 0x1e6 <xTaskIncrementTick+0x11c>
 164:	e0 91 8e 00 	lds	r30, 0x008E	; 0x80008e <pxDelayedTaskList>
 168:	f0 91 8f 00 	lds	r31, 0x008F	; 0x80008f <pxDelayedTaskList+0x1>
 16c:	05 80       	ldd	r0, Z+5	; 0x05
 16e:	f6 81       	ldd	r31, Z+6	; 0x06
 170:	e0 2d       	mov	r30, r0
 172:	c6 81       	ldd	r28, Z+6	; 0x06
 174:	d7 81       	ldd	r29, Z+7	; 0x07
 176:	8a 81       	ldd	r24, Y+2	; 0x02
 178:	9b 81       	ldd	r25, Y+3	; 0x03
 17a:	e8 16       	cp	r14, r24
 17c:	f9 06       	cpc	r15, r25
 17e:	28 f4       	brcc	.+10     	; 0x18a <xTaskIncrementTick+0xc0>
 180:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <xNextTaskUnblockTime+0x1>
 184:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <xNextTaskUnblockTime>
 188:	2e c0       	rjmp	.+92     	; 0x1e6 <xTaskIncrementTick+0x11c>
 18a:	8e 01       	movw	r16, r28
 18c:	0e 5f       	subi	r16, 0xFE	; 254
 18e:	1f 4f       	sbci	r17, 0xFF	; 255
 190:	c8 01       	movw	r24, r16
 192:	0e 94 1a 05 	call	0xa34	; 0xa34 <uxListRemove>
 196:	8c 89       	ldd	r24, Y+20	; 0x14
 198:	9d 89       	ldd	r25, Y+21	; 0x15
 19a:	89 2b       	or	r24, r25
 19c:	21 f0       	breq	.+8      	; 0x1a6 <xTaskIncrementTick+0xdc>
 19e:	ce 01       	movw	r24, r28
 1a0:	0c 96       	adiw	r24, 0x0c	; 12
 1a2:	0e 94 1a 05 	call	0xa34	; 0xa34 <uxListRemove>
 1a6:	8e 89       	ldd	r24, Y+22	; 0x16
 1a8:	90 91 98 00 	lds	r25, 0x0098	; 0x800098 <uxTopReadyPriority>
 1ac:	98 17       	cp	r25, r24
 1ae:	10 f4       	brcc	.+4      	; 0x1b4 <xTaskIncrementTick+0xea>
 1b0:	80 93 98 00 	sts	0x0098, r24	; 0x800098 <uxTopReadyPriority>
 1b4:	90 e0       	ldi	r25, 0x00	; 0
 1b6:	9c 01       	movw	r18, r24
 1b8:	22 0f       	add	r18, r18
 1ba:	33 1f       	adc	r19, r19
 1bc:	22 0f       	add	r18, r18
 1be:	33 1f       	adc	r19, r19
 1c0:	22 0f       	add	r18, r18
 1c2:	33 1f       	adc	r19, r19
 1c4:	82 0f       	add	r24, r18
 1c6:	93 1f       	adc	r25, r19
 1c8:	b8 01       	movw	r22, r16
 1ca:	80 5a       	subi	r24, 0xA0	; 160
 1cc:	9f 4f       	sbci	r25, 0xFF	; 255
 1ce:	0e 94 ab 05 	call	0xb56	; 0xb56 <vListInsertEnd>
 1d2:	9e 89       	ldd	r25, Y+22	; 0x16
 1d4:	e0 91 90 00 	lds	r30, 0x0090	; 0x800090 <pxCurrentTCB>
 1d8:	f0 91 91 00 	lds	r31, 0x0091	; 0x800091 <pxCurrentTCB+0x1>
 1dc:	86 89       	ldd	r24, Z+22	; 0x16
 1de:	98 17       	cp	r25, r24
 1e0:	08 f0       	brcs	.+2      	; 0x1e4 <xTaskIncrementTick+0x11a>
 1e2:	ae cf       	rjmp	.-164    	; 0x140 <xTaskIncrementTick+0x76>
 1e4:	b1 cf       	rjmp	.-158    	; 0x148 <xTaskIncrementTick+0x7e>
 1e6:	e0 91 90 00 	lds	r30, 0x0090	; 0x800090 <pxCurrentTCB>
 1ea:	f0 91 91 00 	lds	r31, 0x0091	; 0x800091 <pxCurrentTCB+0x1>
 1ee:	86 89       	ldd	r24, Z+22	; 0x16
 1f0:	90 e0       	ldi	r25, 0x00	; 0
 1f2:	fc 01       	movw	r30, r24
 1f4:	ee 0f       	add	r30, r30
 1f6:	ff 1f       	adc	r31, r31
 1f8:	ee 0f       	add	r30, r30
 1fa:	ff 1f       	adc	r31, r31
 1fc:	ee 0f       	add	r30, r30
 1fe:	ff 1f       	adc	r31, r31
 200:	8e 0f       	add	r24, r30
 202:	9f 1f       	adc	r25, r31
 204:	fc 01       	movw	r30, r24
 206:	e0 5a       	subi	r30, 0xA0	; 160
 208:	ff 4f       	sbci	r31, 0xFF	; 255
 20a:	80 81       	ld	r24, Z
 20c:	82 30       	cpi	r24, 0x02	; 2
 20e:	40 f4       	brcc	.+16     	; 0x220 <xTaskIncrementTick+0x156>
 210:	09 c0       	rjmp	.+18     	; 0x224 <xTaskIncrementTick+0x15a>
 212:	80 91 97 00 	lds	r24, 0x0097	; 0x800097 <uxPendedTicks>
 216:	8f 5f       	subi	r24, 0xFF	; 255
 218:	80 93 97 00 	sts	0x0097, r24	; 0x800097 <uxPendedTicks>
 21c:	d1 2c       	mov	r13, r1
 21e:	02 c0       	rjmp	.+4      	; 0x224 <xTaskIncrementTick+0x15a>
 220:	dd 24       	eor	r13, r13
 222:	d3 94       	inc	r13
 224:	80 91 96 00 	lds	r24, 0x0096	; 0x800096 <xYieldPending>
 228:	88 23       	and	r24, r24
 22a:	11 f0       	breq	.+4      	; 0x230 <xTaskIncrementTick+0x166>
 22c:	dd 24       	eor	r13, r13
 22e:	d3 94       	inc	r13
 230:	8d 2d       	mov	r24, r13
 232:	df 91       	pop	r29
 234:	cf 91       	pop	r28
 236:	1f 91       	pop	r17
 238:	0f 91       	pop	r16
 23a:	ff 90       	pop	r15
 23c:	ef 90       	pop	r14
 23e:	df 90       	pop	r13
 240:	08 95       	ret

Disassembly of section .text.vTaskSwitchContext:

0000070e <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 70e:	80 91 94 00 	lds	r24, 0x0094	; 0x800094 <uxSchedulerSuspended>
 712:	88 23       	and	r24, r24
 714:	21 f0       	breq	.+8      	; 0x71e <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 716:	81 e0       	ldi	r24, 0x01	; 1
 718:	80 93 96 00 	sts	0x0096, r24	; 0x800096 <xYieldPending>
 71c:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
 71e:	10 92 96 00 	sts	0x0096, r1	; 0x800096 <xYieldPending>
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
 722:	05 c0       	rjmp	.+10     	; 0x72e <vTaskSwitchContext+0x20>
 724:	80 91 98 00 	lds	r24, 0x0098	; 0x800098 <uxTopReadyPriority>
 728:	81 50       	subi	r24, 0x01	; 1
 72a:	80 93 98 00 	sts	0x0098, r24	; 0x800098 <uxTopReadyPriority>
 72e:	80 91 98 00 	lds	r24, 0x0098	; 0x800098 <uxTopReadyPriority>
 732:	90 e0       	ldi	r25, 0x00	; 0
 734:	fc 01       	movw	r30, r24
 736:	ee 0f       	add	r30, r30
 738:	ff 1f       	adc	r31, r31
 73a:	ee 0f       	add	r30, r30
 73c:	ff 1f       	adc	r31, r31
 73e:	ee 0f       	add	r30, r30
 740:	ff 1f       	adc	r31, r31
 742:	8e 0f       	add	r24, r30
 744:	9f 1f       	adc	r25, r31
 746:	fc 01       	movw	r30, r24
 748:	e0 5a       	subi	r30, 0xA0	; 160
 74a:	ff 4f       	sbci	r31, 0xFF	; 255
 74c:	80 81       	ld	r24, Z
 74e:	88 23       	and	r24, r24
 750:	49 f3       	breq	.-46     	; 0x724 <vTaskSwitchContext+0x16>
 752:	80 91 98 00 	lds	r24, 0x0098	; 0x800098 <uxTopReadyPriority>
 756:	90 e0       	ldi	r25, 0x00	; 0
 758:	9c 01       	movw	r18, r24
 75a:	22 0f       	add	r18, r18
 75c:	33 1f       	adc	r19, r19
 75e:	22 0f       	add	r18, r18
 760:	33 1f       	adc	r19, r19
 762:	22 0f       	add	r18, r18
 764:	33 1f       	adc	r19, r19
 766:	28 0f       	add	r18, r24
 768:	39 1f       	adc	r19, r25
 76a:	d9 01       	movw	r26, r18
 76c:	a0 5a       	subi	r26, 0xA0	; 160
 76e:	bf 4f       	sbci	r27, 0xFF	; 255
 770:	11 96       	adiw	r26, 0x01	; 1
 772:	ed 91       	ld	r30, X+
 774:	fc 91       	ld	r31, X
 776:	12 97       	sbiw	r26, 0x02	; 2
 778:	02 80       	ldd	r0, Z+2	; 0x02
 77a:	f3 81       	ldd	r31, Z+3	; 0x03
 77c:	e0 2d       	mov	r30, r0
 77e:	12 96       	adiw	r26, 0x02	; 2
 780:	fc 93       	st	X, r31
 782:	ee 93       	st	-X, r30
 784:	11 97       	sbiw	r26, 0x01	; 1
 786:	2d 59       	subi	r18, 0x9D	; 157
 788:	3f 4f       	sbci	r19, 0xFF	; 255
 78a:	e2 17       	cp	r30, r18
 78c:	f3 07       	cpc	r31, r19
 78e:	29 f4       	brne	.+10     	; 0x79a <vTaskSwitchContext+0x8c>
 790:	22 81       	ldd	r18, Z+2	; 0x02
 792:	33 81       	ldd	r19, Z+3	; 0x03
 794:	fd 01       	movw	r30, r26
 796:	32 83       	std	Z+2, r19	; 0x02
 798:	21 83       	std	Z+1, r18	; 0x01
 79a:	fc 01       	movw	r30, r24
 79c:	ee 0f       	add	r30, r30
 79e:	ff 1f       	adc	r31, r31
 7a0:	ee 0f       	add	r30, r30
 7a2:	ff 1f       	adc	r31, r31
 7a4:	ee 0f       	add	r30, r30
 7a6:	ff 1f       	adc	r31, r31
 7a8:	8e 0f       	add	r24, r30
 7aa:	9f 1f       	adc	r25, r31
 7ac:	fc 01       	movw	r30, r24
 7ae:	e0 5a       	subi	r30, 0xA0	; 160
 7b0:	ff 4f       	sbci	r31, 0xFF	; 255
 7b2:	01 80       	ldd	r0, Z+1	; 0x01
 7b4:	f2 81       	ldd	r31, Z+2	; 0x02
 7b6:	e0 2d       	mov	r30, r0
 7b8:	86 81       	ldd	r24, Z+6	; 0x06
 7ba:	97 81       	ldd	r25, Z+7	; 0x07
 7bc:	90 93 91 00 	sts	0x0091, r25	; 0x800091 <pxCurrentTCB+0x1>
 7c0:	80 93 90 00 	sts	0x0090, r24	; 0x800090 <pxCurrentTCB>
 7c4:	08 95       	ret

Disassembly of section .text:

00000d88 <__cmpsf2>:
 d88:	0e 94 65 05 	call	0xaca	; 0xaca <__fp_cmp>
 d8c:	08 f4       	brcc	.+2      	; 0xd90 <__cmpsf2+0x8>
 d8e:	81 e0       	ldi	r24, 0x01	; 1
 d90:	08 95       	ret

Disassembly of section .text:

0000085a <__floatunsisf>:
 85a:	e8 94       	clt
 85c:	09 c0       	rjmp	.+18     	; 0x870 <__stack+0x11>

0000085e <__floatsisf>:
 85e:	97 fb       	bst	r25, 7
 860:	3e f4       	brtc	.+14     	; 0x870 <__stack+0x11>
 862:	90 95       	com	r25
 864:	80 95       	com	r24
 866:	70 95       	com	r23
 868:	61 95       	neg	r22
 86a:	7f 4f       	sbci	r23, 0xFF	; 255
 86c:	8f 4f       	sbci	r24, 0xFF	; 255
 86e:	9f 4f       	sbci	r25, 0xFF	; 255
 870:	99 23       	and	r25, r25
 872:	a9 f0       	breq	.+42     	; 0x89e <__stack+0x3f>
 874:	f9 2f       	mov	r31, r25
 876:	96 e9       	ldi	r25, 0x96	; 150
 878:	bb 27       	eor	r27, r27
 87a:	93 95       	inc	r25
 87c:	f6 95       	lsr	r31
 87e:	87 95       	ror	r24
 880:	77 95       	ror	r23
 882:	67 95       	ror	r22
 884:	b7 95       	ror	r27
 886:	f1 11       	cpse	r31, r1
 888:	f8 cf       	rjmp	.-16     	; 0x87a <__stack+0x1b>
 88a:	fa f4       	brpl	.+62     	; 0x8ca <__stack+0x6b>
 88c:	bb 0f       	add	r27, r27
 88e:	11 f4       	brne	.+4      	; 0x894 <__stack+0x35>
 890:	60 ff       	sbrs	r22, 0
 892:	1b c0       	rjmp	.+54     	; 0x8ca <__stack+0x6b>
 894:	6f 5f       	subi	r22, 0xFF	; 255
 896:	7f 4f       	sbci	r23, 0xFF	; 255
 898:	8f 4f       	sbci	r24, 0xFF	; 255
 89a:	9f 4f       	sbci	r25, 0xFF	; 255
 89c:	16 c0       	rjmp	.+44     	; 0x8ca <__stack+0x6b>
 89e:	88 23       	and	r24, r24
 8a0:	11 f0       	breq	.+4      	; 0x8a6 <__stack+0x47>
 8a2:	96 e9       	ldi	r25, 0x96	; 150
 8a4:	11 c0       	rjmp	.+34     	; 0x8c8 <__stack+0x69>
 8a6:	77 23       	and	r23, r23
 8a8:	21 f0       	breq	.+8      	; 0x8b2 <__stack+0x53>
 8aa:	9e e8       	ldi	r25, 0x8E	; 142
 8ac:	87 2f       	mov	r24, r23
 8ae:	76 2f       	mov	r23, r22
 8b0:	05 c0       	rjmp	.+10     	; 0x8bc <__stack+0x5d>
 8b2:	66 23       	and	r22, r22
 8b4:	71 f0       	breq	.+28     	; 0x8d2 <__stack+0x73>
 8b6:	96 e8       	ldi	r25, 0x86	; 134
 8b8:	86 2f       	mov	r24, r22
 8ba:	70 e0       	ldi	r23, 0x00	; 0
 8bc:	60 e0       	ldi	r22, 0x00	; 0
 8be:	2a f0       	brmi	.+10     	; 0x8ca <__stack+0x6b>
 8c0:	9a 95       	dec	r25
 8c2:	66 0f       	add	r22, r22
 8c4:	77 1f       	adc	r23, r23
 8c6:	88 1f       	adc	r24, r24
 8c8:	da f7       	brpl	.-10     	; 0x8c0 <__stack+0x61>
 8ca:	88 0f       	add	r24, r24
 8cc:	96 95       	lsr	r25
 8ce:	87 95       	ror	r24
 8d0:	97 f9       	bld	r25, 7
 8d2:	08 95       	ret

Disassembly of section .text:

00000aca <__fp_cmp>:
 aca:	99 0f       	add	r25, r25
 acc:	00 08       	sbc	r0, r0
 ace:	55 0f       	add	r21, r21
 ad0:	aa 0b       	sbc	r26, r26
 ad2:	e0 e8       	ldi	r30, 0x80	; 128
 ad4:	fe ef       	ldi	r31, 0xFE	; 254
 ad6:	16 16       	cp	r1, r22
 ad8:	17 06       	cpc	r1, r23
 ada:	e8 07       	cpc	r30, r24
 adc:	f9 07       	cpc	r31, r25
 ade:	c0 f0       	brcs	.+48     	; 0xb10 <__fp_cmp+0x46>
 ae0:	12 16       	cp	r1, r18
 ae2:	13 06       	cpc	r1, r19
 ae4:	e4 07       	cpc	r30, r20
 ae6:	f5 07       	cpc	r31, r21
 ae8:	98 f0       	brcs	.+38     	; 0xb10 <__fp_cmp+0x46>
 aea:	62 1b       	sub	r22, r18
 aec:	73 0b       	sbc	r23, r19
 aee:	84 0b       	sbc	r24, r20
 af0:	95 0b       	sbc	r25, r21
 af2:	39 f4       	brne	.+14     	; 0xb02 <__fp_cmp+0x38>
 af4:	0a 26       	eor	r0, r26
 af6:	61 f0       	breq	.+24     	; 0xb10 <__fp_cmp+0x46>
 af8:	23 2b       	or	r18, r19
 afa:	24 2b       	or	r18, r20
 afc:	25 2b       	or	r18, r21
 afe:	21 f4       	brne	.+8      	; 0xb08 <__fp_cmp+0x3e>
 b00:	08 95       	ret
 b02:	0a 26       	eor	r0, r26
 b04:	09 f4       	brne	.+2      	; 0xb08 <__fp_cmp+0x3e>
 b06:	a1 40       	sbci	r26, 0x01	; 1
 b08:	a6 95       	lsr	r26
 b0a:	8f ef       	ldi	r24, 0xFF	; 255
 b0c:	81 1d       	adc	r24, r1
 b0e:	81 1d       	adc	r24, r1
 b10:	08 95       	ret

Disassembly of section .text:

00000d92 <__gesf2>:
 d92:	0e 94 65 05 	call	0xaca	; 0xaca <__fp_cmp>
 d96:	08 f4       	brcc	.+2      	; 0xd9a <__gesf2+0x8>
 d98:	8f ef       	ldi	r24, 0xFF	; 255
 d9a:	08 95       	ret

Disassembly of section .text.libgcc.div:

00000b12 <__udivmodsi4>:
 b12:	a1 e2       	ldi	r26, 0x21	; 33
 b14:	1a 2e       	mov	r1, r26
 b16:	aa 1b       	sub	r26, r26
 b18:	bb 1b       	sub	r27, r27
 b1a:	fd 01       	movw	r30, r26
 b1c:	0d c0       	rjmp	.+26     	; 0xb38 <__udivmodsi4_ep>

00000b1e <__udivmodsi4_loop>:
 b1e:	aa 1f       	adc	r26, r26
 b20:	bb 1f       	adc	r27, r27
 b22:	ee 1f       	adc	r30, r30
 b24:	ff 1f       	adc	r31, r31
 b26:	a2 17       	cp	r26, r18
 b28:	b3 07       	cpc	r27, r19
 b2a:	e4 07       	cpc	r30, r20
 b2c:	f5 07       	cpc	r31, r21
 b2e:	20 f0       	brcs	.+8      	; 0xb38 <__udivmodsi4_ep>
 b30:	a2 1b       	sub	r26, r18
 b32:	b3 0b       	sbc	r27, r19
 b34:	e4 0b       	sbc	r30, r20
 b36:	f5 0b       	sbc	r31, r21

00000b38 <__udivmodsi4_ep>:
 b38:	66 1f       	adc	r22, r22
 b3a:	77 1f       	adc	r23, r23
 b3c:	88 1f       	adc	r24, r24
 b3e:	99 1f       	adc	r25, r25
 b40:	1a 94       	dec	r1
 b42:	69 f7       	brne	.-38     	; 0xb1e <__udivmodsi4_loop>
 b44:	60 95       	com	r22
 b46:	70 95       	com	r23
 b48:	80 95       	com	r24
 b4a:	90 95       	com	r25
 b4c:	9b 01       	movw	r18, r22
 b4e:	ac 01       	movw	r20, r24
 b50:	bd 01       	movw	r22, r26
 b52:	cf 01       	movw	r24, r30
 b54:	08 95       	ret

Disassembly of section .text.libgcc.div:

00000c3e <__divmodsi4>:
 c3e:	05 2e       	mov	r0, r21
 c40:	97 fb       	bst	r25, 7
 c42:	1e f4       	brtc	.+6      	; 0xc4a <__divmodsi4+0xc>
 c44:	00 94       	com	r0
 c46:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <__negsi2>
 c4a:	57 fd       	sbrc	r21, 7
 c4c:	07 d0       	rcall	.+14     	; 0xc5c <__divmodsi4_neg2>
 c4e:	0e 94 89 05 	call	0xb12	; 0xb12 <__udivmodsi4>
 c52:	07 fc       	sbrc	r0, 7
 c54:	03 d0       	rcall	.+6      	; 0xc5c <__divmodsi4_neg2>
 c56:	4e f4       	brtc	.+18     	; 0xc6a <__divmodsi4_exit>
 c58:	0c 94 5b 06 	jmp	0xcb6	; 0xcb6 <__negsi2>

00000c5c <__divmodsi4_neg2>:
 c5c:	50 95       	com	r21
 c5e:	40 95       	com	r20
 c60:	30 95       	com	r19
 c62:	21 95       	neg	r18
 c64:	3f 4f       	sbci	r19, 0xFF	; 255
 c66:	4f 4f       	sbci	r20, 0xFF	; 255
 c68:	5f 4f       	sbci	r21, 0xFF	; 255

00000c6a <__divmodsi4_exit>:
 c6a:	08 95       	ret

Disassembly of section .text.libgcc.div:

00000cb6 <__negsi2>:
 cb6:	90 95       	com	r25
 cb8:	80 95       	com	r24
 cba:	70 95       	com	r23
 cbc:	61 95       	neg	r22
 cbe:	7f 4f       	sbci	r23, 0xFF	; 255
 cc0:	8f 4f       	sbci	r24, 0xFF	; 255
 cc2:	9f 4f       	sbci	r25, 0xFF	; 255
 cc4:	08 95       	ret

Disassembly of section .text.libgcc:

00000d72 <__tablejump2__>:
 d72:	ee 0f       	add	r30, r30
 d74:	ff 1f       	adc	r31, r31
 d76:	05 90       	lpm	r0, Z+
 d78:	f4 91       	lpm	r31, Z
 d7a:	e0 2d       	mov	r30, r0
 d7c:	09 94       	ijmp

Disassembly of section .text.__dummy_fini:

00000daa <_fini>:
 daa:	08 95       	ret

Disassembly of section .text.__dummy_funcs_on_exit:

00000dac <__funcs_on_exit>:
 dac:	08 95       	ret

Disassembly of section .text.__dummy_simulator_exit:

00000dae <__simulator_exit>:
 dae:	08 95       	ret

Disassembly of section .text.exit:

00000c8e <exit>:
 c8e:	ec 01       	movw	r28, r24
 c90:	0e 94 d6 06 	call	0xdac	; 0xdac <__funcs_on_exit>
 c94:	0e 94 d5 06 	call	0xdaa	; 0xdaa <_fini>
 c98:	ce 01       	movw	r24, r28
 c9a:	0e 94 d7 06 	call	0xdae	; 0xdae <__simulator_exit>
 c9e:	ce 01       	movw	r24, r28
 ca0:	0e 94 d3 06 	call	0xda6	; 0xda6 <_Exit>

Disassembly of section .text._Exit:

00000da6 <_Exit>:
 da6:	0e 94 63 00 	call	0xc6	; 0xc6 <_exit>
